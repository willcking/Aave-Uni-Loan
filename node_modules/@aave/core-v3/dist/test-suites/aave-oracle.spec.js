"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@aave/deploy-v3/dist/helpers/constants");
const chai_1 = require("chai");
const constants_2 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('AaveOracle', (testEnv) => {
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    let mockToken;
    let mockAggregator;
    let assetPrice;
    before(async () => {
        mockToken = await (0, deploy_v3_1.deployMintableERC20)(['MOCK', 'MOCK', '18']);
        assetPrice = constants_1.MOCK_CHAINLINK_AGGREGATORS_PRICES.ETH;
        mockAggregator = await (0, deploy_v3_1.deployMockAggregator)(assetPrice);
    });
    it('Owner set a new asset source', async () => {
        const { poolAdmin, aaveOracle } = testEnv;
        // Asset has no source
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(constants_2.ZERO_ADDRESS);
        const priorSourcePrice = await aaveOracle.getAssetPrice(mockToken.address);
        const priorSourcesPrices = (await aaveOracle.getAssetsPrices([mockToken.address])).map((x) => x.toString());
        (0, chai_1.expect)(priorSourcePrice).to.equal('0');
        (0, chai_1.expect)(priorSourcesPrices).to.eql(['0']);
        // Add asset source
        await (0, chai_1.expect)(aaveOracle
            .connect(poolAdmin.signer)
            .setAssetSources([mockToken.address], [mockAggregator.address]))
            .to.emit(aaveOracle, 'AssetSourceUpdated')
            .withArgs(mockToken.address, mockAggregator.address);
        const sourcesPrices = await (await aaveOracle.getAssetsPrices([mockToken.address])).map((x) => x.toString());
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(mockAggregator.address);
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(mockToken.address)).to.be.eq(assetPrice);
        (0, chai_1.expect)(sourcesPrices).to.eql([assetPrice]);
    });
    it('Owner update an existing asset source', async () => {
        const { poolAdmin, aaveOracle, dai } = testEnv;
        // DAI token has already a source
        const daiSource = await aaveOracle.getSourceOfAsset(dai.address);
        (0, chai_1.expect)(daiSource).to.be.not.eq(constants_2.ZERO_ADDRESS);
        // Update DAI source
        await (0, chai_1.expect)(aaveOracle.connect(poolAdmin.signer).setAssetSources([dai.address], [mockAggregator.address]))
            .to.emit(aaveOracle, 'AssetSourceUpdated')
            .withArgs(dai.address, mockAggregator.address);
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(dai.address)).to.be.eq(mockAggregator.address);
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(dai.address)).to.be.eq(assetPrice);
    });
    it('Owner tries to set a new asset source with wrong input params (revert expected)', async () => {
        const { poolAdmin, aaveOracle } = testEnv;
        await (0, chai_1.expect)(aaveOracle.connect(poolAdmin.signer).setAssetSources([mockToken.address], [])).to.be.revertedWith(types_1.ProtocolErrors.INCONSISTENT_PARAMS_LENGTH);
    });
    it('Get price of BASE_CURRENCY asset', async () => {
        const { aaveOracle } = testEnv;
        // Check returns the fixed price BASE_CURRENCY_UNIT
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(await aaveOracle.BASE_CURRENCY())).to.be.eq(await aaveOracle.BASE_CURRENCY_UNIT());
    });
    it('A non-owner user tries to set a new asset source (revert expected)', async () => {
        const { users, aaveOracle } = testEnv;
        const user = users[0];
        const { CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN } = types_1.ProtocolErrors;
        await (0, chai_1.expect)(aaveOracle.connect(user.signer).setAssetSources([mockToken.address], [mockAggregator.address])).to.be.revertedWith(CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN);
    });
    it('Get price of BASE_CURRENCY asset with registered asset source for its address', async () => {
        const { poolAdmin, aaveOracle, weth } = testEnv;
        // Add asset source for BASE_CURRENCY address
        await (0, chai_1.expect)(aaveOracle.connect(poolAdmin.signer).setAssetSources([weth.address], [mockAggregator.address]))
            .to.emit(aaveOracle, 'AssetSourceUpdated')
            .withArgs(weth.address, mockAggregator.address);
        // Check returns the fixed price BASE_CURRENCY_UNIT
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(weth.address)).to.be.eq(constants_1.MOCK_CHAINLINK_AGGREGATORS_PRICES.WETH);
    });
    it('Get price of asset with no asset source', async () => {
        const { aaveOracle, oracle } = testEnv;
        const fallbackPrice = constants_2.oneEther;
        // Register price on FallbackOracle
        (0, chai_1.expect)(await oracle.setAssetPrice(mockToken.address, fallbackPrice));
        // Asset has no source
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(constants_2.ZERO_ADDRESS);
        // Returns 0 price
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(mockToken.address)).to.be.eq(fallbackPrice);
    });
    it('Get price of asset with 0 price and no fallback price', async () => {
        const { poolAdmin, aaveOracle } = testEnv;
        const zeroPriceMockAgg = await (0, deploy_v3_1.deployMockAggregator)('0');
        // Asset has no source
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(constants_2.ZERO_ADDRESS);
        // Add asset source
        await (0, chai_1.expect)(aaveOracle
            .connect(poolAdmin.signer)
            .setAssetSources([mockToken.address], [zeroPriceMockAgg.address]))
            .to.emit(aaveOracle, 'AssetSourceUpdated')
            .withArgs(mockToken.address, zeroPriceMockAgg.address);
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(zeroPriceMockAgg.address);
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(mockToken.address)).to.be.eq(0);
    });
    it('Get price of asset with 0 price but non-zero fallback price', async () => {
        const { poolAdmin, aaveOracle, oracle } = testEnv;
        const zeroPriceMockAgg = await (0, deploy_v3_1.deployMockAggregator)('0');
        const fallbackPrice = constants_2.oneEther;
        // Register price on FallbackOracle
        (0, chai_1.expect)(await oracle.setAssetPrice(mockToken.address, fallbackPrice));
        // Asset has no source
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(constants_2.ZERO_ADDRESS);
        // Add asset source
        await (0, chai_1.expect)(aaveOracle
            .connect(poolAdmin.signer)
            .setAssetSources([mockToken.address], [zeroPriceMockAgg.address]))
            .to.emit(aaveOracle, 'AssetSourceUpdated')
            .withArgs(mockToken.address, zeroPriceMockAgg.address);
        (0, chai_1.expect)(await aaveOracle.getSourceOfAsset(mockToken.address)).to.be.eq(zeroPriceMockAgg.address);
        (0, chai_1.expect)(await aaveOracle.getAssetPrice(mockToken.address)).to.be.eq(fallbackPrice);
    });
    it('Owner update the FallbackOracle', async () => {
        const { poolAdmin, aaveOracle, oracle } = testEnv;
        (0, chai_1.expect)(await aaveOracle.getFallbackOracle()).to.be.eq(oracle.address);
        // Update oracle source
        await (0, chai_1.expect)(aaveOracle.connect(poolAdmin.signer).setFallbackOracle(constants_2.ONE_ADDRESS))
            .to.emit(aaveOracle, 'FallbackOracleUpdated')
            .withArgs(constants_2.ONE_ADDRESS);
        (0, chai_1.expect)(await aaveOracle.getFallbackOracle()).to.be.eq(constants_2.ONE_ADDRESS);
    });
});
