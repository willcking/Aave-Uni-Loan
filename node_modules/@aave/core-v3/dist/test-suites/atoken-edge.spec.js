"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const misc_utils_1 = require("../helpers/misc-utils");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const funds_1 = require("./helpers/utils/funds");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('AToken: Edge cases', (testEnv) => {
    const { INVALID_MINT_AMOUNT, INVALID_BURN_AMOUNT, SAFECAST_UINT128_OVERFLOW, CALLER_NOT_POOL_ADMIN, } = types_1.ProtocolErrors;
    it('Check getters', async () => {
        const { pool, users, dai, aDai, faucetMintable, deployer } = testEnv;
        (0, chai_1.expect)(await aDai.decimals()).to.be.eq(await dai.decimals());
        (0, chai_1.expect)(await aDai.UNDERLYING_ASSET_ADDRESS()).to.be.eq(dai.address);
        (0, chai_1.expect)(await aDai.POOL()).to.be.eq(pool.address);
        (0, chai_1.expect)(await aDai.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        const scaledUserBalanceAndSupplyBefore = await aDai.getScaledUserBalanceAndSupply(users[0].address);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyBefore[0]).to.be.eq(0);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyBefore[1]).to.be.eq(0);
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000')));
        await (0, deploy_v3_1.waitForTx)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'), users[0].address, 0));
        const scaledUserBalanceAndSupplyAfter = await aDai.getScaledUserBalanceAndSupply(users[0].address);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyAfter[0]).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1000'));
        (0, chai_1.expect)(scaledUserBalanceAndSupplyAfter[1]).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1000'));
    });
    it('approve()', async () => {
        const { users, aDai } = testEnv;
        await aDai.connect(users[0].signer).approve(users[1].address, constants_1.MAX_UINT_AMOUNT);
        (0, chai_1.expect)(await aDai.allowance(users[0].address, users[1].address)).to.be.eq(constants_1.MAX_UINT_AMOUNT);
    });
    it('approve() with a ZERO_ADDRESS spender', async () => {
        const { users, aDai } = testEnv;
        await (0, chai_1.expect)(aDai.connect(users[0].signer).approve(constants_1.ZERO_ADDRESS, constants_1.MAX_UINT_AMOUNT))
            .to.emit(aDai, 'Approval')
            .withArgs(users[0].address, constants_1.ZERO_ADDRESS, constants_1.MAX_UINT_AMOUNT);
    });
    it('transferFrom()', async () => {
        const { users, aDai } = testEnv;
        await aDai.connect(users[1].signer).transferFrom(users[0].address, users[1].address, 0);
    });
    it('increaseAllowance()', async () => {
        const { users, aDai } = testEnv;
        (0, chai_1.expect)(await aDai.allowance(users[1].address, users[0].address)).to.be.eq(0);
        await aDai
            .connect(users[1].signer)
            .increaseAllowance(users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1'));
        (0, chai_1.expect)(await aDai.allowance(users[1].address, users[0].address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1'));
    });
    it('decreaseAllowance()', async () => {
        const { users, aDai } = testEnv;
        (0, chai_1.expect)(await aDai.allowance(users[1].address, users[0].address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1'));
        await aDai
            .connect(users[1].signer)
            .decreaseAllowance(users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '1'));
        (0, chai_1.expect)(await aDai.allowance(users[1].address, users[0].address)).to.be.eq(0);
    });
    it('transfer() with a ZERO_ADDRESS recipient', async () => {
        const { users, aDai } = testEnv;
        await (0, chai_1.expect)(aDai.connect(users[1].signer).transfer(constants_1.ZERO_ADDRESS, 0))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[1].address, constants_1.ZERO_ADDRESS, 0);
    });
    it('transfer() with a ZERO_ADDRESS origin', async () => {
        const { users, aDai } = testEnv;
        await (0, chai_1.expect)(aDai.connect(users[1].signer).transferFrom(constants_1.ZERO_ADDRESS, users[1].address, 0))
            .to.emit(aDai, 'Transfer')
            .withArgs(constants_1.ZERO_ADDRESS, users[1].address, 0);
    });
    it('mint() when amountScaled == 0 (revert expected)', async () => {
        const { deployer, pool, aDai, users } = testEnv;
        // Impersonate Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        await (0, chai_1.expect)(aDai
            .connect(poolSigner)
            .mint(users[0].address, users[0].address, 0, ethers_1.utils.parseUnits('1', 27))).to.be.revertedWith(INVALID_MINT_AMOUNT);
    });
    it('mint() to a ZERO_ADDRESS account', async () => {
        const { deployer, pool, aDai } = testEnv;
        // Impersonate Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const mintingAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '100');
        await (0, chai_1.expect)(aDai
            .connect(poolSigner)
            .mint(constants_1.ZERO_ADDRESS, constants_1.ZERO_ADDRESS, mintingAmount, ethers_1.utils.parseUnits('1', 27)))
            .to.emit(aDai, 'Transfer')
            .withArgs(constants_1.ZERO_ADDRESS, constants_1.ZERO_ADDRESS, mintingAmount);
    });
    it('burn() when amountScaled == 0 (revert expected)', async () => {
        const { deployer, pool, aDai, users } = testEnv;
        // Impersonate Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        await (0, chai_1.expect)(aDai
            .connect(poolSigner)
            .burn(users[0].address, users[0].address, 0, ethers_1.utils.parseUnits('1', 27))).to.be.revertedWith(INVALID_BURN_AMOUNT);
    });
    it('burn() of a ZERO_ADDRESS account (revert expected)', async () => {
        const { deployer, pool, aDai, users } = testEnv;
        // Impersonate Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const burnAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(aDai.address, '100');
        await (0, chai_1.expect)(aDai
            .connect(poolSigner)
            .burn(constants_1.ZERO_ADDRESS, users[0].address, burnAmount, ethers_1.utils.parseUnits('1', 27)))
            .to.emit(aDai, 'Transfer')
            .withArgs(constants_1.ZERO_ADDRESS, constants_1.ZERO_ADDRESS, burnAmount);
    });
    it('mintToTreasury() with amount == 0', async () => {
        const { deployer, pool, aDai } = testEnv;
        // Impersonate Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        (0, chai_1.expect)(await aDai.connect(poolSigner).mintToTreasury(0, ethers_1.utils.parseUnits('1', 27)));
    });
    it('setIncentivesController() ', async () => {
        const snapshot = await (0, deploy_v3_1.evmSnapshot)();
        const { deployer, poolAdmin, aWETH, aclManager } = testEnv;
        (0, chai_1.expect)(await aclManager.connect(deployer.signer).addPoolAdmin(poolAdmin.address));
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(await aWETH.connect(poolAdmin.signer).setIncentivesController(constants_1.ZERO_ADDRESS));
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.be.eq(constants_1.ZERO_ADDRESS);
        await (0, deploy_v3_1.evmRevert)(snapshot);
    });
    it('setIncentivesController() from not pool admin (revert expected)', async () => {
        const { users: [user], aWETH, } = testEnv;
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        await (0, chai_1.expect)(aWETH.connect(user.signer).setIncentivesController(constants_1.ZERO_ADDRESS)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('transfer() amount > MAX_UINT_128', async () => {
        const { aDai, users: [depositor, borrower], } = testEnv;
        (0, chai_1.expect)(aDai.transfer(borrower.address, constants_1.MAX_UINT_AMOUNT)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('setIncentivesController() ', async () => {
        const snapshot = await (0, deploy_v3_1.evmSnapshot)();
        const { deployer, poolAdmin, aWETH, aclManager } = testEnv;
        (0, chai_1.expect)(await aclManager.connect(deployer.signer).addPoolAdmin(poolAdmin.address));
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(await aWETH.connect(poolAdmin.signer).setIncentivesController(constants_1.ZERO_ADDRESS));
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.be.eq(constants_1.ZERO_ADDRESS);
        await (0, deploy_v3_1.evmRevert)(snapshot);
    });
    it('setIncentivesController() from not pool admin (revert expected)', async () => {
        const { users: [user], aWETH, } = testEnv;
        (0, chai_1.expect)(await aWETH.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        await (0, chai_1.expect)(aWETH.connect(user.signer).setIncentivesController(constants_1.ZERO_ADDRESS)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
});
