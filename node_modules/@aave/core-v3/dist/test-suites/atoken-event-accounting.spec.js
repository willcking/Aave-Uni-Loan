"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const tokenization_events_1 = require("./helpers/utils/tokenization-events");
const types_2 = require("../types");
(0, make_suite_1.makeSuite)('AToken: Mint and Burn Event Accounting', (testEnv) => {
    let firstDaiDeposit;
    let secondDaiDeposit;
    let thirdDaiDeposit;
    let accruedInterest1 = ethers_1.BigNumber.from(0);
    let accruedInterest2 = ethers_1.BigNumber.from(0);
    let accruedInterest3 = ethers_1.BigNumber.from(0);
    let firstDaiBorrow;
    let secondDaiBorrow;
    let accruedDebt1 = ethers_1.BigNumber.from(0);
    let accruedDebt2 = ethers_1.BigNumber.from(0);
    let accruedDebt3 = ethers_1.BigNumber.from(0);
    let aTokenRepayImpl;
    const transferEventSignature = ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('Transfer(address,address,uint256)'));
    before('User 0 deposits 100 DAI, user 1 deposits 1 WETH, borrows 50 DAI', async () => {
        const { dai, configurator, aDai, deployer, pool } = testEnv;
        firstDaiDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000');
        secondDaiDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '20000');
        thirdDaiDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '50000');
        aTokenRepayImpl = await new types_2.MockATokenRepayment__factory(deployer.signer).deploy(pool.address);
        await configurator.updateAToken({
            asset: dai.address,
            treasury: await aDai.RESERVE_TREASURY_ADDRESS(),
            incentivesController: await aDai.getIncentivesController(),
            name: await aDai.name(),
            symbol: await aDai.symbol(),
            implementation: aTokenRepayImpl.address,
            params: '0x',
        });
    });
    it('User 1 supplies DAI', async () => {
        const { dai, aDai, users: [depositor], pool, helpersContract, faucetMintable, deployer, } = testEnv;
        // mints DAI to depositor
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000')));
        // approve protocol to access depositor wallet
        await (0, deploy_v3_1.waitForTx)(await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        const daiReserveData = await helpersContract.getReserveData(dai.address);
        const expectedBalanceIncrease = 0;
        await (0, chai_1.expect)(pool.connect(depositor.signer).deposit(dai.address, firstDaiDeposit, depositor.address, '0'))
            .to.emit(aDai, 'Mint')
            .withArgs(depositor.address, depositor.address, firstDaiDeposit, expectedBalanceIncrease, daiReserveData.liquidityIndex);
        const aDaiBalance = await aDai.balanceOf(depositor.address);
        (0, chai_1.expect)(aDaiBalance).to.be.equal(firstDaiDeposit);
    });
    it('User 1 supplies DAI on behalf of user 2', async () => {
        const { dai, aDai, users: [depositor, receiver], pool, helpersContract, faucetMintable, deployer, } = testEnv;
        // mints DAI to depositor
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000')));
        // approve protocol to access depositor wallet
        await (0, deploy_v3_1.waitForTx)(await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        const daiReserveData = await helpersContract.getReserveData(dai.address);
        const expectedBalanceIncrease = 0;
        await (0, chai_1.expect)(pool.connect(depositor.signer).deposit(dai.address, firstDaiDeposit, receiver.address, '0'))
            .to.emit(aDai, 'Mint')
            .withArgs(depositor.address, receiver.address, firstDaiDeposit, expectedBalanceIncrease, daiReserveData.liquidityIndex);
        const aDaiBalance = await aDai.balanceOf(receiver.address);
        (0, chai_1.expect)(aDaiBalance).to.be.equal(firstDaiDeposit);
    });
    it('User 2 supplies ETH,and borrows DAI', async () => {
        const { dai, weth, users: [, borrower], pool, helpersContract, faucetMintable, } = testEnv;
        // user 2 deposits 100 ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '20000');
        // mints WETH to borrower
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(weth.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '20000')));
        // approve protocol to access the borrower wallet
        await (0, deploy_v3_1.waitForTx)(await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0'));
        // Borrow DAI
        firstDaiBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '5000');
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, firstDaiBorrow, types_1.RateMode.Variable, '0', borrower.address));
        const borrowerWethData = await helpersContract.getUserReserveData(weth.address, borrower.address);
        const borrowerDaiData = await helpersContract.getUserReserveData(dai.address, borrower.address);
        (0, chai_1.expect)(borrowerWethData.currentATokenBalance).to.be.equal(amountETHtoDeposit);
        (0, chai_1.expect)(borrowerDaiData.currentVariableDebt).to.be.equal(firstDaiBorrow);
    });
    it('User 2 borrows more DAI - confirm mint event includes accrued interest', async () => {
        const { dai, variableDebtDai, users: [, borrower], pool, helpersContract, } = testEnv;
        await (0, deploy_v3_1.increaseTime)(86400);
        // execute borrow
        secondDaiBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '2000');
        const borrowTx = await pool
            .connect(borrower.signer)
            .borrow(dai.address, secondDaiBorrow, types_1.RateMode.Variable, '0', borrower.address);
        const borrowReceipt = await borrowTx.wait();
        const borrowerDaiData = await helpersContract.getUserReserveData(dai.address, borrower.address);
        accruedDebt1 = borrowerDaiData.currentVariableDebt.sub(firstDaiBorrow).sub(secondDaiBorrow);
        const totalMinted = secondDaiBorrow.add(accruedDebt1);
        // get transfer event
        const rawTransferEvents = borrowReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = variableDebtDai.interface.parseLog(rawTransferEvents[0]);
        // get mint event
        const parsedMintEvents = (0, tokenization_events_1.getVariableDebtTokenEvent)(variableDebtDai, borrowReceipt, 'Mint');
        (0, chai_1.expect)(parsedMintEvents.length).to.equal(1, 'Incorrect number of Mint Events');
        const parsedMintEvent = parsedMintEvents[0];
        // check transfer event parameters
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(borrower.address);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalMinted, 2);
        // check mint event parameters
        (0, chai_1.expect)(parsedMintEvent.caller).to.equal(borrower.address);
        (0, chai_1.expect)(parsedMintEvent.onBehalfOf).to.equal(borrower.address);
        (0, chai_1.expect)(parsedMintEvent.value).to.be.closeTo(totalMinted, 2);
        (0, chai_1.expect)(parsedMintEvent.balanceIncrease).to.be.closeTo(accruedDebt1, 2);
    });
    it('User 1 - supplies more DAI - confirm mint event includes accrued interest', async () => {
        const { dai, aDai, users: [depositor], pool, faucetMintable } = testEnv;
        await (0, deploy_v3_1.increaseTime)(86400);
        // mints DAI to depositor
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '20000')));
        // user 1 deposits 2000 DAI
        const depositTx = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(depositor.signer)
            .deposit(dai.address, secondDaiDeposit, depositor.address, '0'));
        const aDaiBalance = await aDai.balanceOf(depositor.address);
        accruedInterest1 = aDaiBalance.sub(firstDaiDeposit).sub(secondDaiDeposit);
        const totalMinted = secondDaiDeposit.add(accruedInterest1);
        // get transfer event
        const rawTransferEvents = depositTx.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = aDai.interface.parseLog(rawTransferEvents[1]);
        // get mint event
        const parsedMintEvents = (0, tokenization_events_1.getATokenEvent)(aDai, depositTx, 'Mint');
        (0, chai_1.expect)(parsedMintEvents.length).to.equal(1, 'Incorrect number of Mint Events');
        const parsedMintEvent = parsedMintEvents[0];
        // check transfer event parameters
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(depositor.address);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalMinted, 2);
        // check mint event parameters
        (0, chai_1.expect)(parsedMintEvent.caller).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.onBehalfOf).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.value).to.be.closeTo(totalMinted, 2);
        (0, chai_1.expect)(parsedMintEvent.balanceIncrease).to.be.closeTo(accruedInterest1, 2);
    });
    it('User 1 supplies more DAI again - confirm mint event includes accrued interest', async () => {
        const { dai, aDai, users: [depositor], pool, helpersContract, faucetMintable } = testEnv;
        await (0, deploy_v3_1.increaseTime)(86400);
        // mints DAI to depositor
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '50000')));
        // user 1 deposits 2000 DAI
        const depositTx = await pool
            .connect(depositor.signer)
            .deposit(dai.address, thirdDaiDeposit, depositor.address, '0');
        const depositReceipt = await depositTx.wait();
        const aDaiBalance = await aDai.balanceOf(depositor.address);
        accruedInterest2 = aDaiBalance
            .sub(firstDaiDeposit)
            .sub(secondDaiDeposit)
            .sub(thirdDaiDeposit)
            .sub(accruedInterest1);
        const daiReserveData = await helpersContract.getReserveData(dai.address);
        const totalMinted = thirdDaiDeposit.add(accruedInterest2);
        // get transfer event
        const rawTransferEvents = depositReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = aDai.interface.parseLog(rawTransferEvents[1]);
        // get mint event
        const parsedMintEvents = (0, tokenization_events_1.getATokenEvent)(aDai, depositReceipt, 'Mint');
        (0, chai_1.expect)(parsedMintEvents.length).to.equal(1, 'Incorrect number of Mint Events');
        const parsedMintEvent = parsedMintEvents[0];
        // check transfer event
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.be.equal(depositor.address);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalMinted, 2);
        // check mint event
        (0, chai_1.expect)(parsedMintEvent.caller).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.onBehalfOf).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.value).to.be.closeTo(totalMinted, 2);
        (0, chai_1.expect)(parsedMintEvent.balanceIncrease).to.be.closeTo(accruedInterest2, 2);
        (0, chai_1.expect)(parsedMintEvent.index).to.equal(daiReserveData.liquidityIndex);
    });
    it('User 2 repays all remaining DAI', async () => {
        const { dai, aDai, variableDebtDai, users: [, borrower], pool, helpersContract, faucetMintable } = testEnv;
        await (0, deploy_v3_1.increaseTime)(86400);
        //mints DAI to borrower
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '50000')));
        // approve protocol to access depositor wallet
        await (0, deploy_v3_1.waitForTx)(await dai.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        const daiBalanceBefore = await dai.balanceOf(borrower.address);
        // repay dai loan
        const repayTx = await pool
            .connect(borrower.signer)
            .repay(dai.address, constants_1.MAX_UINT_AMOUNT, types_1.RateMode.Variable, borrower.address);
        const repayReceipt = await repayTx.wait();
        const daiBalanceAfter = await dai.balanceOf(borrower.address);
        const daiRepaid = daiBalanceBefore.sub(daiBalanceAfter);
        accruedDebt3 = daiRepaid
            .sub(firstDaiBorrow)
            .sub(accruedDebt1)
            .sub(secondDaiBorrow)
            .sub(accruedDebt2);
        const borrowerDaiData = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const totalBurned = daiRepaid.sub(accruedDebt3);
        // get transfer event
        const rawTransferEvents = repayReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = variableDebtDai.interface.parseLog(rawTransferEvents[0]);
        // get burn event
        const parsedBurnEvents = (0, tokenization_events_1.getVariableDebtTokenEvent)(variableDebtDai, repayReceipt, 'Burn');
        (0, chai_1.expect)(parsedBurnEvents.length).to.equal(1, 'Incorrect number of Burn Events');
        const parsedBurnEvent = parsedBurnEvents[0];
        // check burn parameters
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(borrower.address);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalBurned, 2);
        // check burn parameters
        (0, chai_1.expect)(parsedBurnEvent.from).to.equal(borrower.address);
        (0, chai_1.expect)(parsedBurnEvent.value).to.be.closeTo(totalBurned, 2);
        (0, chai_1.expect)(parsedBurnEvent.balanceIncrease).to.be.closeTo(accruedDebt3, 2);
        (0, chai_1.expect)(borrowerDaiData.currentVariableDebt).to.be.equal(0);
        // check handleRepayment function is correctly called
        await (0, chai_1.expect)(repayTx)
            .to.emit(aTokenRepayImpl.attach(aDai.address), 'MockRepayment')
            .withArgs(borrower.address, borrower.address, daiRepaid);
    });
    it('User 1 withdraws all deposited funds and interest', async () => {
        const { dai, aDai, users: [depositor], pool, helpersContract, } = testEnv;
        const daiBalanceBefore = await dai.balanceOf(depositor.address);
        const withdrawTx = await pool
            .connect(depositor.signer)
            .withdraw(dai.address, constants_1.MAX_UINT_AMOUNT, depositor.address);
        const withdrawReceipt = await withdrawTx.wait();
        const aDaiBalance = await aDai.balanceOf(depositor.address);
        (0, chai_1.expect)(aDaiBalance).to.be.equal(0);
        const daiBalanceAfter = await dai.balanceOf(depositor.address);
        const daiWithdrawn = daiBalanceAfter.sub(daiBalanceBefore);
        accruedInterest3 = daiWithdrawn
            .sub(firstDaiDeposit)
            .sub(accruedInterest1)
            .sub(secondDaiDeposit)
            .sub(accruedInterest2)
            .sub(thirdDaiDeposit);
        const totalBurned = daiWithdrawn.sub(accruedInterest3);
        const daiReserveData = await helpersContract.getReserveData(dai.address);
        // get transfer event
        const rawTransferEvents = withdrawReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = aDai.interface.parseLog(rawTransferEvents[0]);
        // get burn event
        const parsedBurnEvents = (0, tokenization_events_1.getATokenEvent)(aDai, withdrawReceipt, 'Burn');
        (0, chai_1.expect)(parsedBurnEvents.length).to.equal(1, 'Incorrect number of Burn Events');
        const parsedBurnEvent = parsedBurnEvents[0];
        // check transfer parameters
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(depositor.address);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalBurned, 2);
        // check burn parameters
        (0, chai_1.expect)(parsedBurnEvent.from).to.equal(depositor.address);
        (0, chai_1.expect)(parsedBurnEvent.target).to.equal(depositor.address);
        (0, chai_1.expect)(parsedBurnEvent.value).to.be.closeTo(totalBurned, 2);
        (0, chai_1.expect)(parsedBurnEvent.balanceIncrease).to.be.closeTo(accruedInterest3, 2);
        (0, chai_1.expect)(parsedBurnEvent.index).to.equal(daiReserveData.liquidityIndex);
    });
    it('User 2 borrows, pass time and repay DAI less than accrued debt', async () => {
        const { dai, variableDebtDai, users: [depositor, borrower], pool, } = testEnv;
        // User 1 - Deposit DAI
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(depositor.signer)
            .deposit(dai.address, firstDaiDeposit, depositor.address, '0'));
        // User 2 - Borrow DAI
        const borrowAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '8000');
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Variable, '0', borrower.address));
        const debtBalanceBefore = await variableDebtDai.balanceOf(borrower.address);
        await (0, deploy_v3_1.increaseTime)(86400);
        // repay a very small amount - less than accrued debt
        const smallRepay = ethers_1.BigNumber.from('100000');
        // approve protocol to access depositor wallet
        await (0, deploy_v3_1.waitForTx)(await dai.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        // repay DAI loan
        const repayTx = await pool
            .connect(borrower.signer)
            .repay(dai.address, smallRepay, types_1.RateMode.Variable, borrower.address);
        const repayReceipt = await repayTx.wait();
        const debtBalanceAfter = await variableDebtDai.balanceOf(borrower.address);
        const totalMinted = debtBalanceAfter.sub(debtBalanceBefore);
        // get transfer event
        const rawTransferEvents = repayReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = variableDebtDai.interface.parseLog(rawTransferEvents[0]);
        // get mint event
        const parsedMintEvents = (0, tokenization_events_1.getVariableDebtTokenEvent)(variableDebtDai, repayReceipt, 'Mint');
        (0, chai_1.expect)(parsedMintEvents.length).to.equal(1, 'Incorrect number of Mint Events');
        const parsedMintEvent = parsedMintEvents[0];
        // check transfer event
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(borrower.address);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalMinted, 2);
        // check mint event
        (0, chai_1.expect)(parsedMintEvent.caller).to.equal(borrower.address);
        (0, chai_1.expect)(parsedMintEvent.onBehalfOf).to.equal(borrower.address);
        (0, chai_1.expect)(parsedMintEvent.value).to.be.closeTo(totalMinted, 2);
        (0, chai_1.expect)(parsedMintEvent.balanceIncrease).to.be.closeTo(totalMinted.add(smallRepay), 2);
    });
    it('User 1 withdraws amount less than accrued interest', async () => {
        const { dai, aDai, users: [depositor], pool, helpersContract, } = testEnv;
        // repay a very small amount - less than accrued debt
        const smallWithdrawal = ethers_1.BigNumber.from('100000');
        const withdrawTx = await pool
            .connect(depositor.signer)
            .withdraw(dai.address, smallWithdrawal, depositor.address);
        const withdrawReceipt = await withdrawTx.wait();
        const aTokenSupplyAfter = await aDai.balanceOf(depositor.address);
        const daiReserveData = await helpersContract.getReserveData(dai.address);
        const totalMinted = aTokenSupplyAfter.sub(firstDaiDeposit);
        // get transfer event
        const rawTransferEvents = withdrawReceipt.logs.filter((log) => log.topics[0] === transferEventSignature);
        (0, chai_1.expect)(rawTransferEvents.length).to.equal(2, 'Incorrect number of Transfer Events');
        const parsedTransferEvent = aDai.interface.parseLog(rawTransferEvents[0]);
        // get mint event
        const parsedMintEvents = (0, tokenization_events_1.getATokenEvent)(aDai, withdrawReceipt, 'Mint');
        (0, chai_1.expect)(parsedMintEvents.length).to.equal(1, 'Incorrect number of Mint Events');
        const parsedMintEvent = parsedMintEvents[0];
        // check transfer event
        (0, chai_1.expect)(parsedTransferEvent.args.from).to.equal(deploy_v3_1.ZERO_ADDRESS);
        (0, chai_1.expect)(parsedTransferEvent.args.to).to.equal(depositor.address);
        (0, chai_1.expect)(parsedTransferEvent.args.value).to.be.closeTo(totalMinted, 2);
        // check mint event
        (0, chai_1.expect)(parsedMintEvent.caller).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.onBehalfOf).to.equal(depositor.address);
        (0, chai_1.expect)(parsedMintEvent.value).to.be.closeTo(totalMinted, 2);
        (0, chai_1.expect)(parsedMintEvent.balanceIncrease).to.be.closeTo(totalMinted.add(smallWithdrawal), 2);
        (0, chai_1.expect)(parsedMintEvent.index).to.equal(daiReserveData.liquidityIndex);
    });
});
