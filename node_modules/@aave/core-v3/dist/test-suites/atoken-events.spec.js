"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const tokenization_events_1 = require("./helpers/utils/tokenization-events");
const DEBUG = false;
let balances = {
    balance: {},
};
const log = (str) => {
    if (DEBUG)
        console.log(str);
};
const printBalance = async (name, aToken, userAddress) => {
    console.log(name, 'balanceOf', await hardhat_1.ethers.utils.formatEther(await aToken.balanceOf(userAddress)), 'scaledBalance', await hardhat_1.ethers.utils.formatEther(await aToken.scaledBalanceOf(userAddress)));
};
const increaseSupplyIndex = async (pool, faucet, borrower, collateral, assetToIncrease) => {
    const collateralToken = deploy_v3_1.MintableERC20__factory.connect(collateral, borrower.signer);
    const borrowingToken = deploy_v3_1.MintableERC20__factory.connect(assetToIncrease, borrower.signer);
    await faucet.mint(collateralToken.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(collateralToken.address, '10000000'));
    await collateralToken.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
    await pool
        .connect(borrower.signer)
        .supply(collateral, await (0, contracts_helpers_1.convertToCurrencyDecimals)(collateral, '100000'), borrower.address, '0');
    const { aTokenAddress } = await pool.getReserveData(assetToIncrease);
    const availableLiquidity = await borrowingToken.balanceOf(aTokenAddress);
    await pool
        .connect(borrower.signer)
        .borrow(assetToIncrease, availableLiquidity.percentMul('20'), types_1.RateMode.Variable, 0, borrower.address);
    await (0, deploy_v3_1.advanceTimeAndBlock)(10000000000);
};
const updateBalances = (balances, aToken, receipt) => {
    var _a, _b, _c, _d, _e;
    let events = (0, tokenization_events_1.getATokenEvent)(aToken, receipt, 'Transfer');
    for (const ev of events) {
        if (ev.from == deploy_v3_1.ZERO_ADDRESS || ev.to == deploy_v3_1.ZERO_ADDRESS)
            continue;
        balances.balance[ev.from] = (_a = balances.balance[ev.from]) === null || _a === void 0 ? void 0 : _a.sub(ev.value);
        balances.balance[ev.to] = (_b = balances.balance[ev.to]) === null || _b === void 0 ? void 0 : _b.add(ev.value);
    }
    events = (0, tokenization_events_1.getATokenEvent)(aToken, receipt, 'Mint');
    for (const ev of events) {
        balances.balance[ev.onBehalfOf] = (_c = balances.balance[ev.onBehalfOf]) === null || _c === void 0 ? void 0 : _c.add(ev.value);
    }
    events = (0, tokenization_events_1.getATokenEvent)(aToken, receipt, 'Burn');
    for (const ev of events) {
        balances.balance[ev.from] = (_d = balances.balance[ev.from]) === null || _d === void 0 ? void 0 : _d.sub(ev.value.add(ev.balanceIncrease));
        balances.balance[ev.from] = (_e = balances.balance[ev.from]) === null || _e === void 0 ? void 0 : _e.add(ev.balanceIncrease);
    }
};
(0, make_suite_1.makeSuite)('AToken: Events', (testEnv) => {
    let alice, bob, eve, borrower, borrower2;
    let snapId;
    before(async () => {
        const { users, pool, dai, weth, faucetMintable } = testEnv;
        [alice, bob, eve, borrower, borrower2] = users;
        const amountToMint = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000000');
        const usersToInit = [alice, bob, eve, borrower, borrower2];
        for (const user of usersToInit) {
            await faucetMintable.mint(dai.address, user.address, amountToMint);
            await faucetMintable.mint(weth.address, user.address, amountToMint);
            await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
            await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        }
    });
    beforeEach(async () => {
        snapId = await (0, deploy_v3_1.evmSnapshot)();
        // Init balances
        balances = {
            balance: {
                [alice.address]: ethers_1.BigNumber.from(0),
                [bob.address]: ethers_1.BigNumber.from(0),
                [eve.address]: ethers_1.BigNumber.from(0),
            },
        };
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Alice and Bob supplies 1000, Alice transfer 500 to Bob, and withdraws 500 (without index change)', async () => {
        await testMultipleSupplyAndTransferAndWithdraw(false);
    });
    it('Alice and Bob supplies 1000, Alice transfer 500 to Bob, and withdraws 500 (with index change)', async () => {
        await testMultipleSupplyAndTransferAndWithdraw(true);
    });
    const testMultipleSupplyAndTransferAndWithdraw = async (indexChange) => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let balanceTransferEv;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Alice supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Bob supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1000', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice transfers 500 aDAI to Bob');
        const [fromScaledBefore, toScaledBefore] = await Promise.all([
            aDai.scaledBalanceOf(alice.address),
            aDai.scaledBalanceOf(bob.address),
        ]);
        rcpt = await (0, tokenization_events_1.transfer)(pool, alice, dai.address, '500', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        balanceTransferEv = (0, tokenization_events_1.getATokenEvent)(aDai, rcpt, 'BalanceTransfer')[0];
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore.sub(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        (0, chai_1.expect)(await aDai.scaledBalanceOf(bob.address)).to.be.eq(toScaledBefore.add(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 500 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '500', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    };
    it('Alice supplies 1000, supplies 200, transfers 100 out, withdraws 50 withdraws 100 to Bob, withdraws 200 (without index change)', async () => {
        await testMultipleSupplyAndWithdrawalsOnBehalf(false);
    });
    it('Alice supplies 1000, supplies 200, transfers 100 out, withdraws 50 withdraws 100 to Bob, withdraws 200 (with index change)', async () => {
        await testMultipleSupplyAndWithdrawalsOnBehalf(true);
    });
    const testMultipleSupplyAndWithdrawalsOnBehalf = async (indexChange) => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let balanceTransferEv;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Alice supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice supplies 200 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '200', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice transfers 100 aDAI to Bob');
        const [fromScaledBefore, toScaledBefore] = await Promise.all([
            aDai.scaledBalanceOf(alice.address),
            aDai.scaledBalanceOf(bob.address),
        ]);
        rcpt = await (0, tokenization_events_1.transfer)(pool, alice, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        balanceTransferEv = (0, tokenization_events_1.getATokenEvent)(aDai, rcpt, 'BalanceTransfer')[0];
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore.sub(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        (0, chai_1.expect)(await aDai.scaledBalanceOf(bob.address)).to.be.eq(toScaledBefore.add(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 50 DAI');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '50', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 100 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 300 DAI');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '300', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    };
    it('Alice supplies 1000, supplies 200 to Bob, Bob supplies 100, Alice transfers 100 out, Alice withdraws 100, Alice withdraws 200 to Bob (without index change)', async () => {
        await testMultipleSupplyOnBehalfOfAndWithdrawals(false);
    });
    it('Alice supplies 1000, supplies 200 to Bob, Bob supplies 100, Alice transfers 100 out, Alice withdraws 100, Alice withdraws 200 to Bob (with index change)', async () => {
        await testMultipleSupplyOnBehalfOfAndWithdrawals(true);
    });
    const testMultipleSupplyOnBehalfOfAndWithdrawals = async (indexChange) => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let balanceTransferEv;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Alice supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice supplies 200 DAI to Bob');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '200', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Bob supplies 100 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice transfers 100 aDAI to Bob');
        const [fromScaledBefore, toScaledBefore] = await Promise.all([
            aDai.scaledBalanceOf(alice.address),
            aDai.scaledBalanceOf(bob.address),
        ]);
        rcpt = await (0, tokenization_events_1.transfer)(pool, alice, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        balanceTransferEv = (0, tokenization_events_1.getATokenEvent)(aDai, rcpt, 'BalanceTransfer')[0];
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore.sub(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        (0, chai_1.expect)(await aDai.scaledBalanceOf(bob.address)).to.be.eq(toScaledBefore.add(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 200 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '200', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    };
    it('Alice supplies 1000, transfers 100 to Bob, transfers 500 to itself, Bob transfers 500 from Alice to itself, withdraws 400 to Bob (without index change)', async () => {
        await testMultipleTransfersAndWithdrawals(false);
    });
    it('Alice supplies 1000, transfers 100 to Bob, transfers 500 to itself, Bob transfers 500 from Alice to itself, withdraws 400 to Bob  (with index change)', async () => {
        await testMultipleTransfersAndWithdrawals(true);
    });
    const testMultipleTransfersAndWithdrawals = async (indexChange) => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let balanceTransferEv;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Alice supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice transfers 100 DAI to Bob');
        let [fromScaledBefore, toScaledBefore] = await Promise.all([
            aDai.scaledBalanceOf(alice.address),
            aDai.scaledBalanceOf(bob.address),
        ]);
        rcpt = await (0, tokenization_events_1.transfer)(pool, alice, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        balanceTransferEv = (0, tokenization_events_1.getATokenEvent)(aDai, rcpt, 'BalanceTransfer')[0];
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore.sub(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        (0, chai_1.expect)(await aDai.scaledBalanceOf(bob.address)).to.be.eq(toScaledBefore.add(balanceTransferEv.value), 'Scaled balance emitted in BalanceTransfer event does not match');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice transfers 500 DAI to itself');
        fromScaledBefore = await aDai.scaledBalanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.transfer)(pool, alice, dai.address, '500', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore, 'Scaled balance should remain the same');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Bob transfersFrom Alice 500 DAI to Alice');
        fromScaledBefore = await aDai.scaledBalanceOf(alice.address);
        (0, chai_1.expect)(await aDai
            .connect(alice.signer)
            .approve(bob.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '500')));
        rcpt = await (0, tokenization_events_1.transferFrom)(pool, bob, alice.address, dai.address, '500', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        (0, chai_1.expect)(await aDai.scaledBalanceOf(alice.address)).to.be.eq(fromScaledBefore, 'Scaled balance should remain the same');
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        }
        log('- Alice withdraws 400 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '200', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    };
    it('Alice supplies 300000, withdraws 200000 to Bob, withdraws 5 to Bob', async () => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Alice supplies 300000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '300000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Increase index due to great borrow of DAI');
        await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        log('- Alice withdraws 200000 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '200000', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Increase index due to great borrow of DAI');
        await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        log('- Alice withdraws 5 DAI to Bob');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, alice, dai.address, '5', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    });
    it('Bob supplies 1000, Alice supplies 200 on behalf of Bob, Bob withdraws 200 on behalf of Alice', async () => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        log('- Bob supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1000', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Increase index due to great borrow of DAI');
        await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        log('- Alice supplies 200 DAI to Bob');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '200', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Increase index due to great borrow of DAI');
        await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        log('- Bob withdraws 200 DAI to Alice');
        rcpt = await (0, tokenization_events_1.withdraw)(pool, bob, dai.address, '200', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
    });
    it('Alice supplies 1000 DAI and approves aDai to Bob, Bob transfers 500 to himself and 300 to Eve, index change, principal goes back to Alice', async () => {
        const { pool, dai, aDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await aDai.balanceOf(alice.address);
        let bobBalanceBefore = await aDai.balanceOf(bob.address);
        let eveBalanceBefore = await aDai.balanceOf(eve.address);
        log('- Alice supplies 1000 DAI');
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1000', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Alice approves aDai to Bob');
        await aDai.connect(alice.signer).approve(bob.address, constants_1.MAX_UINT_AMOUNT);
        log('- Bob transfers 500 aDai from Alice to himself');
        rcpt = await (0, tokenization_events_1.transferFrom)(pool, bob, alice.address, dai.address, '500', bob.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Bob transfers 300 aDai from Alice to Eve');
        rcpt = await (0, tokenization_events_1.transferFrom)(pool, bob, alice.address, dai.address, '300', eve.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Increase index due to great borrow of DAI');
        await increaseSupplyIndex(pool, faucetMintable, borrower, weth.address, dai.address);
        log('- Bob transfers 500 back to Alice');
        rcpt = await (0, tokenization_events_1.transfer)(pool, bob, dai.address, '500', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        log('- Eve transfers 500 back to Alice');
        rcpt = await (0, tokenization_events_1.transfer)(pool, eve, dai.address, '300', alice.address, DEBUG);
        updateBalances(balances, aDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', aDai, alice.address);
            await printBalance('bob', aDai, bob.address);
            await printBalance('eve', aDai, eve.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.supply)(pool, alice, dai.address, '1', alice.address, false);
        updateBalances(balances, aDai, rcpt);
        const aliceBalanceAfter = await aDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, bob, dai.address, '1', bob.address, false);
        updateBalances(balances, aDai, rcpt);
        const bobBalanceAfter = await aDai.balanceOf(bob.address);
        rcpt = await (0, tokenization_events_1.supply)(pool, eve, dai.address, '1', eve.address, false);
        updateBalances(balances, aDai, rcpt);
        const eveBalanceAfter = await aDai.balanceOf(eve.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 2);
        (0, chai_1.expect)(eveBalanceAfter).to.be.closeTo(eveBalanceBefore.add(balances.balance[eve.address]), 2);
    });
});
