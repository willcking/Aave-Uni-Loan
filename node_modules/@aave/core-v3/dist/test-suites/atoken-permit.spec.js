"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const make_suite_1 = require("./helpers/make-suite");
const wallets_1 = require("./helpers/utils/wallets");
const types_1 = require("../helpers/types");
(0, make_suite_1.makeSuite)('AToken: Permit', (testEnv) => {
    let testWallets;
    const EIP712_REVISION = '1';
    before(async () => {
        const { dai, pool, deployer, faucetMintable } = testEnv;
        testWallets = (0, wallets_1.getTestWallets)();
        // Mint DAI and deposit to Pool to for aDAI
        await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '20000'));
        await (0, deploy_v3_1.waitForTx)(await dai.approve(pool.address, ethers_1.utils.parseEther('20000')));
        await (0, deploy_v3_1.waitForTx)(await pool.deposit(dai.address, ethers_1.utils.parseEther('20000'), deployer.address, 0));
    });
    it('Checks the domain separator', async () => {
        const { aDai } = testEnv;
        const separator = await aDai.DOMAIN_SEPARATOR();
        const domain = {
            name: await aDai.name(),
            version: EIP712_REVISION,
            chainId: hre.network.config.chainId,
            verifyingContract: aDai.address,
        };
        const domainSeparator = ethers_1.utils._TypedDataEncoder.hashDomain(domain);
        (0, chai_1.expect)(separator).to.be.equal(domainSeparator, 'Invalid domain separator');
    });
    it('Tries to submit a permit with 0 expiration (revert expected)', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const tokenName = await aDai.name();
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = 0;
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = ethers_1.utils.parseEther('2').toString();
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, tokenName, owner.address, spender.address, nonce, permitAmount, expiration.toFixed());
        const ownerPrivateKey = testWallets[0].secretKey;
        (0, chai_1.expect)((await aDai.allowance(owner.address, spender.address)).toString()).to.be.equal('0', 'INVALID_ALLOWANCE_BEFORE_PERMIT');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        await (0, chai_1.expect)(aDai
            .connect(spender.signer)
            .permit(owner.address, spender.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_EXPIRATION);
        (0, chai_1.expect)((await aDai.allowance(owner.address, spender.address)).toString()).to.be.equal('0', 'INVALID_ALLOWANCE_AFTER_PERMIT');
    });
    it('Submits a permit with maximum expiration length', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const deadline = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = ethers_1.utils.parseEther('2').toString();
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, deadline, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        (0, chai_1.expect)((await aDai.allowance(owner.address, spender.address)).toString()).to.be.equal('0', 'INVALID_ALLOWANCE_BEFORE_PERMIT');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        (0, chai_1.expect)(await aDai
            .connect(spender.signer)
            .permit(owner.address, spender.address, permitAmount, deadline, v, r, s));
        (0, chai_1.expect)((await aDai.nonces(owner.address)).toNumber()).to.be.equal(1);
    });
    it('Cancels the previous permit', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const deadline = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = '0';
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, deadline, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        (0, chai_1.expect)((await aDai.allowance(owner.address, spender.address)).toString()).to.be.equal(ethers_1.ethers.utils.parseEther('2'), 'INVALID_ALLOWANCE_BEFORE_PERMIT');
        (0, chai_1.expect)(await aDai
            .connect(spender.signer)
            .permit(owner.address, spender.address, permitAmount, deadline, v, r, s));
        (0, chai_1.expect)((await aDai.allowance(owner.address, spender.address)).toString()).to.be.equal(permitAmount, 'INVALID_ALLOWANCE_AFTER_PERMIT');
        (0, chai_1.expect)((await aDai.nonces(owner.address)).toNumber()).to.be.equal(2);
    });
    it('Tries to submit a permit with invalid nonce (revert expected)', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const deadline = constants_1.MAX_UINT_AMOUNT;
        const nonce = 1000;
        const permitAmount = '0';
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, deadline, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        await (0, chai_1.expect)(aDai
            .connect(spender.signer)
            .permit(owner.address, spender.address, permitAmount, deadline, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_SIGNATURE);
    });
    it('Tries to submit a permit with invalid expiration (previous to the current block) (revert expected)', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = '1';
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = '0';
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, expiration, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        await (0, chai_1.expect)(aDai
            .connect(spender.signer)
            .permit(owner.address, spender.address, expiration, permitAmount, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_EXPIRATION);
    });
    it('Tries to submit a permit with invalid signature (revert expected)', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const deadline = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = '0';
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, deadline, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        await (0, chai_1.expect)(aDai
            .connect(spender.signer)
            .permit(owner.address, constants_1.ZERO_ADDRESS, permitAmount, deadline, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_SIGNATURE);
    });
    it('Tries to submit a permit with invalid owner (revert expected)', async () => {
        const { aDai, deployer, users } = testEnv;
        const owner = deployer;
        const spender = users[1];
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await aDai.nonces(owner.address)).toNumber();
        const permitAmount = '0';
        const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, aDai.address, EIP712_REVISION, await aDai.name(), owner.address, spender.address, nonce, expiration, permitAmount);
        const ownerPrivateKey = testWallets[0].secretKey;
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(ownerPrivateKey, msgParams);
        await (0, chai_1.expect)(aDai
            .connect(spender.signer)
            .permit(constants_1.ZERO_ADDRESS, spender.address, expiration, permitAmount, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.ZERO_ADDRESS_NOT_VALID);
    });
});
