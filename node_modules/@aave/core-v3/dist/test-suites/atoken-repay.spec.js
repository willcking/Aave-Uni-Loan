"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MockATokenRepayment__factory_1 = require("./../types/factories/mocks/tokens/MockATokenRepayment__factory");
const deploy_v3_1 = require("@aave/deploy-v3");
const units_1 = require("@ethersproject/units");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const misc_utils_1 = require("../helpers/misc-utils");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
(0, make_suite_1.makeSuite)('AToken: Repay', (testEnv) => {
    let snapShot;
    let aTokenRepayImpl;
    before('User 0 deposits 100 DAI, user 1 deposits 1 WETH, borrows 50 DAI', async () => {
        const { weth, pool, dai, aDai, users: [user0, user1], deployer, configurator, faucetMintable } = testEnv;
        const daiAmount = ethers_1.utils.parseEther('100');
        const wethAmount = ethers_1.utils.parseEther('1');
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, user0.address, daiAmount));
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, user1.address, wethAmount));
        await (0, deploy_v3_1.waitForTx)(await dai.connect(user0.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, deploy_v3_1.waitForTx)(await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        aTokenRepayImpl = await new MockATokenRepayment__factory_1.MockATokenRepayment__factory(deployer.signer).deploy(pool.address);
        await configurator.updateAToken({
            asset: dai.address,
            treasury: await aDai.RESERVE_TREASURY_ADDRESS(),
            incentivesController: await aDai.getIncentivesController(),
            name: await aDai.name(),
            symbol: await aDai.symbol(),
            implementation: aTokenRepayImpl.address,
            params: '0x',
        });
        (0, chai_1.expect)(await pool.connect(user0.signer).deposit(dai.address, daiAmount, user0.address, 0));
        (0, chai_1.expect)(await pool.connect(user1.signer).deposit(weth.address, wethAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user1.signer).borrow(dai.address, daiAmount.div(2), 2, 0, user1.address));
    });
    beforeEach(async () => {
        snapShot = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snapShot);
    });
    it('User 1 tries to repay using aTokens without actually holding aDAI', async () => {
        const { pool, dai, users: [, user1], } = testEnv;
        const repayAmount = ethers_1.utils.parseEther('25');
        await (0, chai_1.expect)(pool.connect(user1.signer).repayWithATokens(dai.address, repayAmount, 2)).to.be
            .reverted;
    });
    it('User 1 receives 25 aDAI from user 0, repays half of the debt', async () => {
        const { pool, dai, aDai, variableDebtDai, users: [user0, user1], } = testEnv;
        const repayAmount = ethers_1.utils.parseEther('25');
        await (0, chai_1.expect)(await aDai.connect(user0.signer).transfer(user1.address, repayAmount));
        const time = await (0, misc_utils_1.timeLatest)();
        await (0, misc_utils_1.setBlocktime)(time.add(1).toNumber());
        const balanceBefore = await aDai.balanceOf(user1.address, { blockTag: 'pending' });
        const debtBefore = await variableDebtDai.balanceOf(user1.address, { blockTag: 'pending' });
        await (0, chai_1.expect)(pool.connect(user1.signer).repayWithATokens(dai.address, repayAmount, 2))
            .to.emit(pool, 'Repay')
            .withArgs(dai.address, user1.address, user1.address, repayAmount, true)
            .and.not.to.emit(aTokenRepayImpl.attach(aDai.address), 'MockRepayment');
        const balanceAfter = await aDai.balanceOf(user1.address);
        const debtAfter = await variableDebtDai.balanceOf(user1.address);
        (0, chai_1.expect)(balanceAfter).to.be.closeTo(balanceBefore.sub(repayAmount), 2);
        (0, chai_1.expect)(debtAfter).to.be.closeTo(debtBefore.sub(repayAmount), 2);
    });
    it('User 1 receives 25 aDAI from user 0, use all aDai to repay debt', async () => {
        const { pool, dai, aDai, variableDebtDai, users: [user0, user1], } = testEnv;
        const transferAmount = ethers_1.utils.parseEther('25');
        (0, chai_1.expect)(await aDai.connect(user0.signer).transfer(user1.address, transferAmount));
        const time = await (0, misc_utils_1.timeLatest)();
        await (0, misc_utils_1.setBlocktime)(time.add(1).toNumber());
        const balanceBefore = await aDai.balanceOf(user1.address, { blockTag: 'pending' });
        (0, chai_1.expect)(balanceBefore).to.be.gt(transferAmount);
        const debtBefore = await variableDebtDai.balanceOf(user1.address, { blockTag: 'pending' });
        const action = await pool
            .connect(user1.signer)
            .repayWithATokens(dai.address, constants_1.MAX_UINT_AMOUNT, 2);
        const tx = await (0, deploy_v3_1.waitForTx)(action);
        const repayEventSignature = ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('Repay(address,address,address,uint256,bool)'));
        await (0, chai_1.expect)(action).to.not.emit(aTokenRepayImpl.attach(aDai.address), 'MockRepayment');
        const rawRepayEvents = tx.logs.filter((log) => log.topics[0] === repayEventSignature);
        const parsedRepayEvent = pool.interface.parseLog(rawRepayEvents[0]);
        (0, chai_1.expect)(parsedRepayEvent.args.useATokens).to.be.true;
        (0, chai_1.expect)(parsedRepayEvent.args.reserve).to.be.eq(dai.address);
        (0, chai_1.expect)(parsedRepayEvent.args.repayer).to.be.eq(user1.address);
        (0, chai_1.expect)(parsedRepayEvent.args.user).to.be.eq(user1.address);
        const repayAmount = parsedRepayEvent.args.amount;
        const balanceAfter = await aDai.balanceOf(user1.address);
        const debtAfter = await variableDebtDai.balanceOf(user1.address);
        (0, chai_1.expect)(balanceAfter).to.be.eq(0);
        (0, chai_1.expect)(debtAfter).to.be.closeTo(debtBefore.sub(repayAmount), 2);
    });
    it('User 1 receives 55 aDAI from user 0, repay all debt', async () => {
        const { pool, dai, aDai, variableDebtDai, users: [user0, user1], } = testEnv;
        const transferAmount = ethers_1.utils.parseEther('55');
        (0, chai_1.expect)(await aDai.connect(user0.signer).transfer(user1.address, transferAmount));
        const time = await (0, misc_utils_1.timeLatest)();
        await (0, misc_utils_1.setBlocktime)(time.add(1).toNumber());
        const balanceBefore = await aDai.balanceOf(user1.address, { blockTag: 'pending' });
        const debtBefore = await variableDebtDai.balanceOf(user1.address, { blockTag: 'pending' });
        (0, chai_1.expect)(debtBefore).to.be.gt((0, units_1.parseUnits)('50', 18));
        const action = await pool
            .connect(user1.signer)
            .repayWithATokens(dai.address, constants_1.MAX_UINT_AMOUNT, 2);
        const tx = await (0, deploy_v3_1.waitForTx)(action);
        await (0, chai_1.expect)(action).to.not.emit(aTokenRepayImpl.attach(aDai.address), 'MockRepayment');
        const repayEventSignature = ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('Repay(address,address,address,uint256,bool)'));
        const rawRepayEvents = tx.logs.filter((log) => log.topics[0] === repayEventSignature);
        const parsedRepayEvent = pool.interface.parseLog(rawRepayEvents[0]);
        (0, chai_1.expect)(parsedRepayEvent.args.useATokens).to.be.true;
        (0, chai_1.expect)(parsedRepayEvent.args.reserve).to.be.eq(dai.address);
        (0, chai_1.expect)(parsedRepayEvent.args.repayer).to.be.eq(user1.address);
        (0, chai_1.expect)(parsedRepayEvent.args.user).to.be.eq(user1.address);
        const repayAmount = parsedRepayEvent.args.amount;
        const balanceAfter = await aDai.balanceOf(user1.address);
        const debtAfter = await variableDebtDai.balanceOf(user1.address);
        (0, chai_1.expect)(debtAfter).to.be.eq(0);
        (0, chai_1.expect)(balanceAfter).to.be.eq(balanceBefore.sub(repayAmount));
    });
    it('Check interest rates after repaying with aTokens', async () => {
        const { weth, dai, aDai, pool, helpersContract, users: [user], faucetMintable } = testEnv;
        const depositAmount = (0, units_1.parseUnits)('1000', 18);
        await faucetMintable.mint(dai.address, user.address, depositAmount);
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).supply(dai.address, depositAmount, user.address, 0);
        const collateralAmount = (0, units_1.parseUnits)('100', 18);
        await faucetMintable.mint(weth.address, user.address, collateralAmount);
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).supply(weth.address, collateralAmount, user.address, 0);
        const borrowAmount = (0, units_1.parseUnits)('500', 18);
        await pool
            .connect(user.signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Variable, 0, user.address);
        // Now we repay 250 with aTokens
        const repayAmount = (0, units_1.parseUnits)('250', 18);
        const action = await pool
            .connect(user.signer)
            .repayWithATokens(dai.address, repayAmount, types_1.RateMode.Variable);
        await (0, chai_1.expect)(action).to.not.emit(aTokenRepayImpl.attach(aDai.address), 'MockRepayment');
        const reserveData = await pool.getReserveData(dai.address);
        const strategy = deploy_v3_1.DefaultReserveInterestRateStrategy__factory.connect(reserveData.interestRateStrategyAddress, user.signer);
        const stableDebtToken = deploy_v3_1.IStableDebtToken__factory.connect(reserveData.stableDebtTokenAddress, user.signer);
        const stableDebtData = await stableDebtToken.getSupplyData();
        const variableDebtToken = deploy_v3_1.IVariableDebtToken__factory.connect(reserveData.variableDebtTokenAddress, user.signer);
        const scaledTotalSupply = await variableDebtToken.scaledTotalSupply();
        const variableDebt = scaledTotalSupply.rayMul(await pool.getReserveNormalizedVariableDebt(dai.address));
        const expectedRates = await strategy.calculateInterestRates({
            unbacked: 0,
            liquidityAdded: 0,
            liquidityTaken: 0,
            totalStableDebt: stableDebtData[1],
            totalVariableDebt: variableDebt,
            aToken: aDai.address,
            reserve: dai.address,
            reserveFactor: (await helpersContract.getReserveConfigurationData(dai.address)).reserveFactor,
            averageStableBorrowRate: stableDebtData[2],
        });
        (0, chai_1.expect)(reserveData.currentLiquidityRate).to.be.eq(expectedRates[0]);
        (0, chai_1.expect)(reserveData.currentStableBorrowRate).to.be.eq(expectedRates[1]);
        (0, chai_1.expect)(reserveData.currentVariableBorrowRate).to.be.eq(expectedRates[2]);
    });
});
