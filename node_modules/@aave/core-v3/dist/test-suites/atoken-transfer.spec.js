"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
(0, make_suite_1.makeSuite)('AToken: Transfer', (testEnv) => {
    const { INVALID_FROM_BALANCE_AFTER_TRANSFER, INVALID_TO_BALANCE_AFTER_TRANSFER, HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD, } = types_1.ProtocolErrors;
    const DAI_AMOUNT_TO_DEPOSIT = '1000';
    it('User 0 deposits 1000 DAI, transfers 1000 to user 0', async () => {
        const { users, pool, dai, aDai, faucetMintable } = testEnv;
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        // User 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT);
        // Top up user
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        (0, chai_1.expect)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await aDai.getPreviousIndex(users[0].address)).to.be.eq(0);
        (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        (0, chai_1.expect)(await aDai.getPreviousIndex(users[0].address)).to.be.gt(0);
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[0].address, amountDAItoDeposit))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[0].address, amountDAItoDeposit);
        const name = await aDai.name();
        (0, chai_1.expect)(name).to.be.equal('Aave Testnet DAI');
        const fromBalance = await aDai.balanceOf(users[0].address);
        const toBalance = await aDai.balanceOf(users[0].address);
        (0, chai_1.expect)(fromBalance.toString()).to.be.eq(toBalance.toString());
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 0 deposits 1000 DAI, disable as collateral, transfers 1000 to user 1', async () => {
        const { users, pool, dai, aDai, faucetMintable } = testEnv;
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        // User 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT);
        // Top up user
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        (0, chai_1.expect)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        (0, chai_1.expect)(await pool.connect(users[0].signer).setUserUseReserveAsCollateral(dai.address, false));
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[1].address, amountDAItoDeposit);
        const name = await aDai.name();
        (0, chai_1.expect)(name).to.be.equal('Aave Testnet DAI');
        const fromBalance = await aDai.balanceOf(users[0].address);
        const toBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(fromBalance.toString()).to.be.equal('0', INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(toBalance.toString()).to.be.equal(amountDAItoDeposit.toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 0 deposits 1000 DAI, transfers 5 to user 1 twice, then transfer 0 to user 1', async () => {
        const { users, pool, dai, aDai, faucetMintable } = testEnv;
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT)));
        (0, chai_1.expect)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        // User 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT);
        const amountDAItoTransfer = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '5');
        (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoTransfer))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[1].address, amountDAItoTransfer);
        (0, chai_1.expect)(await aDai.balanceOf(users[0].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '995')).toString(), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(await aDai.balanceOf(users[1].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '5')).toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoTransfer))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[1].address, amountDAItoTransfer);
        (0, chai_1.expect)(await aDai.balanceOf(users[0].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '990')).toString(), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(await aDai.balanceOf(users[1].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10')).toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, 0))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[1].address, 0);
        (0, chai_1.expect)(await aDai.balanceOf(users[0].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '990')).toString(), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(await aDai.balanceOf(users[1].address)).to.be.eq((await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10')).toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 0 deposits 1000 DAI, transfers to user 1', async () => {
        const { users, pool, dai, aDai, faucetMintable } = testEnv;
        // User 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT);
        // Top up user
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        (0, chai_1.expect)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[0].address, users[1].address, amountDAItoDeposit);
        const name = await aDai.name();
        (0, chai_1.expect)(name).to.be.equal('Aave Testnet DAI');
        const fromBalance = await aDai.balanceOf(users[0].address);
        const toBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(fromBalance.toString()).to.be.equal('0', INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(toBalance.toString()).to.be.equal(amountDAItoDeposit.toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
    });
    it('User 0 deposits 1 WETH and user 1 tries to borrow the WETH with the received DAI as collateral', async () => {
        const { users, pool, weth, helpersContract, faucetMintable } = testEnv;
        const userAddress = await pool.signer.getAddress();
        const amountWETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '1');
        const amountWETHtoBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.1');
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, users[0].address, amountWETHtoDeposit));
        (0, chai_1.expect)(await weth.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(weth.address, amountWETHtoDeposit, userAddress, '0'));
        (0, chai_1.expect)(await pool
            .connect(users[1].signer)
            .borrow(weth.address, amountWETHtoBorrow, types_1.RateMode.Stable, '0', users[1].address));
        const userReserveData = await helpersContract.getUserReserveData(weth.address, users[1].address);
        (0, chai_1.expect)(userReserveData.currentStableDebt.toString()).to.be.eq(amountWETHtoBorrow);
    });
    it('User 1 tries to transfer all the DAI used as collateral back to user 0 (revert expected)', async () => {
        const { users, aDai, dai } = testEnv;
        const amountDAItoTransfer = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, DAI_AMOUNT_TO_DEPOSIT);
        await (0, chai_1.expect)(aDai.connect(users[1].signer).transfer(users[0].address, amountDAItoTransfer), HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD).to.be.revertedWith(HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD);
    });
    it('User 1 transfers a small amount of DAI used as collateral back to user 0', async () => {
        const { users, aDai, dai } = testEnv;
        const aDAItoTransfer = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100');
        await (0, chai_1.expect)(aDai.connect(users[1].signer).transfer(users[0].address, aDAItoTransfer))
            .to.emit(aDai, 'Transfer')
            .withArgs(users[1].address, users[0].address, aDAItoTransfer);
        const user0Balance = await aDai.balanceOf(users[0].address);
        (0, chai_1.expect)(user0Balance.toString()).to.be.eq(aDAItoTransfer.toString());
    });
});
