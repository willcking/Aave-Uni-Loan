"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require('chai');
const ethers_1 = require("ethers");
const test_1 = __importDefault(require("@aave/deploy-v3/dist/markets/test"));
const deploy_v3_1 = require("@aave/deploy-v3");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
const helpers_1 = require("./helpers/utils/helpers");
const actions_1 = require("./helpers/actions");
const calculations_1 = require("./helpers/utils/calculations");
require("./helpers/utils/wadraymath");
const expectEqual = (actual, expected) => {
    expect(actual).to.be.almostEqualOrEqual(expected);
};
(0, make_suite_1.makeSuite)('BridgeLogic: Testing with borrows', (testEnv) => {
    const { INVALID_AMOUNT, CALLER_NOT_BRIDGE, UNBACKED_MINT_CAP_EXCEEDED } = types_1.ProtocolErrors;
    const depositAmount = ethers_1.utils.parseEther('1000');
    const borrowAmount = ethers_1.utils.parseEther('200');
    const withdrawAmount = ethers_1.utils.parseEther('100');
    const feeBps = ethers_1.BigNumber.from(30);
    const denominatorBP = ethers_1.BigNumber.from(10000);
    const bridgeProtocolFeeBps = ethers_1.BigNumber.from(2000);
    const mintAmount = withdrawAmount.mul(denominatorBP.sub(feeBps)).div(denominatorBP);
    const feeAmount = withdrawAmount.mul(feeBps).div(denominatorBP);
    let aclManager;
    before(async () => {
        calculations_1.configuration.reservesParams = test_1.default.ReservesConfig;
        const { users, poolAdmin, configurator } = testEnv;
        aclManager = await (0, contract_getters_1.getACLManager)();
        await (0, deploy_v3_1.waitForTx)(await aclManager.addBridge(users[2].address));
        await (0, deploy_v3_1.waitForTx)(await aclManager.addBridge(users[3].address));
        await (0, deploy_v3_1.waitForTx)(await configurator.connect(poolAdmin.signer).updateBridgeProtocolFee(bridgeProtocolFeeBps));
    });
    it('User 0 deposit 1000 dai.', async () => {
        const { users, pool, dai, faucetMintable } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, users[0].address, depositAmount));
        await (0, deploy_v3_1.waitForTx)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, deploy_v3_1.waitForTx)(await pool.connect(users[0].signer).deposit(dai.address, depositAmount, users[0].address, 0));
    });
    it('User 1 deposit 2 eth', async () => {
        const { users, pool, weth } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await weth.connect(users[1].signer).deposit({ value: ethers_1.utils.parseEther('2') }));
        await (0, deploy_v3_1.waitForTx)(await weth.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(users[1].signer)
            .deposit(weth.address, ethers_1.utils.parseEther('2'), users[1].address, 0));
    });
    it('User 1 borrows 200 dai with variable debt', async () => {
        const { users, pool, dai } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(users[1].signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Variable, 0, users[1].address));
    });
    it('User 1 borrows 200 dai with stable debt', async () => {
        const { users, pool, dai } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(users[1].signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Stable, 0, users[1].address));
    });
    it('User 1 tries to perform fast withdraw 100 aDai from L2 (revert expected)', async () => {
        const { users, pool, dai } = testEnv;
        await expect(pool.connect(users[1].signer).mintUnbacked(dai.address, mintAmount, users[0].address, 0)).to.be.revertedWith(CALLER_NOT_BRIDGE);
    });
    it('User 2 tries to perform fast withdraw from L2 with no unbackedMintCap (revert expected)', async () => {
        const { users, pool, dai } = testEnv;
        // fast withdraw a100 DAI
        await expect(pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[0].address, 0)).to.be.revertedWith(UNBACKED_MINT_CAP_EXCEEDED);
        // fast withdraw 0 aDAI
        await expect(pool.connect(users[2].signer).mintUnbacked(dai.address, 0, users[0].address, 0)).to.be.revertedWith(INVALID_AMOUNT);
    });
    it('RiskAdmin updates the unbackedMintCap to 10 aDai (10 left) and user 1 tries to perform fast withdraw 100 aDai from L2 (revert expected)', async () => {
        const { users, riskAdmin, pool, configurator, dai } = testEnv;
        expect(await configurator.connect(riskAdmin.signer).setUnbackedMintCap(dai.address, '10'));
        await expect(pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[0].address, 0)).to.be.revertedWith(UNBACKED_MINT_CAP_EXCEEDED);
        expect(await configurator
            .connect(riskAdmin.signer)
            .setUnbackedMintCap(dai.address, constants_1.MAX_UNBACKED_MINT_CAP));
    });
    it('User 2 perform fast withdraw 100 aDai from L2', async () => {
        const { users, pool, dai, helpersContract } = testEnv;
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[2].address, 0));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const expectedDataAfter = (0, calculations_1.calcExpectedReserveDataAfterMintUnbacked)(mintAmount.toString(), reserveDataBefore, txTimestamp);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        expectEqual(reserveDataAfter, expectedDataAfter);
    });
    it('RiskAdmin updates the unbackedMintCap to 100 aDai (0 left) and user 1 tries to perform fast withdraw 1 aDai from L2 (revert expected)', async () => {
        const { users, riskAdmin, pool, configurator, dai } = testEnv;
        expect(await configurator.connect(riskAdmin.signer).setUnbackedMintCap(dai.address, '100'));
        await expect(pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[0].address, 0)).to.be.revertedWith(UNBACKED_MINT_CAP_EXCEEDED);
        expect(await configurator
            .connect(riskAdmin.signer)
            .setUnbackedMintCap(dai.address, constants_1.MAX_UNBACKED_MINT_CAP));
    });
    it('User 2 perform another fast withdraw 100 aDai from L2', async () => {
        const { users, pool, dai, helpersContract } = testEnv;
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[2].address, 0));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedDataAfter = (0, calculations_1.calcExpectedReserveDataAfterMintUnbacked)(mintAmount.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedDataAfter);
    });
    it('Wait 1 days', async () => {
        await (0, deploy_v3_1.advanceTimeAndBlock)(60 * 60 * 24);
    });
    it('User 2 perform invalid fast withdraw 100 aDai from L2', async () => {
        const { users, pool, dai, helpersContract } = testEnv;
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[2].address, 0));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedDataAfter = (0, calculations_1.calcExpectedReserveDataAfterMintUnbacked)(mintAmount.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedDataAfter);
    });
    it('Wait 6 days', async () => {
        await (0, deploy_v3_1.advanceTimeAndBlock)(60 * 60 * 24 * 6);
    });
    it('100 bridged dai used to back unbacked', async () => {
        var _a;
        // Let user 3 be bridge for now
        const { users, pool, dai, aDai, helpersContract, faucetMintable } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await faucetMintable.mint(dai.address, users[3].address, withdrawAmount));
        await (0, deploy_v3_1.waitForTx)(await dai.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[3].signer).backUnbacked(dai.address, mintAmount, feeAmount));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedReserveDataAfter = (0, calculations_1.calcExpectedReserveDataAfterBackUnbacked)(await aDai.scaledTotalSupply(), mintAmount.toString(), feeAmount.toString(), bridgeProtocolFeeBps.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveDataAfter);
        // Check event values for `ReserveDataUpdated`
        const reserveDataUpdatedEvent = (_a = tx.events) === null || _a === void 0 ? void 0 : _a.find(({ event }) => event === 'ReserveDataUpdated');
        if (reserveDataUpdatedEvent) {
            const { reserve: eventReserve, liquidityRate: eventLiquidityRate, stableBorrowRate: eventStableBorrowRate, variableBorrowRate: eventVariableBorrowRate, liquidityIndex: eventLiquidityIndex, variableBorrowIndex: eventVariableBorrowIndex, } = reserveDataUpdatedEvent.args;
            expect(expectedReserveDataAfter.address).to.be.eq(eventReserve);
            expect(expectedReserveDataAfter.liquidityRate).to.be.eq(eventLiquidityRate);
            expect(expectedReserveDataAfter.stableBorrowRate).to.be.eq(eventStableBorrowRate);
            expect(expectedReserveDataAfter.variableBorrowRate).to.be.eq(eventVariableBorrowRate);
            expect(expectedReserveDataAfter.liquidityIndex).to.be.eq(eventLiquidityIndex);
            expect(expectedReserveDataAfter.variableBorrowIndex).to.be.eq(eventVariableBorrowIndex);
        }
    });
    it('user 1 performs unauthorized backing', async () => {
        const { users, pool, dai, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, users[1].address, withdrawAmount);
        await dai.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await expect(pool.connect(users[1].signer).backUnbacked(dai.address, mintAmount, feeAmount)).to.be.revertedWith(CALLER_NOT_BRIDGE);
    });
    it('100 bridged dai used to back unbacked', async () => {
        // Let user 3 be bridge for now
        const { users, pool, dai, aDai, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, users[3].address, withdrawAmount);
        await dai.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[3].signer).backUnbacked(dai.address, mintAmount, feeAmount));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedReserveDataAfter = (0, calculations_1.calcExpectedReserveDataAfterBackUnbacked)(await aDai.scaledTotalSupply(), mintAmount.toString(), feeAmount.toString(), bridgeProtocolFeeBps.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveDataAfter);
    });
    it('User donates 100 dai to aDai holders', async () => {
        // Let user 3 be bridge for now
        const { users, pool, dai, aDai, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, users[3].address, withdrawAmount);
        await dai.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[3].signer).backUnbacked(dai.address, '0', withdrawAmount));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedReserveDataAfter = (0, calculations_1.calcExpectedReserveDataAfterBackUnbacked)(await aDai.scaledTotalSupply(), '0', withdrawAmount.toString(), bridgeProtocolFeeBps.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveDataAfter);
        expect(reserveDataBefore.unbacked).to.be.eq(mintAmount);
        expect(reserveDataAfter.unbacked).to.be.eq(mintAmount);
        expect(reserveDataAfter.liquidityIndex.gt(reserveDataBefore.liquidityIndex)).to.be.eq(true);
    });
    it('Safety module cover 100 unbacked dai', async () => {
        // Let user 3 be bridge for now
        const { users, pool, dai, aDai, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, users[3].address, withdrawAmount);
        await dai.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[3].signer).backUnbacked(dai.address, mintAmount, '0'));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const expectedReserveDataAfter = (0, calculations_1.calcExpectedReserveDataAfterBackUnbacked)(await aDai.scaledTotalSupply(), mintAmount.toString(), '0', bridgeProtocolFeeBps.toString(), reserveDataBefore, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveDataAfter);
        expect(reserveDataBefore.unbacked).to.be.eq(mintAmount);
        expect(reserveDataAfter.unbacked).to.be.eq('0');
    });
});
