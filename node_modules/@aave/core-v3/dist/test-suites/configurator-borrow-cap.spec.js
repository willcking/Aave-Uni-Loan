"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const deploy_v3_1 = require("@aave/deploy-v3");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
(0, make_suite_1.makeSuite)('PoolConfigurator: Borrow Cap', (testEnv) => {
    const { BORROW_CAP_EXCEEDED, INVALID_BORROW_CAP } = types_1.ProtocolErrors;
    before(async () => {
        const { weth, pool, dai, usdc, users: [user1], faucetMintable, deployer, } = testEnv;
        const mintedAmount = ethers_1.utils.parseEther('1000000000');
        // minting for main user
        await faucetMintable.mint(dai.address, deployer.address, mintedAmount);
        await faucetMintable.mint(weth.address, deployer.address, mintedAmount);
        await faucetMintable.mint(usdc.address, deployer.address, mintedAmount);
        // minting for lp user
        await faucetMintable.mint(dai.address, user1.address, mintedAmount);
        await faucetMintable.mint(weth.address, user1.address, mintedAmount);
        await faucetMintable.mint(usdc.address, user1.address, mintedAmount);
        (0, chai_1.expect)(await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await weth.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await usdc.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
    });
    it('Reserves should initially have borrow cap disabled (borrowCap = 0)', async () => {
        const { dai, usdc, helpersContract } = testEnv;
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal('0');
        (0, chai_1.expect)(daiBorrowCap).to.be.equal('0');
    });
    it('Borrows 10 stable DAI, 10 variable USDC', async () => {
        const { weth, pool, dai, usdc, deployer, users: [user1], } = testEnv;
        const suppliedAmount = '1000';
        const borrowedAmount = '10';
        // Deposit collateral
        (0, chai_1.expect)(await pool.deposit(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, suppliedAmount), deployer.address, 0));
        // User 1 deposit more DAI and USDC to be able to borrow
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), user1.address, 0));
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), user1.address, 0));
        // Borrow
        (0, chai_1.expect)(await pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 2, 0, deployer.address));
        (0, chai_1.expect)(await pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 1, 0, deployer.address));
    });
    it('Sets the borrow cap for DAI and USDC to 10 Units', async () => {
        const { configurator, dai, usdc, helpersContract } = testEnv;
        const { borrowCap: usdcOldBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiOldBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = 10;
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(usdc.address, daiOldBorrowCap, newCap);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(dai.address, usdcOldBorrowCap, newCap);
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiBorrowCap).to.be.equal(newCap);
    });
    it('Tries to borrow any DAI or USDC, stable or variable, (> BORROW_CAP) (revert expected)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '10';
        await (0, chai_1.expect)(pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 2, 0, deployer.address)).to.be.revertedWith(BORROW_CAP_EXCEEDED);
        await (0, chai_1.expect)(pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 2, 0, deployer.address)).to.be.revertedWith(BORROW_CAP_EXCEEDED);
    });
    it('Tries to set the borrow cap for USDC and DAI to > MAX_BORROW_CAP (revert expected)', async () => {
        const { configurator, usdc, dai } = testEnv;
        const newCap = Number(constants_1.MAX_BORROW_CAP) + 1;
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap)).to.be.revertedWith(INVALID_BORROW_CAP);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap)).to.be.revertedWith(INVALID_BORROW_CAP);
    });
    it('Sets the borrow cap for DAI and USDC to 120 Units', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const newCap = '120';
        const { borrowCap: usdcOldBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiOldBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(usdc.address, usdcOldBorrowCap, newCap);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(dai.address, daiOldBorrowCap, newCap);
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiBorrowCap).to.be.equal(newCap);
    });
    it('Borrows 10 stable DAI and 10 variable USDC', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '10';
        (0, chai_1.expect)(await pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 2, 0, deployer.address));
        (0, chai_1.expect)(await pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 1, 0, deployer.address));
    });
    it('Sets the borrow cap for WETH to 2 Units', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        const { borrowCap: wethOldBorrowCap } = await helpersContract.getReserveCaps(weth.address);
        const newCap = 2;
        await (0, chai_1.expect)(configurator.setBorrowCap(weth.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(weth.address, wethOldBorrowCap, newCap);
        const wethBorrowCap = (await helpersContract.getReserveCaps(weth.address)).borrowCap;
        (0, chai_1.expect)(wethBorrowCap).to.be.equal(newCap);
    });
    it('Borrows 2 variable WETH (= BORROW_CAP)', async () => {
        const { weth, pool, deployer, helpersContract } = testEnv;
        const borrowedAmount = '2';
        await pool.borrow(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, borrowedAmount), types_1.RateMode.Variable, 0, deployer.address);
    });
    it('Time flies and ETH debt amount goes above the limit due to accrued interests', async () => {
        const { weth, helpersContract } = testEnv;
        // Advance blocks
        await (0, deploy_v3_1.advanceTimeAndBlock)(3600);
        const wethData = await helpersContract.getReserveData(weth.address);
        const totalDebt = wethData.totalVariableDebt.add(wethData.totalStableDebt);
        const wethCaps = await helpersContract.getReserveCaps(weth.address);
        (0, chai_1.expect)(totalDebt).gt(wethCaps.borrowCap);
    });
    it('Tries to borrow any variable ETH (> BORROW_CAP) (revert expected)', async () => {
        const { weth, pool, deployer } = testEnv;
        const borrowedAmount = '1';
        await (0, chai_1.expect)(pool.borrow(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, borrowedAmount), types_1.RateMode.Variable, 0, deployer.address)).to.be.revertedWith(BORROW_CAP_EXCEEDED);
    });
    it('Borrows 99 variable DAI and 99 stable USDC (< BORROW_CAP)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '99';
        (0, chai_1.expect)(await pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 2, 0, deployer.address));
        (0, chai_1.expect)(await pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 1, 0, deployer.address));
    });
    it('Raises the borrow cap for USDC and DAI to 1000 Units', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { borrowCap: usdcOldBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiOldBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '1000';
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(usdc.address, usdcOldBorrowCap, newCap);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(dai.address, daiOldBorrowCap, newCap);
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiBorrowCap).to.be.equal(newCap);
    });
    it('Borrows 100 variable DAI and 100 stable USDC (< BORROW_CAP)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '100';
        (0, chai_1.expect)(await pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 1, 0, deployer.address));
        (0, chai_1.expect)(await pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 2, 0, deployer.address));
    });
    it('Lowers the borrow cap for USDC and DAI to 200 Units', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { borrowCap: usdcOldBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiOldBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '200';
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(usdc.address, usdcOldBorrowCap, newCap);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(dai.address, daiOldBorrowCap, newCap);
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiBorrowCap).to.be.equal(newCap);
    });
    it('Tries to borrows 100 variable DAI and 100 stable USDC (> BORROW_CAP) (revert expected)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '100';
        await (0, chai_1.expect)(pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 1, 0, deployer.address)).to.be.revertedWith(BORROW_CAP_EXCEEDED);
        await (0, chai_1.expect)(pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 2, 0, deployer.address)).to.be.revertedWith(BORROW_CAP_EXCEEDED);
    });
    it('Raises the borrow cap for USDC and DAI to MAX_BORROW_CAP', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { borrowCap: usdcOldBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiOldBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = constants_1.MAX_BORROW_CAP;
        await (0, chai_1.expect)(configurator.setBorrowCap(usdc.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(usdc.address, usdcOldBorrowCap, newCap);
        await (0, chai_1.expect)(configurator.setBorrowCap(dai.address, newCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(dai.address, daiOldBorrowCap, newCap);
        const { borrowCap: usdcBorrowCap } = await helpersContract.getReserveCaps(usdc.address);
        const { borrowCap: daiBorrowCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcBorrowCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiBorrowCap).to.be.equal(newCap);
    });
    it('Borrows 100 variable DAI and 100 stable USDC (< BORROW_CAP)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const borrowedAmount = '100';
        (0, chai_1.expect)(await pool.borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, borrowedAmount), 1, 0, deployer.address));
        (0, chai_1.expect)(await pool.borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, borrowedAmount), 2, 0, deployer.address));
    });
});
