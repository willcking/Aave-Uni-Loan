"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const make_suite_1 = require("./helpers/make-suite");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const deploy_v3_1 = require("@aave/deploy-v3");
const funds_1 = require("./helpers/utils/funds");
const utils_1 = require("ethers/lib/utils");
(0, make_suite_1.makeSuite)('PoolConfigurator: Edge cases', (testEnv) => {
    const { INVALID_RESERVE_FACTOR, INVALID_RESERVE_PARAMS, INVALID_LIQ_BONUS, FLASHLOAN_PREMIUM_INVALID, RESERVE_LIQUIDITY_NOT_ZERO, INVALID_BORROW_CAP, INVALID_SUPPLY_CAP, INVALID_UNBACKED_MINT_CAP, EMODE_CATEGORY_RESERVED, INVALID_EMODE_CATEGORY_PARAMS, INVALID_EMODE_CATEGORY_ASSIGNMENT, BRIDGE_PROTOCOL_FEE_INVALID, ASSET_NOT_LISTED, } = types_1.ProtocolErrors;
    it('ReserveConfiguration setLiquidationBonus() threshold > MAX_VALID_LIQUIDATION_THRESHOLD', async () => {
        const { poolAdmin, dai, configurator } = testEnv;
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(dai.address, 5, 10, 65535 + 1)).to.be.revertedWith(INVALID_LIQ_BONUS);
    });
    it('PoolConfigurator setReserveFactor() reserveFactor > PERCENTAGE_FACTOR (revert expected)', async () => {
        const { dai, configurator } = testEnv;
        const invalidReserveFactor = 20000;
        await (0, chai_1.expect)(configurator.setReserveFactor(dai.address, invalidReserveFactor)).to.be.revertedWith(INVALID_RESERVE_FACTOR);
    });
    it('ReserveConfiguration setReserveFactor() reserveFactor > MAX_VALID_RESERVE_FACTOR', async () => {
        const { dai, configurator } = testEnv;
        const invalidReserveFactor = 65536;
        await (0, chai_1.expect)(configurator.setReserveFactor(dai.address, invalidReserveFactor)).to.be.revertedWith(INVALID_RESERVE_FACTOR);
    });
    it('PoolConfigurator configureReserveAsCollateral() ltv > liquidationThreshold', async () => {
        const { poolAdmin, dai, configurator, helpersContract } = testEnv;
        const config = await helpersContract.getReserveConfigurationData(dai.address);
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(dai.address, 65535 + 1, config.liquidationThreshold, config.liquidationBonus)).to.be.revertedWith(INVALID_RESERVE_PARAMS);
    });
    it('PoolConfigurator configureReserveAsCollateral() liquidationBonus < 10000', async () => {
        const { poolAdmin, dai, configurator, helpersContract } = testEnv;
        const config = await helpersContract.getReserveConfigurationData(dai.address);
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(dai.address, config.ltv, config.liquidationThreshold, 10000)).to.be.revertedWith(INVALID_RESERVE_PARAMS);
    });
    it('PoolConfigurator configureReserveAsCollateral() liquidationThreshold.percentMul(liquidationBonus) > PercentageMath.PERCENTAGE_FACTOR', async () => {
        const { poolAdmin, dai, configurator } = testEnv;
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(dai.address, 10001, 10001, 10001)).to.be.revertedWith(INVALID_RESERVE_PARAMS);
    });
    it('PoolConfigurator configureReserveAsCollateral() liquidationThreshold == 0 && liquidationBonus > 0', async () => {
        const { poolAdmin, dai, configurator } = testEnv;
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).configureReserveAsCollateral(dai.address, 0, 0, 10500)).to.be.revertedWith(INVALID_RESERVE_PARAMS);
    });
    it('Tries to bridge protocol fee > PERCENTAGE_FACTOR (revert expected)', async () => {
        const { configurator } = testEnv;
        const newProtocolFee = 10001;
        await (0, chai_1.expect)(configurator.updateBridgeProtocolFee(newProtocolFee)).to.be.revertedWith(BRIDGE_PROTOCOL_FEE_INVALID);
    });
    it('Tries to update flashloan premium total > PERCENTAGE_FACTOR (revert expected)', async () => {
        const { configurator } = testEnv;
        const newPremiumTotal = 10001;
        await (0, chai_1.expect)(configurator.updateFlashloanPremiumTotal(newPremiumTotal)).to.be.revertedWith(FLASHLOAN_PREMIUM_INVALID);
    });
    it('Tries to update flashloan premium to protocol > PERCENTAGE_FACTOR (revert expected)', async () => {
        const { configurator } = testEnv;
        const newPremiumToProtocol = 10001;
        await (0, chai_1.expect)(configurator.updateFlashloanPremiumToProtocol(newPremiumToProtocol)).to.be.revertedWith(FLASHLOAN_PREMIUM_INVALID);
    });
    it('Tries to update borrowCap > MAX_BORROW_CAP (revert expected)', async () => {
        const { configurator, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setBorrowCap(weth.address, ethers_1.BigNumber.from(constants_1.MAX_BORROW_CAP).add(1))).to.be.revertedWith(INVALID_BORROW_CAP);
    });
    it('Tries to update supplyCap > MAX_SUPPLY_CAP (revert expected)', async () => {
        const { configurator, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setSupplyCap(weth.address, ethers_1.BigNumber.from(constants_1.MAX_SUPPLY_CAP).add(1))).to.be.revertedWith(INVALID_SUPPLY_CAP);
    });
    it('Tries to update unbackedMintCap > MAX_UNBACKED_MINT_CAP (revert expected)', async () => {
        const { configurator, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setUnbackedMintCap(weth.address, ethers_1.BigNumber.from(constants_1.MAX_UNBACKED_MINT_CAP).add(1))).to.be.revertedWith(INVALID_UNBACKED_MINT_CAP);
    });
    it('Tries to set borrowCap of MAX_BORROW_CAP an unlisted asset', async () => {
        const { configurator, users } = testEnv;
        const newCap = 10;
        await (0, chai_1.expect)(configurator.setBorrowCap(users[5].address, newCap)).to.be.revertedWith(ASSET_NOT_LISTED);
    });
    it('Tries to add a category with id 0 (revert expected)', async () => {
        const { configurator, poolAdmin } = testEnv;
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(0, '9800', '9800', '10100', constants_1.ZERO_ADDRESS, 'INVALID_ID_CATEGORY')).to.be.revertedWith(EMODE_CATEGORY_RESERVED);
    });
    it('Tries to add an eMode category with ltv > liquidation threshold (revert expected)', async () => {
        const { configurator, poolAdmin } = testEnv;
        const id = ethers_1.BigNumber.from('16');
        const ltv = ethers_1.BigNumber.from('9900');
        const lt = ethers_1.BigNumber.from('9800');
        const lb = ethers_1.BigNumber.from('10100');
        const oracle = constants_1.ZERO_ADDRESS;
        const label = 'STABLECOINS';
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setEModeCategory(id, ltv, lt, lb, oracle, label)).to.be.revertedWith(INVALID_EMODE_CATEGORY_PARAMS);
    });
    it('Tries to add an eMode category with no liquidation bonus (revert expected)', async () => {
        const { configurator, poolAdmin } = testEnv;
        const id = ethers_1.BigNumber.from('16');
        const ltv = ethers_1.BigNumber.from('9800');
        const lt = ethers_1.BigNumber.from('9800');
        const lb = ethers_1.BigNumber.from('10000');
        const oracle = constants_1.ZERO_ADDRESS;
        const label = 'STABLECOINS';
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setEModeCategory(id, ltv, lt, lb, oracle, label)).to.be.revertedWith(INVALID_EMODE_CATEGORY_PARAMS);
    });
    it('Tries to add an eMode category with too large liquidation bonus (revert expected)', async () => {
        const { configurator, poolAdmin } = testEnv;
        const id = ethers_1.BigNumber.from('16');
        const ltv = ethers_1.BigNumber.from('9800');
        const lt = ethers_1.BigNumber.from('9800');
        const lb = ethers_1.BigNumber.from('11000');
        const oracle = constants_1.ZERO_ADDRESS;
        const label = 'STABLECOINS';
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setEModeCategory(id, ltv, lt, lb, oracle, label)).to.be.revertedWith(INVALID_EMODE_CATEGORY_PARAMS);
    });
    it('Tries to add an eMode category with liquidation threshold > 1 (revert expected)', async () => {
        const { configurator, poolAdmin } = testEnv;
        const id = ethers_1.BigNumber.from('16');
        const ltv = ethers_1.BigNumber.from('9800');
        const lt = ethers_1.BigNumber.from('10100');
        const lb = ethers_1.BigNumber.from('10100');
        const oracle = constants_1.ZERO_ADDRESS;
        const label = 'STABLECOINS';
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setEModeCategory(id, ltv, lt, lb, oracle, label)).to.be.revertedWith(INVALID_EMODE_CATEGORY_PARAMS);
    });
    it('Tries to set DAI eMode category to undefined category (revert expected)', async () => {
        const { configurator, poolAdmin, dai } = testEnv;
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, '100')).to.be.revertedWith(INVALID_EMODE_CATEGORY_ASSIGNMENT);
    });
    it('Tries to set DAI eMode category to category with too low LT (revert expected)', async () => {
        const { configurator, helpersContract, poolAdmin, dai } = testEnv;
        const { liquidationThreshold, ltv } = await helpersContract.getReserveConfigurationData(dai.address);
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory('100', ltv, liquidationThreshold.sub(1), '10100', constants_1.ZERO_ADDRESS, 'LT_TOO_LOW_FOR_DAI'));
        await (0, chai_1.expect)(configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, '100')).to.be.revertedWith(INVALID_EMODE_CATEGORY_ASSIGNMENT);
    });
    it('Tries to disable the DAI reserve with liquidity on it (revert expected)', async () => {
        const { dai, pool, configurator, faucetMintable, deployer } = testEnv;
        const userAddress = await pool.signer.getAddress();
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, deployer.address, amountDAItoDeposit));
        // Approve protocol to access depositor wallet
        (0, chai_1.expect)(await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        // User 1 deposits 1000 DAI
        (0, chai_1.expect)(await pool.deposit(dai.address, amountDAItoDeposit, userAddress, '0'));
        await (0, chai_1.expect)(configurator.setReserveActive(dai.address, false), RESERVE_LIQUIDITY_NOT_ZERO).to.be.revertedWith(RESERVE_LIQUIDITY_NOT_ZERO);
    });
    it('Tries to withdraw from an inactive reserve (revert expected)', async () => {
        const { dai, pool, configurator, helpersContract, faucetMintable, deployer } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        const userAddress = await pool.signer.getAddress();
        // Impersonate configurator
        const impConfig = await (0, deploy_v3_1.impersonateAddress)(configurator.address);
        await (0, funds_1.topUpNonPayableWithEther)(pool.signer, [configurator.address], (0, utils_1.parseUnits)('10', 18));
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, deployer.address, amountDAItoDeposit));
        // Approve protocol to access depositor wallet
        (0, chai_1.expect)(await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        // User 1 deposits 1000 DAI
        (0, chai_1.expect)(await pool.deposit(dai.address, amountDAItoDeposit, userAddress, '0'));
        // get configuration
        const daiConfiguration = (await pool.getConfiguration(dai.address)).data;
        const activeMask = ethers_1.BigNumber.from('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF');
        // Set new configuration with active turned off
        (0, chai_1.expect)(await pool
            .connect(impConfig.signer)
            .setConfiguration(dai.address, { data: daiConfiguration.and(activeMask) }));
        const updatedConfiguration = await helpersContract.getReserveConfigurationData(dai.address);
        (0, chai_1.expect)(updatedConfiguration.isActive).to.false;
        await (0, chai_1.expect)(pool.withdraw(dai.address, amountDAItoDeposit, userAddress)).to.be.revertedWith(types_1.ProtocolErrors.RESERVE_INACTIVE);
    });
});
