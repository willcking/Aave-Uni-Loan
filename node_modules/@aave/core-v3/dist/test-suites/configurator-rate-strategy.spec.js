"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../types");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('PoolConfigurator: Set Rate Strategy', (testEnv) => {
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Update Interest Rate of a reserve', async () => {
        const { poolAdmin, configurator, pool, helpersContract, weth, dai, usdc, users: [depositor, borrower], faucetMintable } = testEnv;
        // Utilize the DAI pool
        const mintedAmount = ethers_1.utils.parseEther('100');
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, depositor.address, mintedAmount));
        (0, chai_1.expect)(await dai.connect(depositor.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(depositor.signer).deposit(dai.address, mintedAmount, depositor.address, 0));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, borrower.address, mintedAmount));
        (0, chai_1.expect)(await weth.connect(borrower.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(borrower.signer).deposit(weth.address, mintedAmount, borrower.address, 0));
        (0, chai_1.expect)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, borrower.address));
        // PoolAdmin updates IR strategy address
        const strategyUSDC = await helpersContract.getInterestRateStrategyAddress(usdc.address);
        const reserveDataBefore = await pool.getReserveData(dai.address);
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .setReserveInterestRateStrategyAddress(dai.address, strategyUSDC))
            .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
            .withArgs(dai.address, reserveDataBefore.interestRateStrategyAddress, strategyUSDC);
        const reserveDataAfter = await pool.getReserveData(dai.address);
        (0, chai_1.expect)(reserveDataAfter.interestRateStrategyAddress).to.be.eq(strategyUSDC);
        // Indexes and rates are the same until a new operation is performed
        (0, chai_1.expect)(reserveDataBefore.liquidityIndex).to.be.eq(reserveDataAfter.liquidityIndex);
        (0, chai_1.expect)(reserveDataBefore.currentLiquidityRate).to.be.eq(reserveDataAfter.currentLiquidityRate);
        (0, chai_1.expect)(reserveDataBefore.variableBorrowIndex).to.be.eq(reserveDataAfter.variableBorrowIndex);
        (0, chai_1.expect)(reserveDataBefore.currentVariableBorrowRate).to.be.eq(reserveDataAfter.currentVariableBorrowRate);
        (0, chai_1.expect)(reserveDataBefore.currentStableBorrowRate).to.be.eq(reserveDataAfter.currentStableBorrowRate);
        (0, chai_1.expect)(reserveDataBefore.lastUpdateTimestamp).to.be.eq(reserveDataAfter.lastUpdateTimestamp);
        // Reserve interaction so IR gets applied
        (0, chai_1.expect)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, borrower.address));
        // Rates get updated
        const reserveDataUpdated = await pool.getReserveData(dai.address);
        (0, chai_1.expect)(reserveDataAfter.interestRateStrategyAddress).to.be.eq(reserveDataUpdated.interestRateStrategyAddress);
        (0, chai_1.expect)(reserveDataAfter.currentLiquidityRate).to.be.not.eq(reserveDataUpdated.currentLiquidityRate);
        (0, chai_1.expect)(reserveDataAfter.currentVariableBorrowRate).to.be.not.eq(reserveDataUpdated.currentVariableBorrowRate);
        (0, chai_1.expect)(reserveDataAfter.currentStableBorrowRate).to.be.not.eq(reserveDataUpdated.currentStableBorrowRate);
        (0, chai_1.expect)(reserveDataAfter.lastUpdateTimestamp).to.be.lt(reserveDataUpdated.lastUpdateTimestamp);
    });
    it('Update Interest Rate of a reserve with ZERO_ADDRESS and bricks the reserve (revert expected)', async () => {
        const { poolAdmin, configurator, pool, weth, dai, users: [depositor, borrower], faucetMintable } = testEnv;
        // Utilize the DAI pool
        const mintedAmount = ethers_1.utils.parseEther('100');
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, depositor.address, mintedAmount));
        (0, chai_1.expect)(await dai.connect(depositor.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(depositor.signer).deposit(dai.address, mintedAmount, depositor.address, 0));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, borrower.address, mintedAmount));
        (0, chai_1.expect)(await weth.connect(borrower.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(borrower.signer).deposit(weth.address, mintedAmount, borrower.address, 0));
        (0, chai_1.expect)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, borrower.address));
        // PoolAdmin updates IR strategy address
        const reserveDataBefore = await pool.getReserveData(dai.address);
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .setReserveInterestRateStrategyAddress(dai.address, deploy_v3_1.ZERO_ADDRESS))
            .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
            .withArgs(dai.address, reserveDataBefore.interestRateStrategyAddress, deploy_v3_1.ZERO_ADDRESS);
        // Reserve interaction so IR gets applied
        await (0, chai_1.expect)(pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, borrower.address)).reverted;
    });
    it('ZeroReserveInterestRateStrategy - Checks all rates are 0', async () => {
        const { deployer, addressesProvider } = testEnv;
        const zeroStrategy = await new types_1.ZeroReserveInterestRateStrategy__factory(deployer.signer).deploy(addressesProvider.address);
        (0, chai_1.expect)(await zeroStrategy.OPTIMAL_USAGE_RATIO()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.MAX_EXCESS_USAGE_RATIO()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getVariableRateSlope1()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getVariableRateSlope2()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getStableRateSlope1()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getStableRateSlope2()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getStableRateExcessOffset()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getBaseStableBorrowRate()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getBaseVariableBorrowRate()).to.be.eq(0);
        (0, chai_1.expect)(await zeroStrategy.getMaxVariableBorrowRate()).to.be.eq(0);
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await zeroStrategy.calculateInterestRates({
            unbacked: 0,
            liquidityAdded: 0,
            liquidityTaken: 0,
            totalStableDebt: 0,
            totalVariableDebt: 0,
            averageStableBorrowRate: 0,
            reserveFactor: 0,
            reserve: deploy_v3_1.ZERO_ADDRESS,
            aToken: deploy_v3_1.ZERO_ADDRESS,
        });
        (0, chai_1.expect)(currentLiquidityRate).to.be.eq(0, 'Invalid liquidity rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.eq(0, 'Invalid stable rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.eq(0, 'Invalid variable rate');
    });
    it('ZeroReserveInterestRateStrategy - Update a reserve with ZeroInterestRateStrategy to set zero rates', async () => {
        const { deployer, poolAdmin, configurator, pool, addressesProvider, weth, dai, faucetMintable, users: [depositor, borrower, stableBorrower], } = testEnv;
        const zeroStrategy = await new types_1.ZeroReserveInterestRateStrategy__factory(deployer.signer).deploy(addressesProvider.address);
        // Utilize the DAI pool
        const mintedAmount = ethers_1.utils.parseEther('100');
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, depositor.address, mintedAmount));
        (0, chai_1.expect)(await dai.connect(depositor.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(depositor.signer).deposit(dai.address, mintedAmount, depositor.address, 0));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, borrower.address, mintedAmount));
        (0, chai_1.expect)(await weth.connect(borrower.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(borrower.signer).deposit(weth.address, mintedAmount, borrower.address, 0));
        (0, chai_1.expect)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 2, 0, borrower.address));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, stableBorrower.address, mintedAmount));
        (0, chai_1.expect)(await weth.connect(stableBorrower.signer).approve(pool.address, deploy_v3_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(stableBorrower.signer)
            .deposit(weth.address, mintedAmount, stableBorrower.address, 0));
        (0, chai_1.expect)(await pool
            .connect(stableBorrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, stableBorrower.address));
        // PoolAdmin updates IR strategy address
        const reserveDataBefore = await pool.getReserveData(dai.address);
        await (0, chai_1.expect)(configurator
            .connect(poolAdmin.signer)
            .setReserveInterestRateStrategyAddress(dai.address, zeroStrategy.address))
            .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
            .withArgs(dai.address, reserveDataBefore.interestRateStrategyAddress, zeroStrategy.address);
        const reserveDataAfter = await pool.getReserveData(dai.address);
        (0, chai_1.expect)(reserveDataAfter.interestRateStrategyAddress).to.be.eq(zeroStrategy.address);
        // Indexes and rates are the same until a new operation is performed
        (0, chai_1.expect)(reserveDataBefore.liquidityIndex).to.be.eq(reserveDataAfter.liquidityIndex);
        (0, chai_1.expect)(reserveDataBefore.currentLiquidityRate).to.be.eq(reserveDataAfter.currentLiquidityRate);
        (0, chai_1.expect)(reserveDataBefore.variableBorrowIndex).to.be.eq(reserveDataAfter.variableBorrowIndex);
        (0, chai_1.expect)(reserveDataBefore.currentVariableBorrowRate).to.be.eq(reserveDataAfter.currentVariableBorrowRate);
        (0, chai_1.expect)(reserveDataBefore.currentStableBorrowRate).to.be.eq(reserveDataAfter.currentStableBorrowRate);
        (0, chai_1.expect)(reserveDataBefore.lastUpdateTimestamp).to.be.eq(reserveDataAfter.lastUpdateTimestamp);
        // Reserve interaction so IR gets applied
        (0, chai_1.expect)(await pool
            .connect(borrower.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), 1, 0, borrower.address));
        // Rates get updated
        const reserveDataUpdated = await pool.getReserveData(dai.address);
        (0, chai_1.expect)(reserveDataAfter.interestRateStrategyAddress).to.be.eq(zeroStrategy.address);
        (0, chai_1.expect)(reserveDataAfter.currentLiquidityRate).to.be.not.eq(reserveDataUpdated.currentLiquidityRate);
        (0, chai_1.expect)(reserveDataAfter.currentVariableBorrowRate).to.be.not.eq(reserveDataUpdated.currentVariableBorrowRate);
        (0, chai_1.expect)(reserveDataAfter.currentStableBorrowRate).to.be.not.eq(reserveDataUpdated.currentStableBorrowRate);
        (0, chai_1.expect)(reserveDataAfter.lastUpdateTimestamp).to.be.lt(reserveDataUpdated.lastUpdateTimestamp);
        (0, chai_1.expect)(reserveDataUpdated.currentLiquidityRate).to.be.eq(0);
        (0, chai_1.expect)(reserveDataUpdated.currentVariableBorrowRate).to.be.eq(0);
        (0, chai_1.expect)(reserveDataUpdated.currentStableBorrowRate).to.be.eq(0);
        // Stable borrow gets rebalanced
        await (0, chai_1.expect)(pool.connect(depositor.signer).rebalanceStableBorrowRate(dai.address, stableBorrower.address))
            .to.emit(pool, 'RebalanceStableBorrowRate')
            .withArgs(dai.address, stableBorrower.address);
        // Stable borrow can be rebalanced as many times the rebalancer likes
        await (0, chai_1.expect)(pool.connect(depositor.signer).rebalanceStableBorrowRate(dai.address, stableBorrower.address))
            .to.emit(pool, 'RebalanceStableBorrowRate')
            .withArgs(dai.address, stableBorrower.address);
    });
});
