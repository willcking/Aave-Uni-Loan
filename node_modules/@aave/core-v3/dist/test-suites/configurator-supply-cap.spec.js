"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
(0, make_suite_1.makeSuite)('PoolConfigurator: Supply Cap', (testEnv) => {
    const { SUPPLY_CAP_EXCEEDED, INVALID_SUPPLY_CAP } = types_1.ProtocolErrors;
    before(async () => {
        const { weth, pool, dai, usdc, faucetMintable, deployer } = testEnv;
        const mintedAmount = ethers_1.utils.parseEther('1000000000');
        await faucetMintable.mint(dai.address, deployer.address, mintedAmount);
        await faucetMintable.mint(weth.address, deployer.address, mintedAmount);
        await faucetMintable.mint(usdc.address, deployer.address, mintedAmount);
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await weth.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
    });
    it('Reserves should initially have supply cap disabled (supplyCap = 0)', async () => {
        const { dai, usdc, helpersContract } = testEnv;
        let usdcSupplyCap = (await helpersContract.getReserveCaps(usdc.address)).supplyCap;
        let daiSupplyCap = (await helpersContract.getReserveCaps(dai.address)).supplyCap;
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal('0');
        (0, chai_1.expect)(daiSupplyCap).to.be.equal('0');
    });
    it('Supply 1000 Dai, 1000 USDC and 1000 WETH', async () => {
        const { weth, pool, dai, usdc, deployer } = testEnv;
        const suppliedAmount = '1000';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, suppliedAmount), deployer.address, 0);
    });
    it('Sets the supply cap for DAI and USDC to 1000 Unit, leaving 0 Units to reach the limit', async () => {
        const { configurator, dai, usdc, helpersContract } = testEnv;
        const { supplyCap: oldUsdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: oldDaiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '1000';
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(usdc.address, oldUsdcSupplyCap, newCap);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(dai.address, oldDaiSupplyCap, newCap);
        const { supplyCap: usdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: daiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiSupplyCap).to.be.equal(newCap);
    });
    it('Tries to supply any DAI or USDC (> SUPPLY_CAP) (revert expected)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '10';
        await (0, chai_1.expect)(pool.deposit(usdc.address, suppliedAmount, deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
        await (0, chai_1.expect)(pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
    });
    it('Tries to set the supply cap for USDC and DAI to > MAX_SUPPLY_CAP (revert expected)', async () => {
        const { configurator, usdc, dai } = testEnv;
        const newCap = Number(constants_1.MAX_SUPPLY_CAP) + 1;
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap)).to.be.revertedWith(INVALID_SUPPLY_CAP);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap)).to.be.revertedWith(INVALID_SUPPLY_CAP);
    });
    it('Sets the supply cap for usdc and DAI to 1110 Units, leaving 110 Units to reach the limit', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { supplyCap: oldUsdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: oldDaiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '1110';
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(usdc.address, oldUsdcSupplyCap, newCap);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(dai.address, oldDaiSupplyCap, newCap);
        const { supplyCap: usdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: daiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiSupplyCap).to.be.equal(newCap);
    });
    it('Supply 10 DAI and 10 USDC, leaving 100 Units to reach the limit', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '10';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
    });
    it('Tries to supply 101 DAI and 101 USDC (> SUPPLY_CAP) 1 unit above the limit (revert expected)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '101';
        await (0, chai_1.expect)(pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
        await (0, chai_1.expect)(pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
    });
    it('Supply 99 DAI and 99 USDC (< SUPPLY_CAP), leaving 1 Units to reach the limit', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '99';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
    });
    it('Supply 1 DAI and 1 USDC (= SUPPLY_CAP), reaching the limit', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '1';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
    });
    it('Time flies and DAI and USDC supply amount goes above the limit due to accrued interests', async () => {
        const { usdc, pool, dai, deployer, helpersContract } = testEnv;
        // Advance blocks
        await (0, deploy_v3_1.advanceTimeAndBlock)(3600);
        const daiData = await helpersContract.getReserveData(dai.address);
        const daiCaps = await helpersContract.getReserveCaps(dai.address);
        const usdcData = await helpersContract.getReserveData(usdc.address);
        const usdcCaps = await helpersContract.getReserveCaps(usdc.address);
        (0, chai_1.expect)(daiData.totalAToken).gt(daiCaps.supplyCap);
        (0, chai_1.expect)(usdcData.totalAToken).gt(usdcCaps.supplyCap);
    });
    it('Raises the supply cap for USDC and DAI to 2000 Units, leaving 800 Units to reach the limit', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { supplyCap: oldUsdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: oldDaiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '2000';
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(usdc.address, oldUsdcSupplyCap, newCap);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(dai.address, oldDaiSupplyCap, newCap);
        const { supplyCap: usdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: daiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiSupplyCap).to.be.equal(newCap);
    });
    it('Supply 100 DAI and 100 USDC, leaving 700 Units to reach the limit', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '100';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
    });
    it('Lowers the supply cap for USDC and DAI to 1200 Units (suppliedAmount > supplyCap)', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { supplyCap: oldUsdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: oldDaiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = '1200';
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(usdc.address, oldUsdcSupplyCap, newCap);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(dai.address, oldDaiSupplyCap, newCap);
        const { supplyCap: usdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: daiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiSupplyCap).to.be.equal(newCap);
    });
    it('Tries to supply 100 DAI and 100 USDC (> SUPPLY_CAP) (revert expected)', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '100';
        await (0, chai_1.expect)(pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
        await (0, chai_1.expect)(pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0)).to.be.revertedWith(SUPPLY_CAP_EXCEEDED);
    });
    it('Raises the supply cap for USDC and DAI to MAX_SUPPLY_CAP', async () => {
        const { configurator, usdc, dai, helpersContract } = testEnv;
        const { supplyCap: oldUsdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: oldDaiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        const newCap = constants_1.MAX_SUPPLY_CAP;
        await (0, chai_1.expect)(configurator.setSupplyCap(usdc.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(usdc.address, oldUsdcSupplyCap, newCap);
        await (0, chai_1.expect)(configurator.setSupplyCap(dai.address, newCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(dai.address, oldDaiSupplyCap, newCap);
        const { supplyCap: usdcSupplyCap } = await helpersContract.getReserveCaps(usdc.address);
        const { supplyCap: daiSupplyCap } = await helpersContract.getReserveCaps(dai.address);
        (0, chai_1.expect)(usdcSupplyCap).to.be.equal(newCap);
        (0, chai_1.expect)(daiSupplyCap).to.be.equal(newCap);
    });
    it('Supply 100 DAI and 100 USDC', async () => {
        const { usdc, pool, dai, deployer } = testEnv;
        const suppliedAmount = '100';
        await pool.deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, suppliedAmount), deployer.address, 0);
        await pool.deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, suppliedAmount), deployer.address, 0);
    });
});
