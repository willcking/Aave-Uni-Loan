"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const reservesConfigs_1 = require("@aave/deploy-v3/dist/markets/test/reservesConfigs");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const types_2 = require("../types");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
const expectReserveConfigurationData = async (helpersContract, asset, values) => {
    const [reserveCfg, eModeCategory, reserveCaps, isPaused] = await getReserveData(helpersContract, asset);
    (0, chai_1.expect)(reserveCfg.decimals).to.be.eq(values.reserveDecimals, 'reserveDecimals is not correct');
    (0, chai_1.expect)(reserveCfg.ltv).to.be.eq(values.baseLTVAsCollateral, 'ltv is not correct');
    (0, chai_1.expect)(reserveCfg.liquidationThreshold).to.be.eq(values.liquidationThreshold, 'liquidationThreshold is not correct');
    (0, chai_1.expect)(reserveCfg.liquidationBonus).to.be.eq(values.liquidationBonus, 'liquidationBonus is not correct');
    (0, chai_1.expect)(reserveCfg.reserveFactor).to.be.eq(values.reserveFactor, 'reserveFactor is not correct');
    (0, chai_1.expect)(reserveCfg.usageAsCollateralEnabled).to.be.eq(values.usageAsCollateralEnabled, 'usageAsCollateralEnabled is not correct');
    (0, chai_1.expect)(reserveCfg.borrowingEnabled).to.be.eq(values.borrowingEnabled, 'borrowingEnabled is not correct');
    (0, chai_1.expect)(reserveCfg.stableBorrowRateEnabled).to.be.eq(values.stableBorrowRateEnabled, 'stableBorrowRateEnabled is not correct');
    (0, chai_1.expect)(reserveCfg.isActive).to.be.eq(values.isActive, 'isActive is not correct');
    (0, chai_1.expect)(reserveCfg.isFrozen).to.be.eq(values.isFrozen, 'isFrozen is not correct');
    (0, chai_1.expect)(isPaused).to.be.equal(values.isPaused, 'isPaused is not correct');
    (0, chai_1.expect)(eModeCategory).to.be.eq(values.eModeCategory, 'eModeCategory is not correct');
    (0, chai_1.expect)(reserveCaps.borrowCap).to.be.eq(values.borrowCap, 'borrowCap is not correct');
    (0, chai_1.expect)(reserveCaps.supplyCap).to.be.eq(values.supplyCap, 'supplyCap is not correct');
};
const getReserveData = async (helpersContract, asset) => {
    return Promise.all([
        helpersContract.getReserveConfigurationData(asset),
        helpersContract.getReserveEModeCategory(asset),
        helpersContract.getReserveCaps(asset),
        helpersContract.getPaused(asset),
        helpersContract.getLiquidationProtocolFee(asset),
        helpersContract.getUnbackedMintCap(asset),
    ]);
};
(0, make_suite_1.makeSuite)('PoolConfigurator', (testEnv) => {
    let baseConfigValues;
    const { RESERVE_LIQUIDITY_NOT_ZERO, INVALID_DEBT_CEILING, RESERVE_DEBT_NOT_ZERO } = types_1.ProtocolErrors;
    before(() => {
        const { reserveDecimals, baseLTVAsCollateral, liquidationThreshold, liquidationBonus, reserveFactor, borrowingEnabled, stableBorrowRateEnabled, borrowCap, supplyCap, } = reservesConfigs_1.strategyWETH;
        baseConfigValues = {
            reserveDecimals,
            baseLTVAsCollateral,
            liquidationThreshold,
            liquidationBonus,
            reserveFactor,
            usageAsCollateralEnabled: true,
            borrowingEnabled,
            stableBorrowRateEnabled,
            isActive: true,
            isFrozen: false,
            isPaused: false,
            eModeCategory: ethers_1.BigNumber.from(0),
            borrowCap: borrowCap,
            supplyCap: supplyCap,
        };
    });
    it('InitReserves via AssetListing admin', async () => {
        const { addressesProvider, configurator, poolAdmin, aclManager, users, pool } = testEnv;
        // const snapId
        const assetListingAdmin = users[4];
        // Add new AssetListingAdmin
        (0, chai_1.expect)(await aclManager.connect(poolAdmin.signer).addAssetListingAdmin(assetListingAdmin.address));
        // Deploy mock `InitReserveInput`
        const mockToken = await new types_2.MintableERC20__factory(await (0, signer_1.getFirstSigner)()).deploy('MOCK', 'MOCK', '18');
        const stableDebtTokenImplementation = await new types_2.StableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const variableDebtTokenImplementation = await new types_2.VariableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const aTokenImplementation = await new types_2.AToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const mockRateStrategy = await new types_2.MockReserveInterestRateStrategy__factory(await (0, signer_1.getFirstSigner)()).deploy(addressesProvider.address, 0, 0, 0, 0, 0, 0);
        // Init the reserve
        const initInputParams = [
            {
                aTokenImpl: aTokenImplementation.address,
                stableDebtTokenImpl: stableDebtTokenImplementation.address,
                variableDebtTokenImpl: variableDebtTokenImplementation.address,
                underlyingAssetDecimals: 18,
                interestRateStrategyAddress: mockRateStrategy.address,
                underlyingAsset: mockToken.address,
                treasury: constants_1.ZERO_ADDRESS,
                incentivesController: constants_1.ZERO_ADDRESS,
                aTokenName: 'AMOCK',
                aTokenSymbol: 'AMOCK',
                variableDebtTokenName: 'VMOCK',
                variableDebtTokenSymbol: 'VMOCK',
                stableDebtTokenName: 'SMOCK',
                stableDebtTokenSymbol: 'SMOCK',
                params: '0x10',
            },
        ];
        (0, chai_1.expect)(await configurator.connect(assetListingAdmin.signer).initReserves(initInputParams));
    });
    it('Deactivates the ETH reserve', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveActive(weth.address, false));
        const { isActive } = await helpersContract.getReserveConfigurationData(weth.address);
        (0, chai_1.expect)(isActive).to.be.equal(false);
    });
    it('Reactivates the ETH reserve', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveActive(weth.address, true));
        const { isActive } = await helpersContract.getReserveConfigurationData(weth.address);
        (0, chai_1.expect)(isActive).to.be.equal(true);
    });
    it('Pauses the ETH reserve by pool admin', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        await (0, chai_1.expect)(configurator.setReservePause(weth.address, true))
            .to.emit(configurator, 'ReservePaused')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            isPaused: true,
        });
    });
    it('Unpauses the ETH reserve by pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReservePause(weth.address, false))
            .to.emit(configurator, 'ReservePaused')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, { ...baseConfigValues });
    });
    it('Pauses the ETH reserve by emergency admin', async () => {
        const { configurator, weth, helpersContract, emergencyAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(emergencyAdmin.signer).setReservePause(weth.address, true))
            .to.emit(configurator, 'ReservePaused')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            isPaused: true,
        });
    });
    it('Unpauses the ETH reserve by emergency admin', async () => {
        const { configurator, helpersContract, weth, emergencyAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(emergencyAdmin.signer).setReservePause(weth.address, false))
            .to.emit(configurator, 'ReservePaused')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, { ...baseConfigValues });
    });
    it('Freezes the ETH reserve by pool Admin', async () => {
        const { configurator, weth, helpersContract } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveFreeze(weth.address, true))
            .to.emit(configurator, 'ReserveFrozen')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            isFrozen: true,
        });
    });
    it('Unfreezes the ETH reserve by Pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveFreeze(weth.address, false))
            .to.emit(configurator, 'ReserveFrozen')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, { ...baseConfigValues });
    });
    it('Freezes the ETH reserve by Risk Admin', async () => {
        const { configurator, weth, helpersContract, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveFreeze(weth.address, true))
            .to.emit(configurator, 'ReserveFrozen')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            isFrozen: true,
        });
    });
    it('Unfreezes the ETH reserve by Risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveFreeze(weth.address, false))
            .to.emit(configurator, 'ReserveFrozen')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, { ...baseConfigValues });
    });
    it('Deactivates the ETH reserve for borrowing via pool admin while stable borrowing is active (revert expected)', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveBorrowing(weth.address, false)).to.be.revertedWith(types_1.ProtocolErrors.STABLE_BORROWING_ENABLED);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
        });
    });
    it('Deactivates the ETH reserve for borrowing via risk admin while stable borrowing is active (revert expected)', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveBorrowing(weth.address, false)).to.be.revertedWith(types_1.ProtocolErrors.STABLE_BORROWING_ENABLED);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
        });
    });
    it('Disable stable borrow rate on the ETH reserve via pool admin', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveStableRateBorrowing(weth.address, false))
            .to.emit(configurator, 'ReserveStableRateBorrowing')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            stableBorrowRateEnabled: false,
        });
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Disable stable borrow rate on the ETH reserve via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveStableRateBorrowing(weth.address, false))
            .to.emit(configurator, 'ReserveStableRateBorrowing')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            stableBorrowRateEnabled: false,
        });
    });
    it('Deactivates the ETH reserve for borrowing via pool admin', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveBorrowing(weth.address, false))
            .to.emit(configurator, 'ReserveBorrowing')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowingEnabled: false,
            stableBorrowRateEnabled: false,
        });
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Deactivates the ETH reserve for borrowing via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveBorrowing(weth.address, false))
            .to.emit(configurator, 'ReserveBorrowing')
            .withArgs(weth.address, false);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowingEnabled: false,
            stableBorrowRateEnabled: false,
        });
    });
    it('Enables stable borrow rate on the ETH reserve via pool admin while borrowing is disabled (revert expected)', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        await (0, chai_1.expect)(configurator.setReserveStableRateBorrowing(weth.address, true)).to.be.revertedWith(types_1.ProtocolErrors.BORROWING_NOT_ENABLED);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowingEnabled: false,
            stableBorrowRateEnabled: false,
        });
    });
    it('Enables stable borrow rate on the ETH reserve via risk admin while borrowing is disabled (revert expected)', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setReserveStableRateBorrowing(weth.address, true)).to.be.revertedWith(types_1.ProtocolErrors.BORROWING_NOT_ENABLED);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowingEnabled: false,
            stableBorrowRateEnabled: false,
        });
    });
    it('Activates the ETH reserve for borrowing via pool admin', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, weth, helpersContract } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveBorrowing(weth.address, true))
            .to.emit(configurator, 'ReserveBorrowing')
            .withArgs(weth.address, true);
        const { variableBorrowIndex } = await helpersContract.getReserveData(weth.address);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            stableBorrowRateEnabled: false,
        });
        (0, chai_1.expect)(variableBorrowIndex.toString()).to.be.equal(constants_1.RAY);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Activates the ETH reserve for borrowing via risk admin', async () => {
        const { configurator, weth, helpersContract, riskAdmin } = testEnv;
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setReserveBorrowing(weth.address, true))
            .to.emit(configurator, 'ReserveBorrowing')
            .withArgs(weth.address, true);
        const { variableBorrowIndex } = await helpersContract.getReserveData(weth.address);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            stableBorrowRateEnabled: false,
        });
        (0, chai_1.expect)(variableBorrowIndex.toString()).to.be.equal(constants_1.RAY);
    });
    it('Enables stable borrow rate on the ETH reserve via pool admin', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, helpersContract, weth } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveStableRateBorrowing(weth.address, true))
            .to.emit(configurator, 'ReserveStableRateBorrowing')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
        });
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Enables stable borrow rate on the ETH reserve via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setReserveStableRateBorrowing(weth.address, true))
            .to.emit(configurator, 'ReserveStableRateBorrowing')
            .withArgs(weth.address, true);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
        });
    });
    it('Deactivates the ETH reserve as collateral via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(weth.address, 0, 0, 0))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(weth.address, 0, 0, 0);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            baseLTVAsCollateral: '0',
            liquidationThreshold: '0',
            liquidationBonus: '0',
            usageAsCollateralEnabled: false,
        });
    });
    it('Activates the ETH reserve as collateral via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(weth.address, '8000', '8250', '10500'))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(weth.address, '8000', '8250', '10500');
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            baseLTVAsCollateral: '8000',
            liquidationThreshold: '8250',
            liquidationBonus: '10500',
        });
    });
    it('Deactivates the ETH reserve as collateral via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        (0, chai_1.expect)(await configurator
            .connect(riskAdmin.signer)
            .configureReserveAsCollateral(weth.address, 0, 0, 0))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(weth.address, 0, 0, 0);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            baseLTVAsCollateral: '0',
            liquidationThreshold: '0',
            liquidationBonus: '0',
            usageAsCollateralEnabled: false,
        });
    });
    it('Activates the ETH reserve as collateral via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        (0, chai_1.expect)(await configurator
            .connect(riskAdmin.signer)
            .configureReserveAsCollateral(weth.address, '8000', '8250', '10500'))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(weth.address, '8000', '8250', '10500');
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            baseLTVAsCollateral: '8000',
            liquidationThreshold: '8250',
            liquidationBonus: '10500',
        });
    });
    it('Changes the reserve factor of WETH via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const { reserveFactor: oldReserveFactor } = await helpersContract.getReserveConfigurationData(weth.address);
        const newReserveFactor = '1000';
        (0, chai_1.expect)(await configurator.setReserveFactor(weth.address, newReserveFactor))
            .to.emit(configurator, 'ReserveFactorChanged')
            .withArgs(weth.address, oldReserveFactor, newReserveFactor);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            reserveFactor: newReserveFactor,
        });
    });
    it('Changes the reserve factor of WETH via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const { reserveFactor: oldReserveFactor } = await helpersContract.getReserveConfigurationData(weth.address);
        const newReserveFactor = '1000';
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setReserveFactor(weth.address, newReserveFactor))
            .to.emit(configurator, 'ReserveFactorChanged')
            .withArgs(weth.address, oldReserveFactor, newReserveFactor);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            reserveFactor: newReserveFactor,
        });
    });
    it('Updates the reserve factor of WETH equal to PERCENTAGE_FACTOR', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, helpersContract, weth, poolAdmin } = testEnv;
        const { reserveFactor: oldReserveFactor } = await helpersContract.getReserveConfigurationData(weth.address);
        const newReserveFactor = '10000';
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setReserveFactor(weth.address, newReserveFactor))
            .to.emit(configurator, 'ReserveFactorChanged')
            .withArgs(weth.address, oldReserveFactor, newReserveFactor);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            reserveFactor: newReserveFactor,
        });
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Updates the unbackedMintCap of WETH via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const oldWethUnbackedMintCap = await helpersContract.getUnbackedMintCap(weth.address);
        const newUnbackedMintCap = '10000';
        (0, chai_1.expect)(await configurator.setUnbackedMintCap(weth.address, newUnbackedMintCap))
            .to.emit(configurator, 'UnbackedMintCapChanged')
            .withArgs(weth.address, oldWethUnbackedMintCap, newUnbackedMintCap);
        (0, chai_1.expect)(await helpersContract.getUnbackedMintCap(weth.address)).to.be.eq(newUnbackedMintCap);
    });
    it('Updates the unbackedMintCap of WETH via risk admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const oldWethUnbackedMintCap = await helpersContract.getUnbackedMintCap(weth.address);
        const newUnbackedMintCap = '20000';
        (0, chai_1.expect)(await configurator.setUnbackedMintCap(weth.address, newUnbackedMintCap))
            .to.emit(configurator, 'UnbackedMintCapChanged')
            .withArgs(weth.address, oldWethUnbackedMintCap, newUnbackedMintCap);
        (0, chai_1.expect)(await helpersContract.getUnbackedMintCap(weth.address)).to.be.eq(newUnbackedMintCap);
    });
    it('Updates the borrowCap of WETH via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const { borrowCap: wethOldBorrowCap } = await helpersContract.getReserveCaps(weth.address);
        const newBorrowCap = '3000000';
        (0, chai_1.expect)(await configurator.setBorrowCap(weth.address, newBorrowCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(weth.address, wethOldBorrowCap, newBorrowCap);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowCap: newBorrowCap,
        });
    });
    it('Updates the borrowCap of WETH risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const { borrowCap: wethOldBorrowCap } = await helpersContract.getReserveCaps(weth.address);
        const newBorrowCap = '3000000';
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setBorrowCap(weth.address, newBorrowCap))
            .to.emit(configurator, 'BorrowCapChanged')
            .withArgs(weth.address, wethOldBorrowCap, newBorrowCap);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowCap: newBorrowCap,
        });
    });
    it('Updates the supplyCap of WETH via pool admin', async () => {
        const { configurator, helpersContract, weth } = testEnv;
        const { supplyCap: oldWethSupplyCap } = await helpersContract.getReserveCaps(weth.address);
        const newBorrowCap = '3000000';
        const newSupplyCap = '3000000';
        (0, chai_1.expect)(await configurator.setSupplyCap(weth.address, newSupplyCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(weth.address, oldWethSupplyCap, newSupplyCap);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowCap: newBorrowCap,
            supplyCap: newSupplyCap,
        });
    });
    it('Updates the supplyCap of WETH via risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const { supplyCap: oldWethSupplyCap } = await helpersContract.getReserveCaps(weth.address);
        const newBorrowCap = '3000000';
        const newSupplyCap = '3000000';
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setSupplyCap(weth.address, newSupplyCap))
            .to.emit(configurator, 'SupplyCapChanged')
            .withArgs(weth.address, oldWethSupplyCap, newSupplyCap);
        await expectReserveConfigurationData(helpersContract, weth.address, {
            ...baseConfigValues,
            borrowCap: newBorrowCap,
            supplyCap: newSupplyCap,
        });
    });
    it('Updates the ReserveInterestRateStrategy address of WETH via pool admin', async () => {
        const { poolAdmin, pool, configurator, weth } = testEnv;
        const { interestRateStrategyAddress: interestRateStrategyAddressBefore } = await pool.getReserveData(weth.address);
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setReserveInterestRateStrategyAddress(weth.address, constants_1.ZERO_ADDRESS))
            .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
            .withArgs(weth.address, interestRateStrategyAddressBefore, constants_1.ZERO_ADDRESS);
        const { interestRateStrategyAddress: interestRateStrategyAddressAfter } = await pool.getReserveData(weth.address);
        (0, chai_1.expect)(interestRateStrategyAddressBefore).to.not.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(interestRateStrategyAddressAfter).to.be.eq(constants_1.ZERO_ADDRESS);
        //reset interest rate strategy to the correct one
        await configurator
            .connect(poolAdmin.signer)
            .setReserveInterestRateStrategyAddress(weth.address, interestRateStrategyAddressBefore);
    });
    it('Updates the ReserveInterestRateStrategy address of WETH via risk admin', async () => {
        const { riskAdmin, pool, configurator, weth } = testEnv;
        const { interestRateStrategyAddress: interestRateStrategyAddressBefore } = await pool.getReserveData(weth.address);
        (0, chai_1.expect)(await configurator
            .connect(riskAdmin.signer)
            .setReserveInterestRateStrategyAddress(weth.address, constants_1.ONE_ADDRESS))
            .to.emit(configurator, 'ReserveInterestRateStrategyChanged')
            .withArgs(weth.address, interestRateStrategyAddressBefore, constants_1.ONE_ADDRESS);
        const { interestRateStrategyAddress: interestRateStrategyAddressAfter } = await pool.getReserveData(weth.address);
        (0, chai_1.expect)(interestRateStrategyAddressBefore).to.not.be.eq(constants_1.ONE_ADDRESS);
        (0, chai_1.expect)(interestRateStrategyAddressAfter).to.be.eq(constants_1.ONE_ADDRESS);
        //reset interest rate strategy to the correct one
        await configurator
            .connect(riskAdmin.signer)
            .setReserveInterestRateStrategyAddress(weth.address, interestRateStrategyAddressBefore);
    });
    it('Register a new risk Admin', async () => {
        const { aclManager, poolAdmin, users, riskAdmin } = testEnv;
        const riskAdminRole = await aclManager.RISK_ADMIN_ROLE();
        const newRiskAdmin = users[3].address;
        (0, chai_1.expect)(await aclManager.addRiskAdmin(newRiskAdmin))
            .to.emit(aclManager, 'RoleGranted')
            .withArgs(riskAdminRole, newRiskAdmin, poolAdmin.address);
        (0, chai_1.expect)(await aclManager.isRiskAdmin(riskAdmin.address)).to.be.true;
        (0, chai_1.expect)(await aclManager.isRiskAdmin(newRiskAdmin)).to.be.true;
    });
    it('Unregister the new risk admin', async () => {
        const { aclManager, poolAdmin, users, riskAdmin } = testEnv;
        const riskAdminRole = await aclManager.RISK_ADMIN_ROLE();
        const newRiskAdmin = users[3].address;
        (0, chai_1.expect)(await aclManager.removeRiskAdmin(newRiskAdmin))
            .to.emit(aclManager, 'RoleRevoked')
            .withArgs(riskAdminRole, newRiskAdmin, poolAdmin.address);
        (0, chai_1.expect)(await aclManager.isRiskAdmin(riskAdmin.address)).to.be.true;
        (0, chai_1.expect)(await aclManager.isRiskAdmin(newRiskAdmin)).to.be.false;
    });
    it('Authorized a new flash borrower', async () => {
        const { aclManager, poolAdmin, users } = testEnv;
        const authorizedFlashBorrowerRole = await aclManager.FLASH_BORROWER_ROLE();
        const authorizedFlashBorrower = users[4].address;
        (0, chai_1.expect)(await aclManager.addFlashBorrower(authorizedFlashBorrower))
            .to.emit(aclManager, 'RoleGranted')
            .withArgs(authorizedFlashBorrowerRole, authorizedFlashBorrower, poolAdmin.address);
        (0, chai_1.expect)(await aclManager.isFlashBorrower(authorizedFlashBorrower)).to.be.true;
    });
    it('Unauthorized flash borrower', async () => {
        const { aclManager, poolAdmin, users } = testEnv;
        const authorizedFlashBorrowerRole = await aclManager.FLASH_BORROWER_ROLE();
        const authorizedFlashBorrower = users[4].address;
        (0, chai_1.expect)(await aclManager.removeFlashBorrower(authorizedFlashBorrower))
            .to.emit(aclManager, 'RoleRevoked')
            .withArgs(authorizedFlashBorrowerRole, authorizedFlashBorrower, poolAdmin.address);
        (0, chai_1.expect)(await aclManager.isFlashBorrower(authorizedFlashBorrower)).to.be.false;
    });
    it('Updates bridge protocol fee equal to PERCENTAGE_FACTOR', async () => {
        const { pool, configurator } = testEnv;
        const newProtocolFee = 10000;
        const oldBridgeProtocolFee = await pool.BRIDGE_PROTOCOL_FEE();
        (0, chai_1.expect)(await configurator.updateBridgeProtocolFee(newProtocolFee))
            .to.emit(configurator, 'BridgeProtocolFeeUpdated')
            .withArgs(oldBridgeProtocolFee, newProtocolFee);
        (0, chai_1.expect)(await pool.BRIDGE_PROTOCOL_FEE()).to.be.eq(newProtocolFee);
    });
    it('Updates bridge protocol fee', async () => {
        const { pool, configurator } = testEnv;
        const oldBridgeProtocolFee = await pool.BRIDGE_PROTOCOL_FEE();
        const newProtocolFee = 2000;
        (0, chai_1.expect)(await configurator.updateBridgeProtocolFee(newProtocolFee))
            .to.emit(configurator, 'BridgeProtocolFeeUpdated')
            .withArgs(oldBridgeProtocolFee, newProtocolFee);
        (0, chai_1.expect)(await pool.BRIDGE_PROTOCOL_FEE()).to.be.eq(newProtocolFee);
    });
    it('Updates flash loan premiums equal to PERCENTAGE_FACTOR: 10000 toProtocol, 10000 total', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { pool, configurator } = testEnv;
        const oldFlashloanPremiumTotal = await pool.FLASHLOAN_PREMIUM_TOTAL();
        const oldFlashloanPremiumToProtocol = await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL();
        const newPremiumTotal = 10000;
        const newPremiumToProtocol = 10000;
        (0, chai_1.expect)(await configurator.updateFlashloanPremiumTotal(newPremiumTotal))
            .to.emit(configurator, 'FlashloanPremiumTotalUpdated')
            .withArgs(oldFlashloanPremiumTotal, newPremiumTotal);
        (0, chai_1.expect)(await configurator.updateFlashloanPremiumToProtocol(newPremiumToProtocol))
            .to.emit(configurator, 'FlashloanPremiumToProtocolUpdated')
            .withArgs(oldFlashloanPremiumToProtocol, newPremiumToProtocol);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TOTAL()).to.be.eq(newPremiumTotal);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL()).to.be.eq(newPremiumToProtocol);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Updates flash loan premiums: 10 toProtocol, 40 total', async () => {
        const { pool, configurator } = testEnv;
        const oldFlashloanPremiumTotal = await pool.FLASHLOAN_PREMIUM_TOTAL();
        const oldFlashloanPremiumToProtocol = await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL();
        const newPremiumTotal = 40;
        const newPremiumToProtocol = 10;
        (0, chai_1.expect)(await configurator.updateFlashloanPremiumTotal(newPremiumTotal))
            .to.emit(configurator, 'FlashloanPremiumTotalUpdated')
            .withArgs(oldFlashloanPremiumTotal, newPremiumTotal);
        (0, chai_1.expect)(await configurator.updateFlashloanPremiumToProtocol(newPremiumToProtocol))
            .to.emit(configurator, 'FlashloanPremiumToProtocolUpdated')
            .withArgs(oldFlashloanPremiumToProtocol, newPremiumToProtocol);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TOTAL()).to.be.eq(newPremiumTotal);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL()).to.be.eq(newPremiumToProtocol);
    });
    it('Adds a new eMode category for stablecoins', async () => {
        const { configurator, pool, poolAdmin } = testEnv;
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory('1', '9800', '9800', '10100', constants_1.ONE_ADDRESS, 'STABLECOINS'))
            .to.emit(configurator, 'EModeCategoryAdded')
            .withArgs(1, 9800, 9800, 10100, constants_1.ONE_ADDRESS, 'STABLECOINS');
        const categoryData = await pool.getEModeCategoryData(1);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(9800, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(9800, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(10100, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(constants_1.ONE_ADDRESS, 'invalid eMode category price source');
    });
    it('Set a eMode category to an asset', async () => {
        const { configurator, pool, helpersContract, poolAdmin, dai } = testEnv;
        const oldCategoryId = await helpersContract.getReserveEModeCategory(dai.address);
        const newCategoryId = 1;
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, '1'))
            .to.emit(configurator, 'EModeAssetCategoryChanged')
            .withArgs(dai.address, oldCategoryId, newCategoryId);
        const categoryData = await pool.getEModeCategoryData(newCategoryId);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(9800, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(9800, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(10100, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(constants_1.ONE_ADDRESS, 'invalid eMode category price source');
    });
    it('Sets siloed borrowing through the pool admin', async () => {
        const { configurator, helpersContract, weth, poolAdmin } = testEnv;
        const oldSiloedBorrowing = await helpersContract.getSiloedBorrowing(weth.address);
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setSiloedBorrowing(weth.address, true))
            .to.emit(configurator, 'SiloedBorrowingChanged')
            .withArgs(weth.address, oldSiloedBorrowing, true);
        const newSiloedBorrowing = await helpersContract.getSiloedBorrowing(weth.address);
        (0, chai_1.expect)(newSiloedBorrowing).to.be.eq(true, 'Invalid siloed borrowing state');
    });
    it('Sets siloed borrowing through the risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const oldSiloedBorrowing = await helpersContract.getSiloedBorrowing(weth.address);
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setSiloedBorrowing(weth.address, false))
            .to.emit(configurator, 'SiloedBorrowingChanged')
            .withArgs(weth.address, oldSiloedBorrowing, false);
        const newSiloedBorrowing = await helpersContract.getSiloedBorrowing(weth.address);
        (0, chai_1.expect)(newSiloedBorrowing).to.be.eq(false, 'Invalid siloed borrowing state');
    });
    it('Resets the siloed borrowing mode. Tries to set siloed borrowing after the asset has been borrowed (revert expected)', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { configurator, weth, dai, riskAdmin, pool, users: [user1, user2], faucetMintable } = testEnv;
        await configurator.connect(riskAdmin.signer).setSiloedBorrowing(weth.address, false);
        const wethAmount = ethers_1.utils.parseEther('1');
        const daiAmount = ethers_1.utils.parseEther('1000');
        // user 1 supplies WETH
        await faucetMintable.mint(weth.address, user1.address, wethAmount);
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user1.signer).supply(weth.address, wethAmount, user1.address, '0');
        // user 2 supplies DAI, borrows WETH
        await faucetMintable.mint(dai.address, user2.address, daiAmount);
        await dai.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user2.signer).supply(dai.address, daiAmount, user2.address, '0');
        await pool.connect(user2.signer).borrow(weth.address, '100', 2, '0', user2.address);
        await (0, chai_1.expect)(configurator.setSiloedBorrowing(weth.address, true)).to.be.revertedWith(RESERVE_DEBT_NOT_ZERO);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Sets a debt ceiling through the pool admin', async () => {
        const { configurator, helpersContract, weth, poolAdmin } = testEnv;
        const oldDebtCeiling = await helpersContract.getDebtCeiling(weth.address);
        const newDebtCeiling = '1';
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setDebtCeiling(weth.address, newDebtCeiling))
            .to.emit(configurator, 'DebtCeilingChanged')
            .withArgs(weth.address, oldDebtCeiling, newDebtCeiling);
        const newCeiling = await helpersContract.getDebtCeiling(weth.address);
        (0, chai_1.expect)(newCeiling).to.be.eq(newDebtCeiling, 'Invalid debt ceiling');
    });
    it('Sets a debt ceiling through the risk admin', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const oldDebtCeiling = await helpersContract.getDebtCeiling(weth.address);
        const newDebtCeiling = '10';
        (0, chai_1.expect)(await configurator.connect(riskAdmin.signer).setDebtCeiling(weth.address, newDebtCeiling))
            .to.emit(configurator, 'DebtCeilingChanged')
            .withArgs(weth.address, oldDebtCeiling, newDebtCeiling);
        const newCeiling = await helpersContract.getDebtCeiling(weth.address);
        (0, chai_1.expect)(newCeiling).to.be.eq(newDebtCeiling, 'Invalid debt ceiling');
    });
    it('Sets a debt ceiling larger than max (revert expected)', async () => {
        const { configurator, helpersContract, weth, riskAdmin } = testEnv;
        const MAX_VALID_DEBT_CEILING = ethers_1.BigNumber.from('1099511627775');
        const debtCeiling = MAX_VALID_DEBT_CEILING.add(1);
        const currentCeiling = await helpersContract.getDebtCeiling(weth.address);
        await (0, chai_1.expect)(configurator.connect(riskAdmin.signer).setDebtCeiling(weth.address, debtCeiling)).to.be.revertedWith(INVALID_DEBT_CEILING);
        const newCeiling = await helpersContract.getDebtCeiling(weth.address);
        (0, chai_1.expect)(newCeiling).to.be.eq(currentCeiling, 'Invalid debt ceiling');
    });
    it('Resets the WETH debt ceiling. Tries to set debt ceiling after liquidity has been provided (revert expected)', async () => {
        const { configurator, weth, riskAdmin, pool, users: [user1], faucetMintable } = testEnv;
        await configurator.connect(riskAdmin.signer).setDebtCeiling(weth.address, '0');
        // user 1 deposits
        await faucetMintable.mint(weth.address, user1.address, '100');
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user1.signer).supply(weth.address, '100', user1.address, '0');
        await (0, chai_1.expect)(configurator.setDebtCeiling(weth.address, '100')).to.be.revertedWith(RESERVE_LIQUIDITY_NOT_ZERO);
    });
    it('Withdraws supplied liquidity, sets WETH debt ceiling', async () => {
        const { configurator, helpersContract, weth, riskAdmin, pool, users: [user1], } = testEnv;
        await pool.connect(user1.signer).withdraw(weth.address, constants_1.MAX_UINT_AMOUNT, user1.address);
        await configurator.connect(riskAdmin.signer).setDebtCeiling(weth.address, '100');
        const newCeiling = await helpersContract.getDebtCeiling(weth.address);
        (0, chai_1.expect)(newCeiling).to.be.eq('100');
    });
    it('Readds liquidity, increases WETH debt ceiling', async () => {
        const { configurator, helpersContract, weth, riskAdmin, pool, users: [user1], } = testEnv;
        await pool.connect(user1.signer).supply(weth.address, '100', user1.address, '0');
        await configurator.connect(riskAdmin.signer).setDebtCeiling(weth.address, '200');
        const newCeiling = await helpersContract.getDebtCeiling(weth.address);
        (0, chai_1.expect)(newCeiling).to.be.eq('200');
    });
    it('Read debt ceiling decimals', async () => {
        const { helpersContract } = testEnv;
        (0, chai_1.expect)(await helpersContract.getDebtCeilingDecimals()).to.be.eq(2);
    });
    it('Check that the reserves have flashloans enabled', async () => {
        const { weth, aave, usdc, dai, helpersContract } = testEnv;
        const wethFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(weth.address);
        (0, chai_1.expect)(wethFlashLoanEnabled).to.be.equal(true);
        const aaveFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(aave.address);
        (0, chai_1.expect)(aaveFlashLoanEnabled).to.be.equal(true);
        const usdcFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(usdc.address);
        (0, chai_1.expect)(usdcFlashLoanEnabled).to.be.equal(true);
        const daiFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(dai.address);
        (0, chai_1.expect)(daiFlashLoanEnabled).to.be.equal(true);
    });
    it('Disable weth flashloans', async () => {
        const { weth, configurator, helpersContract } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveFlashLoaning(weth.address, false));
        const wethFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(weth.address);
        (0, chai_1.expect)(wethFlashLoanEnabled).to.be.equal(false);
    });
});
