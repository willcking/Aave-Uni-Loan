"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const misc_utils_1 = require("../helpers/misc-utils");
const make_suite_1 = require("./helpers/make-suite");
const wallets_1 = require("./helpers/utils/wallets");
const types_1 = require("../helpers/types");
(0, make_suite_1.makeSuite)('DebtToken: Permit Delegation', (testEnv) => {
    let snapId;
    beforeEach(async () => {
        snapId = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    let daiMintedAmount;
    let wethMintedAmount;
    let testWallets;
    const MINT_AMOUNT = '1000';
    const EIP712_REVISION = '1';
    before(async () => {
        const { pool, weth, dai, deployer: user1, users: [user2], faucetMintable, } = testEnv;
        testWallets = (0, wallets_1.getTestWallets)();
        // Setup the pool
        daiMintedAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, MINT_AMOUNT);
        wethMintedAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, MINT_AMOUNT);
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, user1.address, daiMintedAmount));
        (0, chai_1.expect)(await dai.approve(pool.address, daiMintedAmount));
        (0, chai_1.expect)(await pool.deposit(dai.address, daiMintedAmount, user1.address, 0));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, user2.address, wethMintedAmount));
        (0, chai_1.expect)(await weth.connect(user2.signer).approve(pool.address, wethMintedAmount));
        (0, chai_1.expect)(await pool.connect(user2.signer).deposit(weth.address, wethMintedAmount, user2.address, 0));
    });
    it('Checks the domain separator', async () => {
        const { variableDebtDai, stableDebtDai } = testEnv;
        const variableSeparator = await variableDebtDai.DOMAIN_SEPARATOR();
        const stableSeparator = await stableDebtDai.DOMAIN_SEPARATOR();
        const variableDomain = {
            name: await variableDebtDai.name(),
            version: EIP712_REVISION,
            chainId: hre.network.config.chainId,
            verifyingContract: variableDebtDai.address,
        };
        const stableDomain = {
            name: await stableDebtDai.name(),
            version: EIP712_REVISION,
            chainId: hre.network.config.chainId,
            verifyingContract: stableDebtDai.address,
        };
        const variableDomainSeparator = ethers_1.utils._TypedDataEncoder.hashDomain(variableDomain);
        const stableDomainSeparator = ethers_1.utils._TypedDataEncoder.hashDomain(stableDomain);
        (0, chai_1.expect)(variableSeparator).to.be.equal(variableDomainSeparator, 'Invalid variable domain separator');
        (0, chai_1.expect)(stableSeparator).to.be.equal(stableDomainSeparator, 'Invalid stable domain separator');
    });
    it('User 3 borrows variable interest dai on behalf of user 2 via permit', async () => {
        const { pool, variableDebtDai, dai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await variableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, variableDebtDai.address, EIP712_REVISION, await variableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        (0, chai_1.expect)(await variableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user2.address, user3.address, permitAmount, expiration, v, r, s));
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal(permitAmount);
        await pool.connect(user3.signer).borrow(dai.address, permitAmount, 2, 0, user2.address);
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('User 3 borrows stable interest dai on behalf of user 2 via permit', async () => {
        const { pool, stableDebtDai, dai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await stableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, stableDebtDai.address, EIP712_REVISION, await stableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        (0, chai_1.expect)(await stableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user2.address, user3.address, permitAmount, expiration, v, r, s));
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal(permitAmount);
        await pool
            .connect(user3.signer)
            .borrow(dai.address, daiMintedAmount.div(10), 1, 0, user2.address);
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal(permitAmount.sub(daiMintedAmount.div(10)));
    });
    it('Stable debt delegation with delegator == address(0)', async () => {
        const { stableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await stableDebtDai.nonces(user2.address)).toNumber();
        const EIP712_REVISION = await stableDebtDai.EIP712_REVISION();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, stableDebtDai.address, EIP712_REVISION, await stableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(stableDebtDai
            .connect(user1.signer)
            .delegationWithSig(constants_1.ZERO_ADDRESS, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.ZERO_ADDRESS_NOT_VALID);
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('Stable debt delegation with block.timestamp > deadline', async () => {
        const { stableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = (await (0, misc_utils_1.timeLatest)()).sub(500).toString();
        const nonce = (await stableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, stableDebtDai.address, EIP712_REVISION, await stableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(stableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user2.address, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_EXPIRATION);
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('Stable debt delegation with wrong delegator', async () => {
        const { stableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await stableDebtDai.nonces(user2.address)).toNumber();
        const EIP712_REVISION = await stableDebtDai.EIP712_REVISION();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, stableDebtDai.address, EIP712_REVISION, await stableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(stableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user1.address, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_SIGNATURE);
        (0, chai_1.expect)((await stableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('Variable debt delegation with delegator == address(0)', async () => {
        const { variableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await variableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, variableDebtDai.address, EIP712_REVISION, await variableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(variableDebtDai
            .connect(user1.signer)
            .delegationWithSig(constants_1.ZERO_ADDRESS, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.ZERO_ADDRESS_NOT_VALID);
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('Variable debt delegation with block.timestamp > deadline', async () => {
        const { variableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = (await (0, misc_utils_1.timeLatest)()).sub(500).toString();
        const nonce = (await variableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, variableDebtDai.address, EIP712_REVISION, await variableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(variableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user2.address, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_EXPIRATION);
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
    it('Variable debt delegation with wrong delegator', async () => {
        const { variableDebtDai, deployer: user1, users: [user2, user3], } = testEnv;
        const chainId = hre.network.config.chainId || constants_1.HARDHAT_CHAINID;
        const expiration = constants_1.MAX_UINT_AMOUNT;
        const nonce = (await variableDebtDai.nonces(user2.address)).toNumber();
        const permitAmount = daiMintedAmount.div(3);
        const msgParams = (0, contracts_helpers_1.buildDelegationWithSigParams)(chainId, variableDebtDai.address, EIP712_REVISION, await variableDebtDai.name(), user3.address, nonce, expiration, permitAmount.toString());
        const user2PrivateKey = testWallets[1].secretKey;
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
        const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(user2PrivateKey, msgParams);
        await (0, chai_1.expect)(variableDebtDai
            .connect(user1.signer)
            .delegationWithSig(user1.address, user3.address, permitAmount, expiration, v, r, s)).to.be.revertedWith(types_1.ProtocolErrors.INVALID_SIGNATURE);
        (0, chai_1.expect)((await variableDebtDai.borrowAllowance(user2.address, user3.address)).toString()).to.be.equal('0');
    });
});
