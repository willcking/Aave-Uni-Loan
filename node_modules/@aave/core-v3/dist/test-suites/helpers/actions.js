"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractsData = exports.getTxCostAndTimestamp = exports.rebalanceStableBorrowRate = exports.swapBorrowRateMode = exports.setUseAsCollateral = exports.repayWithPermit = exports.supplyWithPermit = exports.repay = exports.borrow = exports.delegateBorrowAllowance = exports.withdraw = exports.deposit = exports.approve = exports.mint = exports.configuration = void 0;
const calculations_1 = require("./utils/calculations");
const helpers_1 = require("./utils/helpers");
const contracts_helpers_1 = require("../../helpers/contracts-helpers");
const contracts_helpers_2 = require("../../helpers/contracts-helpers");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const constants_1 = require("../../helpers/constants");
const chai_1 = __importDefault(require("chai"));
const types_1 = require("../../types");
const deploy_v3_1 = require("@aave/deploy-v3");
const hardhat_1 = require("hardhat");
const misc_utils_1 = require("../../helpers/misc-utils");
const bignumber_1 = require("@ethersproject/bignumber");
const { expect } = chai_1.default;
const almostEqualOrEqual = function (expected, actual) {
    const keys = Object.keys(actual);
    keys.forEach((key) => {
        if (key === 'lastUpdateTimestamp' ||
            key === 'marketStableRate' ||
            key === 'symbol' ||
            key === 'aTokenAddress' ||
            key === 'decimals' ||
            key === 'totalStableDebtLastUpdated') {
            // skipping consistency check on accessory data
            return;
        }
        this.assert(actual[key] != undefined, `Property ${key} is undefined in the actual data`);
        expect(expected[key] != undefined, `Property ${key} is undefined in the expected data`);
        if (expected[key] == null || actual[key] == null) {
            console.log('Found a undefined value for Key ', key, ' value ', expected[key], actual[key]);
        }
        if (actual[key] instanceof bignumber_1.BigNumber) {
            const actualValue = actual[key];
            const expectedValue = expected[key];
            this.assert(actualValue.eq(expectedValue) ||
                actualValue.add(1).eq(expectedValue) ||
                actualValue.eq(expectedValue.add(1)) ||
                actualValue.add(2).eq(expectedValue) ||
                actualValue.eq(expectedValue.add(2)) ||
                actualValue.add(3).eq(expectedValue) ||
                actualValue.eq(expectedValue.add(3)), `expected #{act} to be almost equal or equal #{exp} for property ${key}`, `expected #{act} to be almost equal or equal #{exp} for property ${key}`, expectedValue.toString(), actualValue.toString());
        }
        else {
            this.assert(actual[key] !== null &&
                expected[key] !== null &&
                actual[key].toString() === expected[key].toString(), `expected #{act} to be equal #{exp} for property ${key}`, `expected #{act} to be equal #{exp} for property ${key}`, expected[key], actual[key]);
        }
    });
};
chai_1.default.use(function (chai, utils) {
    chai.Assertion.overwriteMethod('almostEqualOrEqual', function (original) {
        return function (expected) {
            const actual = expected
                ? this._obj
                : this._obj;
            almostEqualOrEqual.apply(this, [expected, actual]);
        };
    });
});
exports.configuration = {};
const mint = async (reserveSymbol, amount, user, testEnv) => {
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const token = await (0, contract_getters_1.getMintableERC20)(reserve);
    await (0, deploy_v3_1.waitForTx)(await testEnv.faucetMintable.mint(reserve, user.address, await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount)));
};
exports.mint = mint;
const approve = async (reserveSymbol, user, testEnv) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const token = await (0, contract_getters_1.getMintableERC20)(reserve);
    await (0, deploy_v3_1.waitForTx)(await token.connect(user.signer).approve(pool.address, '100000000000000000000000000000'));
};
exports.approve = approve;
const deposit = async (reserveSymbol, amount, sender, onBehalfOf, sendValue, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const amountToDeposit = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount);
    const txOptions = {};
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, sender.address);
    if (sendValue) {
        txOptions.value = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, sendValue);
    }
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(sender.signer)
            .deposit(reserve, amountToDeposit, onBehalfOf, '0', txOptions));
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, sender.address);
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterDeposit)(amountToDeposit.toString(), reserveDataBefore, txTimestamp);
        const expectedUserReserveData = (0, calculations_1.calcExpectedUserDataAfterDeposit)(amountToDeposit.toString(), reserveDataBefore, expectedReserveData, userDataBefore, txTimestamp, timestamp, txCost);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserReserveData);
        // truffleAssert.eventEmitted(txResult, "Deposit", (ev: any) => {
        //   const {_reserve, _user, _amount} = ev;
        //   return (
        //     _reserve === reserve &&
        //     _user === user &&
        //     new BigNumber(_amount).isEqualTo(new BigNumber(amountToDeposit))
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool.connect(sender.signer).deposit(reserve, amountToDeposit, onBehalfOf, '0', txOptions), revertMessage).to.be.reverted;
    }
};
exports.deposit = deposit;
const withdraw = async (reserveSymbol, amount, user, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const { aTokenInstance, reserve, userData: userDataBefore, reserveData: reserveDataBefore, } = await getDataBeforeAction(reserveSymbol, user.address, testEnv);
    let amountToWithdraw = '0';
    if (amount !== '-1') {
        amountToWithdraw = (await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount)).toString();
    }
    else {
        amountToWithdraw = constants_1.MAX_UINT_AMOUNT;
    }
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool.connect(user.signer).withdraw(reserve, amountToWithdraw, user.address));
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, user.address, testEnv);
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterWithdraw)(amountToWithdraw, reserveDataBefore, userDataBefore, txTimestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterWithdraw)(amountToWithdraw, reserveDataBefore, expectedReserveData, userDataBefore, txTimestamp, timestamp, txCost);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        // truffleAssert.eventEmitted(txResult, "Redeem", (ev: any) => {
        //   const {_from, _value} = ev;
        //   return (
        //     _from === user && new BigNumber(_value).isEqualTo(actualAmountRedeemed)
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool.connect(user.signer).withdraw(reserve, amountToWithdraw, user.address), revertMessage).to.be.reverted;
    }
};
exports.withdraw = withdraw;
const delegateBorrowAllowance = async (reserve, amount, interestRateMode, user, receiver, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserveAddress = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserve);
    const amountToDelegate = await (await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserveAddress, amount)).toString();
    const reserveData = await pool.getReserveData(reserveAddress);
    const debtToken = interestRateMode === '1'
        ? await (0, contract_getters_1.getStableDebtToken)(reserveData.stableDebtTokenAddress)
        : await (0, contract_getters_1.getVariableDebtToken)(reserveData.variableDebtTokenAddress);
    const delegateAllowancePromise = debtToken
        .connect(user.signer)
        .approveDelegation(receiver, amountToDelegate);
    if (expectedResult === 'revert' && revertMessage) {
        await expect(delegateAllowancePromise, revertMessage).to.be.revertedWith(revertMessage);
        return;
    }
    else {
        await (0, deploy_v3_1.waitForTx)(await delegateAllowancePromise);
        const allowance = await debtToken.borrowAllowance(user.address, receiver);
        expect(allowance.toString()).to.be.equal(amountToDelegate, 'borrowAllowance is set incorrectly');
    }
};
exports.delegateBorrowAllowance = delegateBorrowAllowance;
const borrow = async (reserveSymbol, amount, interestRateMode, user, onBehalfOf, timeTravel, expectedResult, testEnv, revertMessage) => {
    const { pool, helpersContract } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, user.address);
    const reserveTokens = await helpersContract.getReserveTokensAddresses(reserve);
    const debtToken = interestRateMode === '1'
        ? await (0, contract_getters_1.getStableDebtToken)(reserveTokens.stableDebtTokenAddress)
        : await (0, contract_getters_1.getVariableDebtToken)(reserveTokens.variableDebtTokenAddress);
    const borrowAllowanceBefore = await debtToken.borrowAllowance(onBehalfOf, user.address);
    const amountToBorrow = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount);
    const tx = pool
        .connect(user.signer)
        .borrow(reserve, amountToBorrow, interestRateMode, '0', onBehalfOf);
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await tx);
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        if (timeTravel) {
            const secondsToTravel = bignumber_1.BigNumber.from(timeTravel).mul(constants_1.ONE_YEAR).div(365).toNumber();
            await (0, deploy_v3_1.advanceTimeAndBlock)(secondsToTravel);
        }
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, user.address);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterBorrow)(amountToBorrow.toString(), interestRateMode, reserveDataBefore, userDataBefore, txTimestamp, timestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterBorrow)(amountToBorrow.toString(), interestRateMode, reserveDataBefore, expectedReserveData, userDataBefore, txTimestamp, timestamp);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        if (user.address !== onBehalfOf) {
            const borrowAllowanceAfter = await debtToken.borrowAllowance(onBehalfOf, user.address);
            expect(borrowAllowanceAfter).to.be.equal(borrowAllowanceBefore.sub(amountToBorrow), 'borrowAllowance is updated incorrectly');
        }
        // truffleAssert.eventEmitted(txResult, "Borrow", (ev: any) => {
        //   const {
        //     _reserve,
        //     _user,
        //     _amount,
        //     _borrowRateMode,
        //     _borrowRate,
        //     _originationFee,
        //   } = ev;
        //   return (
        //     _reserve.toLowerCase() === reserve.toLowerCase() &&
        //     _user.toLowerCase() === user.toLowerCase() &&
        //     new BigNumber(_amount).eq(amountToBorrow) &&
        //     new BigNumber(_borrowRateMode).eq(expectedUserData.borrowRateMode) &&
        //     new BigNumber(_borrowRate).eq(expectedUserData.borrowRate) &&
        //     new BigNumber(_originationFee).eq(
        //       expectedUserData.originationFee.minus(userDataBefore.originationFee)
        //     )
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(tx, revertMessage).to.be.reverted;
    }
};
exports.borrow = borrow;
const repay = async (reserveSymbol, amount, rateMode, user, onBehalfOf, sendValue, expectedResult, testEnv, timeTravel, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, onBehalfOf.address, testEnv);
    let amountToRepay = '0';
    if (amount !== '-1') {
        amountToRepay = (await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount)).toString();
    }
    else {
        amountToRepay = constants_1.MAX_UINT_AMOUNT;
    }
    amountToRepay = bignumber_1.BigNumber.from(amountToRepay).toHexString();
    const txOptions = {};
    if (sendValue) {
        const valueToSend = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, sendValue);
        txOptions.value = valueToSend.toHexString(); // '0x' + BigNumber.from(valueToSend.toString()).toString(16);
    }
    if (timeTravel) {
        const secondsToTravel = bignumber_1.BigNumber.from(timeTravel).mul(constants_1.ONE_YEAR).div(365).toNumber();
        await (0, deploy_v3_1.advanceTimeAndBlock)(secondsToTravel);
    }
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(user.signer)
            .repay(reserve, amountToRepay, rateMode, onBehalfOf.address, txOptions));
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, onBehalfOf.address, testEnv);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterRepay)(amountToRepay, rateMode, reserveDataBefore, userDataBefore, txTimestamp, timestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterRepay)(amountToRepay, rateMode, reserveDataBefore, expectedReserveData, userDataBefore, user.address, onBehalfOf.address, txTimestamp, timestamp);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        // truffleAssert.eventEmitted(txResult, "Repay", (ev: any) => {
        //   const {_reserve, _user, _repayer} = ev;
        //   return (
        //     _reserve.toLowerCase() === reserve.toLowerCase() &&
        //     _user.toLowerCase() === onBehalfOf.toLowerCase() &&
        //     _repayer.toLowerCase() === user.toLowerCase()
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool
            .connect(user.signer)
            .repay(reserve, amountToRepay, rateMode, onBehalfOf.address, txOptions), revertMessage).to.be.reverted;
    }
};
exports.repay = repay;
const supplyWithPermit = async (reserveSymbol, amount, sender, senderPk, onBehalfOf, useAsCollateral, sendValue, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const amountToDeposit = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount);
    const chainId = Number(await (0, hardhat_1.getChainId)());
    const token = new types_1.MintableERC20__factory(sender.signer).attach(reserve);
    const highDeadline = '100000000000000000000000000';
    const nonce = await token.nonces(sender.address);
    const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, reserve, '1', reserveSymbol, sender.address, pool.address, nonce.toNumber(), highDeadline, amountToDeposit.toString());
    const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(senderPk, msgParams);
    const txOptions = {};
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, sender.address);
    if (sendValue) {
        txOptions.value = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, sendValue);
    }
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(sender.signer)
            .supplyWithPermit(reserve, amountToDeposit, onBehalfOf, '0', highDeadline, v, r, s, txOptions));
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, onBehalfOf, testEnv, sender.address);
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterDeposit)(amountToDeposit.toString(), reserveDataBefore, txTimestamp);
        const expectedUserReserveData = (0, calculations_1.calcExpectedUserDataAfterDeposit)(amountToDeposit.toString(), reserveDataBefore, expectedReserveData, userDataBefore, txTimestamp, timestamp, txCost);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserReserveData);
        // truffleAssert.eventEmitted(txResult, "Deposit", (ev: any) => {
        //   const {_reserve, _user, _amount} = ev;
        //   return (
        //     _reserve === reserve &&
        //     _user === user &&
        //     new BigNumber(_amount).isEqualTo(new BigNumber(amountToDeposit))
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool
            .connect(sender.signer)
            .supplyWithPermit(reserve, amountToDeposit, onBehalfOf, '0', highDeadline, v, r, s, txOptions), revertMessage).to.be.reverted;
    }
};
exports.supplyWithPermit = supplyWithPermit;
const repayWithPermit = async (reserveSymbol, amount, rateMode, user, userPk, onBehalfOf, sendValue, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const highDeadline = '100000000000000000000000000';
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, onBehalfOf.address, testEnv);
    let amountToRepay = '0';
    if (amount !== '-1') {
        amountToRepay = (await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, amount)).toString();
    }
    else {
        amountToRepay = constants_1.MAX_UINT_AMOUNT;
    }
    amountToRepay = bignumber_1.BigNumber.from(amountToRepay).toHexString();
    const chainId = Number(await (0, hardhat_1.getChainId)());
    const token = new types_1.MintableERC20__factory(user.signer).attach(reserve);
    const nonce = await token.nonces(user.address);
    const msgParams = (0, contracts_helpers_1.buildPermitParams)(chainId, reserve, '1', reserveSymbol, user.address, pool.address, nonce.toNumber(), highDeadline, amountToRepay);
    const { v, r, s } = (0, contracts_helpers_1.getSignatureFromTypedData)(userPk, msgParams);
    const txOptions = {};
    if (sendValue) {
        const valueToSend = await (0, contracts_helpers_2.convertToCurrencyDecimals)(reserve, sendValue);
        txOptions.value = valueToSend.toHexString();
    }
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(user.signer)
            .repayWithPermit(reserve, amountToRepay, rateMode, onBehalfOf.address, highDeadline, v, r, s, txOptions));
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const { reserveData: reserveDataAfter, userData: userDataAfter, timestamp, } = await (0, exports.getContractsData)(reserve, onBehalfOf.address, testEnv);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterRepay)(amountToRepay, rateMode, reserveDataBefore, userDataBefore, txTimestamp, timestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterRepay)(amountToRepay, rateMode, reserveDataBefore, expectedReserveData, userDataBefore, user.address, onBehalfOf.address, txTimestamp, timestamp);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        // truffleAssert.eventEmitted(txResult, "Repay", (ev: any) => {
        //   const {_reserve, _user, _repayer} = ev;
        //   return (
        //     _reserve.toLowerCase() === reserve.toLowerCase() &&
        //     _user.toLowerCase() === onBehalfOf.toLowerCase() &&
        //     _repayer.toLowerCase() === user.toLowerCase()
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool
            .connect(user.signer)
            .repayWithPermit(reserve, amountToRepay, rateMode, onBehalfOf.address, highDeadline, v, r, s, txOptions), revertMessage).to.be.reverted;
    }
};
exports.repayWithPermit = repayWithPermit;
const setUseAsCollateral = async (reserveSymbol, user, useAsCollateral, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, user.address, testEnv);
    const useAsCollateralBool = useAsCollateral.toLowerCase() === 'true';
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool.connect(user.signer).setUserUseReserveAsCollateral(reserve, useAsCollateralBool));
        const { txCost } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const { userData: userDataAfter } = await (0, exports.getContractsData)(reserve, user.address, testEnv);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterSetUseAsCollateral)(useAsCollateral.toLocaleLowerCase() === 'true', reserveDataBefore, userDataBefore, txCost);
        expectEqual(userDataAfter, expectedUserData);
        // if (useAsCollateralBool) {
        //   truffleAssert.eventEmitted(txResult, 'ReserveUsedAsCollateralEnabled', (ev: any) => {
        //     const {_reserve, _user} = ev;
        //     return _reserve === reserve && _user === user;
        //   });
        // } else {
        //   truffleAssert.eventEmitted(txResult, 'ReserveUsedAsCollateralDisabled', (ev: any) => {
        //     const {_reserve, _user} = ev;
        //     return _reserve === reserve && _user === user;
        //   });
        // }
    }
    else if (expectedResult === 'revert') {
        await expect(pool.connect(user.signer).setUserUseReserveAsCollateral(reserve, useAsCollateralBool), revertMessage).to.be.reverted;
    }
};
exports.setUseAsCollateral = setUseAsCollateral;
const swapBorrowRateMode = async (reserveSymbol, user, rateMode, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, user.address, testEnv);
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool.connect(user.signer).swapBorrowRateMode(reserve, rateMode));
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const { reserveData: reserveDataAfter, userData: userDataAfter } = await (0, exports.getContractsData)(reserve, user.address, testEnv);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterSwapRateMode)(reserveDataBefore, userDataBefore, rateMode, txTimestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterSwapRateMode)(reserveDataBefore, expectedReserveData, userDataBefore, rateMode, txCost, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        // truffleAssert.eventEmitted(txResult, "Swap", (ev: any) => {
        //   const {_user, _reserve, _newRateMode, _newRate} = ev;
        //   return (
        //     _user === user &&
        //     _reserve == reserve &&
        //     new BigNumber(_newRateMode).eq(expectedUserData.borrowRateMode) &&
        //     new BigNumber(_newRate).eq(expectedUserData.borrowRate)
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool.connect(user.signer).swapBorrowRateMode(reserve, rateMode), revertMessage).to
            .be.reverted;
    }
};
exports.swapBorrowRateMode = swapBorrowRateMode;
const rebalanceStableBorrowRate = async (reserveSymbol, user, target, expectedResult, testEnv, revertMessage) => {
    const { pool } = testEnv;
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData: reserveDataBefore, userData: userDataBefore } = await (0, exports.getContractsData)(reserve, target.address, testEnv);
    if (expectedResult === 'success') {
        const txResult = await (0, deploy_v3_1.waitForTx)(await pool.connect(user.signer).rebalanceStableBorrowRate(reserve, target.address));
        const { txCost, txTimestamp } = await (0, exports.getTxCostAndTimestamp)(txResult);
        const { reserveData: reserveDataAfter, userData: userDataAfter } = await (0, exports.getContractsData)(reserve, target.address, testEnv);
        const expectedReserveData = (0, calculations_1.calcExpectedReserveDataAfterStableRateRebalance)(reserveDataBefore, userDataBefore, txTimestamp);
        const expectedUserData = (0, calculations_1.calcExpectedUserDataAfterStableRateRebalance)(reserveDataBefore, expectedReserveData, userDataBefore, txCost, txTimestamp);
        expectEqual(reserveDataAfter, expectedReserveData);
        expectEqual(userDataAfter, expectedUserData);
        // truffleAssert.eventEmitted(txResult, 'RebalanceStableBorrowRate', (ev: any) => {
        //   const {_user, _reserve, _newStableRate} = ev;
        //   return (
        //     _user.toLowerCase() === target.toLowerCase() &&
        //     _reserve.toLowerCase() === reserve.toLowerCase() &&
        //     new BigNumber(_newStableRate).eq(expectedUserData.borrowRate)
        //   );
        // });
    }
    else if (expectedResult === 'revert') {
        await expect(pool.connect(user.signer).rebalanceStableBorrowRate(reserve, target.address), revertMessage).to.be.reverted;
    }
};
exports.rebalanceStableBorrowRate = rebalanceStableBorrowRate;
const expectEqual = (actual, expected) => {
    if (!exports.configuration.skipIntegrityCheck) {
        // @ts-ignore
        expect(actual).to.be.almostEqualOrEqual(expected);
    }
};
const getDataBeforeAction = async (reserveSymbol, user, testEnv) => {
    const reserve = await (0, contract_getters_1.getTestnetReserveAddressFromSymbol)(reserveSymbol);
    const { reserveData, userData } = await (0, exports.getContractsData)(reserve, user, testEnv);
    const aTokenInstance = await (0, contract_getters_1.getAToken)(reserveData.aTokenAddress);
    return {
        reserve,
        reserveData,
        userData,
        aTokenInstance,
    };
};
const getTxCostAndTimestamp = async (tx) => {
    if (!tx.blockNumber || !tx.transactionHash || !tx.cumulativeGasUsed) {
        throw new Error('No tx blocknumber');
    }
    const txTimestamp = bignumber_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
    const txInfo = await hre.ethers.provider.getTransaction(tx.transactionHash);
    const gasPrice = txInfo.gasPrice ? txInfo.gasPrice : tx.effectiveGasPrice;
    const txCost = bignumber_1.BigNumber.from(tx.cumulativeGasUsed).mul(gasPrice);
    return { txCost, txTimestamp };
};
exports.getTxCostAndTimestamp = getTxCostAndTimestamp;
const getContractsData = async (reserve, user, testEnv, sender) => {
    const { pool, helpersContract } = testEnv;
    const [userData, reserveData, timestamp] = await Promise.all([
        (0, helpers_1.getUserData)(pool, helpersContract, reserve, user, sender || user),
        (0, helpers_1.getReserveData)(helpersContract, reserve),
        (0, misc_utils_1.timeLatest)(),
    ]);
    return {
        reserveData,
        userData,
        timestamp,
    };
};
exports.getContractsData = getContractsData;
