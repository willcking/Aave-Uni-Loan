"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeStory = void 0;
const actions_1 = require("./actions");
const types_1 = require("../../helpers/types");
const wallets_1 = require("./utils/wallets");
const executeStory = async (story, testEnv) => {
    for (const action of story.actions) {
        const { users } = testEnv;
        await executeAction(action, users, testEnv);
    }
};
exports.executeStory = executeStory;
const executeAction = async (action, users, testEnv) => {
    const { reserve, user: userIndex, borrowRateMode } = action.args;
    const { name, expected, revertMessage } = action;
    if (!name || name === '') {
        throw 'Action name is missing';
    }
    if (!reserve || reserve === '') {
        throw 'Invalid reserve selected for deposit';
    }
    if (!userIndex || userIndex === '') {
        throw `Invalid user selected to deposit into the ${reserve} reserve`;
    }
    if (!expected || expected === '') {
        throw `An expected result for action ${name} is required`;
    }
    let rateMode = types_1.RateMode.None;
    if (borrowRateMode) {
        if (borrowRateMode === 'none') {
            rateMode = types_1.RateMode.None;
        }
        else if (borrowRateMode === 'stable') {
            rateMode = types_1.RateMode.Stable;
        }
        else if (borrowRateMode === 'variable') {
            rateMode = types_1.RateMode.Variable;
        }
        else {
            //random value, to test improper selection of the parameter
            rateMode = '4';
        }
    }
    const user = users[parseInt(userIndex)];
    const userPrivateKey = (0, wallets_1.getTestWallets)()[parseInt(userIndex) + 1].secretKey;
    switch (name) {
        case 'mint':
            const { amount } = action.args;
            if (!amount || amount === '') {
                throw `Invalid amount of ${reserve} to mint`;
            }
            await (0, actions_1.mint)(reserve, amount, user, testEnv);
            break;
        case 'approve':
            await (0, actions_1.approve)(reserve, user, testEnv);
            break;
        case 'deposit':
            {
                const { amount, sendValue, onBehalfOf: onBehalfOfIndex } = action.args;
                const onBehalfOf = onBehalfOfIndex
                    ? users[parseInt(onBehalfOfIndex)].address
                    : user.address;
                if (!amount || amount === '') {
                    throw `Invalid amount to deposit into the ${reserve} reserve`;
                }
                await (0, actions_1.deposit)(reserve, amount, user, onBehalfOf, sendValue, expected, testEnv, revertMessage);
            }
            break;
        case 'supplyWithPermit':
            {
                const { amount, sendValue, onBehalfOf: onBehalfOfIndex, useAsCollateral } = action.args;
                const onBehalfOf = onBehalfOfIndex
                    ? users[parseInt(onBehalfOfIndex)].address
                    : user.address;
                if (!amount || amount === '') {
                    throw `Invalid amount to deposit into the ${reserve} reserve`;
                }
                await (0, actions_1.supplyWithPermit)(reserve, amount, user, userPrivateKey, onBehalfOf, useAsCollateral, sendValue, expected, testEnv, revertMessage);
            }
            break;
        case 'delegateBorrowAllowance':
            {
                const { amount, toUser: toUserIndex } = action.args;
                const toUser = users[parseInt(toUserIndex, 10)].address;
                if (!amount || amount === '') {
                    throw `Invalid amount to deposit into the ${reserve} reserve`;
                }
                await (0, actions_1.delegateBorrowAllowance)(reserve, amount, rateMode, user, toUser, expected, testEnv, revertMessage);
            }
            break;
        case 'withdraw':
            {
                const { amount } = action.args;
                if (!amount || amount === '') {
                    throw `Invalid amount to withdraw from the ${reserve} reserve`;
                }
                await (0, actions_1.withdraw)(reserve, amount, user, expected, testEnv, revertMessage);
            }
            break;
        case 'borrow':
            {
                const { amount, timeTravel, onBehalfOf: onBehalfOfIndex } = action.args;
                const onBehalfOf = onBehalfOfIndex
                    ? users[parseInt(onBehalfOfIndex)].address
                    : user.address;
                if (!amount || amount === '') {
                    throw `Invalid amount to borrow from the ${reserve} reserve`;
                }
                await (0, actions_1.borrow)(reserve, amount, rateMode, user, onBehalfOf, timeTravel, expected, testEnv, revertMessage);
            }
            break;
        case 'repay':
            {
                const { amount, timeTravel, sendValue } = action.args;
                let { onBehalfOf: onBehalfOfIndex } = action.args;
                if (!amount || amount === '') {
                    throw `Invalid amount to repay into the ${reserve} reserve`;
                }
                let userToRepayOnBehalf;
                if (!onBehalfOfIndex || onBehalfOfIndex === '') {
                    console.log('WARNING: No onBehalfOf specified for a repay action. Defaulting to the repayer address');
                    userToRepayOnBehalf = user;
                }
                else {
                    userToRepayOnBehalf = users[parseInt(onBehalfOfIndex)];
                }
                await (0, actions_1.repay)(reserve, amount, rateMode, user, userToRepayOnBehalf, sendValue, expected, testEnv, timeTravel, revertMessage);
            }
            break;
        case 'repayWithPermit':
            {
                const { amount, borrowRateMode, sendValue, deadline } = action.args;
                let { onBehalfOf: onBehalfOfIndex } = action.args;
                if (!amount || amount === '') {
                    throw `Invalid amount to repay into the ${reserve} reserve`;
                }
                let userToRepayOnBehalf;
                if (!onBehalfOfIndex || onBehalfOfIndex === '') {
                    console.log('WARNING: No onBehalfOf specified for a repay action. Defaulting to the repayer address');
                    userToRepayOnBehalf = user;
                }
                else {
                    userToRepayOnBehalf = users[parseInt(onBehalfOfIndex)];
                }
                await (0, actions_1.repayWithPermit)(reserve, amount, rateMode, user, userPrivateKey, userToRepayOnBehalf, sendValue, expected, testEnv, revertMessage);
            }
            break;
        case 'setUseAsCollateral':
            {
                const { useAsCollateral } = action.args;
                if (!useAsCollateral || useAsCollateral === '') {
                    throw `A valid value for useAsCollateral needs to be set when calling setUseReserveAsCollateral on reserve ${reserve}`;
                }
                await (0, actions_1.setUseAsCollateral)(reserve, user, useAsCollateral, expected, testEnv, revertMessage);
            }
            break;
        case 'swapBorrowRateMode':
            await (0, actions_1.swapBorrowRateMode)(reserve, user, rateMode, expected, testEnv, revertMessage);
            break;
        case 'rebalanceStableBorrowRate':
            {
                const { target: targetIndex } = action.args;
                if (!targetIndex || targetIndex === '') {
                    throw `A target must be selected when trying to rebalance a stable rate`;
                }
                const target = users[parseInt(targetIndex)];
                await (0, actions_1.rebalanceStableBorrowRate)(reserve, user, target, expected, testEnv, revertMessage);
            }
            break;
        default:
            throw `Invalid action requested: ${name}`;
    }
};
