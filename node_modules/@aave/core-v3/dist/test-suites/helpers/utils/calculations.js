"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcExpectedReserveNormalizedDebt = exports.calcExpectedReserveNormalizedIncome = exports.calcExpectedUsageRatios = exports.calcExpectedOverallBorrowRate = exports.calcExpectedInterestRates = exports.calcCompoundedInterest = exports.calcExpectedStableDebtTokenBalance = exports.calcExpectedVariableDebtTokenBalance = exports.calcExpectedATokenBalance = exports.calcExpectedUserDataAfterStableRateRebalance = exports.calcExpectedReserveDataAfterStableRateRebalance = exports.calcExpectedUserDataAfterSwapRateMode = exports.calcExpectedReserveDataAfterSwapRateMode = exports.calcExpectedUserDataAfterSetUseAsCollateral = exports.calcExpectedUserDataAfterRepay = exports.calcExpectedUserDataAfterBorrow = exports.calcExpectedReserveDataAfterRepay = exports.calcExpectedReserveDataAfterBorrow = exports.calcExpectedReserveDataAfterWithdraw = exports.calcExpectedReserveDataAfterBackUnbacked = exports.calcExpectedReserveDataAfterMintUnbacked = exports.calcExpectedReserveDataAfterDeposit = exports.calcExpectedUserDataAfterWithdraw = exports.calcExpectedUserDataAfterDeposit = exports.configuration = void 0;
const constants_1 = require("../../../helpers/constants");
const types_1 = require("../../../helpers/types");
const bignumber_1 = require("@ethersproject/bignumber");
require("./wadraymath");
const chai_1 = require("chai");
exports.configuration = {};
const calcExpectedUserDataAfterDeposit = (amountDeposited, reserveDataBeforeAction, reserveDataAfterAction, userDataBeforeAction, txTimestamp, currentTimestamp, txCost) => {
    const expectedUserData = {};
    expectedUserData.currentStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    expectedUserData.currentVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.principalStableDebt = userDataBeforeAction.principalStableDebt;
    expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt;
    expectedUserData.variableBorrowIndex = userDataBeforeAction.variableBorrowIndex;
    expectedUserData.stableBorrowRate = userDataBeforeAction.stableBorrowRate;
    expectedUserData.stableRateLastUpdated = userDataBeforeAction.stableRateLastUpdated;
    expectedUserData.liquidityRate = reserveDataAfterAction.liquidityRate;
    expectedUserData.scaledATokenBalance = calcExpectedScaledATokenBalance(userDataBeforeAction, reserveDataAfterAction.liquidityIndex, bignumber_1.BigNumber.from(amountDeposited), bignumber_1.BigNumber.from(0));
    expectedUserData.currentATokenBalance = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp).add(amountDeposited);
    if (userDataBeforeAction.currentATokenBalance.eq(0)) {
        expectedUserData.usageAsCollateralEnabled = true;
    }
    else {
        expectedUserData.usageAsCollateralEnabled = userDataBeforeAction.usageAsCollateralEnabled;
    }
    expectedUserData.variableBorrowIndex = userDataBeforeAction.variableBorrowIndex;
    expectedUserData.walletBalance = userDataBeforeAction.walletBalance.sub(amountDeposited);
    expectedUserData.currentStableDebt = expectedUserData.principalStableDebt =
        (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    expectedUserData.currentVariableDebt = expectedUserData.principalStableDebt =
        (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    return expectedUserData;
};
exports.calcExpectedUserDataAfterDeposit = calcExpectedUserDataAfterDeposit;
const calcExpectedUserDataAfterWithdraw = (amountWithdrawn, reserveDataBeforeAction, reserveDataAfterAction, userDataBeforeAction, txTimestamp, currentTimestamp, txCost) => {
    const expectedUserData = {};
    const aTokenBalance = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    if (amountWithdrawn == constants_1.MAX_UINT_AMOUNT) {
        amountWithdrawn = aTokenBalance.toString();
    }
    expectedUserData.scaledATokenBalance = calcExpectedScaledATokenBalance(userDataBeforeAction, reserveDataAfterAction.liquidityIndex, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(amountWithdrawn));
    expectedUserData.currentATokenBalance = aTokenBalance.sub(amountWithdrawn);
    expectedUserData.principalStableDebt = userDataBeforeAction.principalStableDebt;
    expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt;
    expectedUserData.currentStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    expectedUserData.currentVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.variableBorrowIndex = userDataBeforeAction.variableBorrowIndex;
    expectedUserData.stableBorrowRate = userDataBeforeAction.stableBorrowRate;
    expectedUserData.stableRateLastUpdated = userDataBeforeAction.stableRateLastUpdated;
    expectedUserData.liquidityRate = reserveDataAfterAction.liquidityRate;
    if (userDataBeforeAction.currentATokenBalance.eq(0)) {
        expectedUserData.usageAsCollateralEnabled = true;
    }
    else {
        //if the user is withdrawing everything, usageAsCollateralEnabled must be false
        if (expectedUserData.currentATokenBalance.eq(0)) {
            expectedUserData.usageAsCollateralEnabled = false;
        }
        else {
            expectedUserData.usageAsCollateralEnabled = userDataBeforeAction.usageAsCollateralEnabled;
        }
    }
    expectedUserData.walletBalance = userDataBeforeAction.walletBalance.add(amountWithdrawn);
    return expectedUserData;
};
exports.calcExpectedUserDataAfterWithdraw = calcExpectedUserDataAfterWithdraw;
const calcExpectedReserveDataAfterDeposit = (amountDeposited, reserveDataBeforeAction, txTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(amountDeposited), bignumber_1.BigNumber.from(0));
    expectedReserveData.averageStableBorrowRate = reserveDataBeforeAction.averageStableBorrowRate;
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterDeposit = calcExpectedReserveDataAfterDeposit;
const calcExpectedReserveDataAfterMintUnbacked = (amountMinted, reserveDataBeforeAction, txTimestamp) => {
    const expectedReserveData = {};
    const amountMintedBN = bignumber_1.BigNumber.from(amountMinted);
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked.add(amountMintedBN);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(0));
    expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebt, bignumber_1.BigNumber.from(0), reserveDataBeforeAction.stableBorrowRate);
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterMintUnbacked = calcExpectedReserveDataAfterMintUnbacked;
const calcExpectedReserveDataAfterBackUnbacked = (scaledATokenSupply, amount, fee, bridgeProtocolFee, reserveDataBeforeAction, txTimestamp) => {
    const cumulateToLiquidityIndex = (liquidityIndex, totalLiquidity, amount) => {
        const amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());
        return amountToLiquidityRatio.add(constants_1.RAY).rayMul(liquidityIndex);
    };
    const expectedReserveData = {};
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    const amountBN = bignumber_1.BigNumber.from(amount);
    const backingAmount = amountBN.lt(reserveDataBeforeAction.unbacked)
        ? amountBN
        : reserveDataBeforeAction.unbacked;
    const feeBN = bignumber_1.BigNumber.from(fee);
    const protocolFeePercentage = bignumber_1.BigNumber.from(bridgeProtocolFee);
    const premiumToProtocol = feeBN.percentMul(protocolFeePercentage);
    const premiumToLP = feeBN.sub(premiumToProtocol);
    const totalSupply = scaledATokenSupply.rayMul(expectedReserveData.liquidityIndex);
    // The fee is added directly to total liquidity, the backing will not change this liquidity.
    // We only update the liquidity index at the end, because it will otherwise influence computations midway
    expectedReserveData.liquidityIndex = cumulateToLiquidityIndex(expectedReserveData.liquidityIndex, totalSupply.add(expectedReserveData.accruedToTreasuryScaled.rayMul(expectedReserveData.liquidityIndex)), premiumToLP);
    expectedReserveData.accruedToTreasuryScaled = expectedReserveData.accruedToTreasuryScaled.add(premiumToProtocol.rayDiv(expectedReserveData.liquidityIndex));
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked.sub(backingAmount);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, backingAmount.add(feeBN), bignumber_1.BigNumber.from(0));
    expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebt, bignumber_1.BigNumber.from(0), reserveDataBeforeAction.stableBorrowRate);
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterBackUnbacked = calcExpectedReserveDataAfterBackUnbacked;
const calcExpectedReserveDataAfterWithdraw = (amountWithdrawn, reserveDataBeforeAction, userDataBeforeAction, txTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    if (amountWithdrawn == constants_1.MAX_UINT_AMOUNT) {
        amountWithdrawn = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp).toString();
    }
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(amountWithdrawn));
    expectedReserveData.averageStableBorrowRate = reserveDataBeforeAction.averageStableBorrowRate;
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterWithdraw = calcExpectedReserveDataAfterWithdraw;
const calcExpectedReserveDataAfterBorrow = (amountBorrowed, borrowRateMode, reserveDataBeforeAction, userDataBeforeAction, txTimestamp, currentTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    expectedReserveData.lastUpdateTimestamp = txTimestamp;
    const amountBorrowedBN = bignumber_1.BigNumber.from(amountBorrowed);
    // Update indexes
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(amountBorrowed));
    // Now we can perform the borrow THERE MUST BE SOMETHING IN HERE THAN CAN BE SIMPLIFIED
    if (borrowRateMode == types_1.RateMode.Stable) {
        const expectedStableDebtUntilTx = calcExpectedTotalStableDebt(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, txTimestamp);
        expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, expectedStableDebtUntilTx, amountBorrowedBN, reserveDataBeforeAction.stableBorrowRate);
        expectedReserveData.principalStableDebt = expectedStableDebtUntilTx.add(amountBorrowedBN);
        const ratesAfterTx = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.principalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
        expectedReserveData.liquidityRate = ratesAfterTx[0];
        expectedReserveData.stableBorrowRate = ratesAfterTx[1];
        expectedReserveData.variableBorrowRate = ratesAfterTx[2];
        expectedReserveData.totalStableDebt = calcExpectedTotalStableDebt(expectedReserveData.principalStableDebt, expectedReserveData.averageStableBorrowRate, txTimestamp, currentTimestamp);
        expectedReserveData.totalVariableDebt = reserveDataBeforeAction.scaledVariableDebt.rayMul((0, exports.calcExpectedReserveNormalizedDebt)(expectedReserveData.variableBorrowRate, expectedReserveData.variableBorrowIndex, txTimestamp, currentTimestamp));
        [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
            (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    }
    else {
        expectedReserveData.principalStableDebt = reserveDataBeforeAction.principalStableDebt;
        const totalStableDebtAfterTx = (0, exports.calcExpectedStableDebtTokenBalance)(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, txTimestamp);
        expectedReserveData.totalStableDebt = calcExpectedTotalStableDebt(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, currentTimestamp);
        expectedReserveData.averageStableBorrowRate = reserveDataBeforeAction.averageStableBorrowRate;
        expectedReserveData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt.add(amountBorrowedBN.rayDiv(expectedReserveData.variableBorrowIndex));
        const totalVariableDebtAfterTx = expectedReserveData.scaledVariableDebt.rayMul(expectedReserveData.variableBorrowIndex);
        [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
            (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
        const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, totalStableDebtAfterTx, totalVariableDebtAfterTx, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
        expectedReserveData.liquidityRate = rates[0];
        expectedReserveData.stableBorrowRate = rates[1];
        expectedReserveData.variableBorrowRate = rates[2];
        expectedReserveData.totalVariableDebt = expectedReserveData.scaledVariableDebt.rayMul((0, exports.calcExpectedReserveNormalizedDebt)(expectedReserveData.variableBorrowRate, expectedReserveData.variableBorrowIndex, txTimestamp, currentTimestamp));
        [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
            (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    }
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterBorrow = calcExpectedReserveDataAfterBorrow;
const calcExpectedReserveDataAfterRepay = (amountRepaid, borrowRateMode, reserveDataBeforeAction, userDataBeforeAction, txTimestamp, currentTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    // TODO: The repay amount here need to be capped to the balance.
    let amountRepaidBN = bignumber_1.BigNumber.from(amountRepaid);
    const userStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    const userVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    //if amount repaid == MAX_UINT_AMOUNT, user is repaying everything
    if (amountRepaidBN.abs().eq(constants_1.MAX_UINT_AMOUNT)) {
        if (borrowRateMode == types_1.RateMode.Stable) {
            amountRepaidBN = userStableDebt;
        }
        else {
            amountRepaidBN = userVariableDebt;
        }
    }
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, amountRepaidBN, bignumber_1.BigNumber.from(0));
    if (borrowRateMode == types_1.RateMode.Stable) {
        const expectedDebt = calcExpectedTotalStableDebt(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, txTimestamp);
        expectedReserveData.principalStableDebt = expectedReserveData.totalStableDebt =
            expectedDebt.sub(amountRepaidBN);
        //due to accumulation errors, the total stable debt might be smaller than the last user debt.
        //in this case we simply set the total supply and avg stable rate to 0.
        if (expectedReserveData.totalStableDebt.lt(0)) {
            expectedReserveData.principalStableDebt =
                expectedReserveData.totalStableDebt =
                    expectedReserveData.averageStableBorrowRate =
                        bignumber_1.BigNumber.from(0);
        }
        else {
            expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, expectedDebt, amountRepaidBN.negated(), userDataBeforeAction.stableBorrowRate);
            //also due to accumulation errors, the final avg stable rate when the last user repays might be negative.
            //if that is the case, it means a small leftover of total stable debt is left, which can be erased.
            if (expectedReserveData.averageStableBorrowRate.lt(0)) {
                expectedReserveData.principalStableDebt =
                    expectedReserveData.totalStableDebt =
                        expectedReserveData.averageStableBorrowRate =
                            bignumber_1.BigNumber.from(0);
            }
        }
    }
    else {
        expectedReserveData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt.sub(amountRepaidBN.rayDiv(expectedReserveData.variableBorrowIndex));
        expectedReserveData.totalVariableDebt = expectedReserveData.scaledVariableDebt.rayMul(expectedReserveData.variableBorrowIndex);
        expectedReserveData.averageStableBorrowRate = reserveDataBeforeAction.averageStableBorrowRate;
    }
    // Update usage ratio because of debt change
    [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
        (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    expectedReserveData.lastUpdateTimestamp = txTimestamp;
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterRepay = calcExpectedReserveDataAfterRepay;
const calcExpectedUserDataAfterBorrow = (amountBorrowed, interestRateMode, reserveDataBeforeAction, expectedDataAfterAction, userDataBeforeAction, txTimestamp, currentTimestamp) => {
    const expectedUserData = {};
    const amountBorrowedBN = bignumber_1.BigNumber.from(amountBorrowed);
    if (interestRateMode == types_1.RateMode.Stable) {
        const stableDebtUntilTx = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
        expectedUserData.principalStableDebt = stableDebtUntilTx.add(amountBorrowed);
        expectedUserData.stableRateLastUpdated = txTimestamp;
        expectedUserData.stableBorrowRate = calcExpectedUserStableRate(stableDebtUntilTx, userDataBeforeAction.stableBorrowRate, amountBorrowedBN, reserveDataBeforeAction.stableBorrowRate);
        expectedUserData.currentStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(expectedUserData.principalStableDebt, expectedUserData.stableBorrowRate, txTimestamp, currentTimestamp);
        expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt;
    }
    else {
        expectedUserData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt.add(amountBorrowedBN.rayDiv(expectedDataAfterAction.variableBorrowIndex));
        expectedUserData.principalStableDebt = userDataBeforeAction.principalStableDebt;
        expectedUserData.stableBorrowRate = userDataBeforeAction.stableBorrowRate;
        expectedUserData.stableRateLastUpdated = userDataBeforeAction.stableRateLastUpdated;
        expectedUserData.currentStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, currentTimestamp);
    }
    expectedUserData.currentVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(expectedDataAfterAction, expectedUserData, currentTimestamp);
    expectedUserData.liquidityRate = expectedDataAfterAction.liquidityRate;
    expectedUserData.usageAsCollateralEnabled = userDataBeforeAction.usageAsCollateralEnabled;
    expectedUserData.currentATokenBalance = (0, exports.calcExpectedATokenBalance)(expectedDataAfterAction, userDataBeforeAction, currentTimestamp);
    expectedUserData.scaledATokenBalance = userDataBeforeAction.scaledATokenBalance;
    expectedUserData.walletBalance = userDataBeforeAction.walletBalance.add(amountBorrowed);
    return expectedUserData;
};
exports.calcExpectedUserDataAfterBorrow = calcExpectedUserDataAfterBorrow;
const calcExpectedUserDataAfterRepay = (totalRepaid, rateMode, reserveDataBeforeAction, expectedDataAfterAction, userDataBeforeAction, user, onBehalfOf, txTimestamp, currentTimestamp) => {
    const expectedUserData = {};
    const variableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, currentTimestamp);
    const stableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, currentTimestamp);
    let totalRepaidBN = bignumber_1.BigNumber.from(totalRepaid);
    if (totalRepaidBN.abs().eq(constants_1.MAX_UINT_AMOUNT)) {
        totalRepaidBN = rateMode == types_1.RateMode.Stable ? stableDebt : variableDebt;
    }
    if (rateMode == types_1.RateMode.Stable) {
        expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt;
        expectedUserData.currentVariableDebt = variableDebt;
        expectedUserData.principalStableDebt = expectedUserData.currentStableDebt =
            stableDebt.sub(totalRepaidBN);
        if (expectedUserData.currentStableDebt.eq('0')) {
            //user repaid everything
            expectedUserData.stableBorrowRate = expectedUserData.stableRateLastUpdated =
                bignumber_1.BigNumber.from('0');
        }
        else {
            expectedUserData.stableBorrowRate = userDataBeforeAction.stableBorrowRate;
            expectedUserData.stableRateLastUpdated = txTimestamp;
        }
    }
    else {
        expectedUserData.currentStableDebt = userDataBeforeAction.principalStableDebt;
        expectedUserData.principalStableDebt = stableDebt;
        expectedUserData.stableBorrowRate = userDataBeforeAction.stableBorrowRate;
        expectedUserData.stableRateLastUpdated = userDataBeforeAction.stableRateLastUpdated;
        expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt.sub(totalRepaidBN.rayDiv(expectedDataAfterAction.variableBorrowIndex));
        expectedUserData.currentVariableDebt = expectedUserData.scaledVariableDebt.rayMul(expectedDataAfterAction.variableBorrowIndex);
    }
    expectedUserData.liquidityRate = expectedDataAfterAction.liquidityRate;
    expectedUserData.usageAsCollateralEnabled = userDataBeforeAction.usageAsCollateralEnabled;
    expectedUserData.currentATokenBalance = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.scaledATokenBalance = userDataBeforeAction.scaledATokenBalance;
    if (user === onBehalfOf) {
        expectedUserData.walletBalance = userDataBeforeAction.walletBalance.sub(totalRepaidBN);
    }
    else {
        //wallet balance didn't change
        expectedUserData.walletBalance = userDataBeforeAction.walletBalance;
    }
    return expectedUserData;
};
exports.calcExpectedUserDataAfterRepay = calcExpectedUserDataAfterRepay;
const calcExpectedUserDataAfterSetUseAsCollateral = (useAsCollateral, reserveDataBeforeAction, userDataBeforeAction, txCost) => {
    const expectedUserData = { ...userDataBeforeAction };
    expectedUserData.usageAsCollateralEnabled = useAsCollateral;
    return expectedUserData;
};
exports.calcExpectedUserDataAfterSetUseAsCollateral = calcExpectedUserDataAfterSetUseAsCollateral;
const calcExpectedReserveDataAfterSwapRateMode = (reserveDataBeforeAction, userDataBeforeAction, rateMode, txTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(0));
    const variableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    const stableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    const totalStableDebtUntilTx = expectedReserveData.totalStableDebt;
    if (rateMode === types_1.RateMode.Stable) {
        //swap user stable debt to variable
        expectedReserveData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt.add(stableDebt.rayDiv(expectedReserveData.variableBorrowIndex));
        expectedReserveData.totalVariableDebt = expectedReserveData.scaledVariableDebt.rayMul(expectedReserveData.variableBorrowIndex);
        expectedReserveData.principalStableDebt = expectedReserveData.totalStableDebt =
            totalStableDebtUntilTx.sub(stableDebt);
        expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, expectedReserveData.principalStableDebt.add(stableDebt), stableDebt.negated(), userDataBeforeAction.stableBorrowRate);
    }
    else {
        //swap variable to stable
        expectedReserveData.principalStableDebt = expectedReserveData.totalStableDebt =
            totalStableDebtUntilTx.add(variableDebt);
        expectedReserveData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt.sub(variableDebt.rayDiv(expectedReserveData.variableBorrowIndex));
        expectedReserveData.totalVariableDebt = expectedReserveData.scaledVariableDebt.rayMul(expectedReserveData.variableBorrowIndex);
        expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRate(reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebt, variableDebt, reserveDataBeforeAction.stableBorrowRate);
    }
    [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
        (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterSwapRateMode = calcExpectedReserveDataAfterSwapRateMode;
const calcExpectedUserDataAfterSwapRateMode = (reserveDataBeforeAction, expectedDataAfterAction, userDataBeforeAction, rateMode, txCost, txTimestamp) => {
    const expectedUserData = { ...userDataBeforeAction };
    const stableDebtBalance = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    const variableDebtBalance = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.currentATokenBalance = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    if (rateMode === types_1.RateMode.Stable) {
        // swap to variable
        expectedUserData.currentStableDebt = expectedUserData.principalStableDebt = bignumber_1.BigNumber.from(0);
        expectedUserData.stableBorrowRate = bignumber_1.BigNumber.from(0);
        expectedUserData.scaledVariableDebt = userDataBeforeAction.scaledVariableDebt.add(stableDebtBalance.rayDiv(expectedDataAfterAction.variableBorrowIndex));
        expectedUserData.currentVariableDebt = expectedUserData.scaledVariableDebt.rayMul(expectedDataAfterAction.variableBorrowIndex);
        expectedUserData.stableRateLastUpdated = bignumber_1.BigNumber.from(0);
    }
    else {
        expectedUserData.principalStableDebt = expectedUserData.currentStableDebt =
            userDataBeforeAction.currentStableDebt.add(variableDebtBalance);
        //weighted average of the previous and the current
        expectedUserData.stableBorrowRate = calcExpectedUserStableRate(stableDebtBalance, userDataBeforeAction.stableBorrowRate, variableDebtBalance, reserveDataBeforeAction.stableBorrowRate);
        expectedUserData.stableRateLastUpdated = txTimestamp;
        expectedUserData.currentVariableDebt = expectedUserData.scaledVariableDebt = bignumber_1.BigNumber.from(0);
    }
    expectedUserData.liquidityRate = expectedDataAfterAction.liquidityRate;
    return expectedUserData;
};
exports.calcExpectedUserDataAfterSwapRateMode = calcExpectedUserDataAfterSwapRateMode;
const calcExpectedReserveDataAfterStableRateRebalance = (reserveDataBeforeAction, userDataBeforeAction, txTimestamp) => {
    const expectedReserveData = {};
    expectedReserveData.unbacked = reserveDataBeforeAction.unbacked;
    expectedReserveData.address = reserveDataBeforeAction.address;
    expectedReserveData.reserveFactor = reserveDataBeforeAction.reserveFactor;
    updateState(reserveDataBeforeAction, expectedReserveData, txTimestamp);
    updateLiquidityAndUsageRatios(reserveDataBeforeAction, expectedReserveData, bignumber_1.BigNumber.from(0), bignumber_1.BigNumber.from(0));
    const userStableDebt = (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    expectedReserveData.principalStableDebt = expectedReserveData.totalStableDebt =
        calcExpectedTotalStableDebt(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, txTimestamp);
    //removing the stable liquidity at the old rate
    const avgRateBefore = calcExpectedAverageStableBorrowRateRebalance(reserveDataBeforeAction.averageStableBorrowRate, expectedReserveData.totalStableDebt, userStableDebt.negated(), userDataBeforeAction.stableBorrowRate);
    // adding it again at the new rate
    expectedReserveData.averageStableBorrowRate = calcExpectedAverageStableBorrowRateRebalance(avgRateBefore, expectedReserveData.totalStableDebt.sub(userStableDebt), userStableDebt, reserveDataBeforeAction.stableBorrowRate);
    [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
        (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    const rates = (0, exports.calcExpectedInterestRates)(reserveDataBeforeAction.symbol, reserveDataBeforeAction.marketStableRate, expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.averageStableBorrowRate, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
    expectedReserveData.liquidityRate = rates[0];
    expectedReserveData.stableBorrowRate = rates[1];
    expectedReserveData.variableBorrowRate = rates[2];
    updateTotalLiquidityAndUsageRatio(expectedReserveData);
    return expectedReserveData;
};
exports.calcExpectedReserveDataAfterStableRateRebalance = calcExpectedReserveDataAfterStableRateRebalance;
const calcExpectedUserDataAfterStableRateRebalance = (reserveDataBeforeAction, expectedDataAfterAction, userDataBeforeAction, txCost, txTimestamp) => {
    const expectedUserData = { ...userDataBeforeAction };
    expectedUserData.principalStableDebt = userDataBeforeAction.principalStableDebt;
    expectedUserData.principalVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.currentStableDebt = expectedUserData.principalStableDebt =
        (0, exports.calcExpectedStableDebtTokenBalance)(userDataBeforeAction.principalStableDebt, userDataBeforeAction.stableBorrowRate, userDataBeforeAction.stableRateLastUpdated, txTimestamp);
    expectedUserData.currentVariableDebt = (0, exports.calcExpectedVariableDebtTokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    expectedUserData.stableRateLastUpdated = txTimestamp;
    expectedUserData.principalVariableDebt = userDataBeforeAction.principalVariableDebt;
    // Stable rate after burn
    expectedUserData.stableBorrowRate = expectedDataAfterAction.averageStableBorrowRate;
    expectedUserData.liquidityRate = expectedDataAfterAction.liquidityRate;
    expectedUserData.currentATokenBalance = (0, exports.calcExpectedATokenBalance)(reserveDataBeforeAction, userDataBeforeAction, txTimestamp);
    return expectedUserData;
};
exports.calcExpectedUserDataAfterStableRateRebalance = calcExpectedUserDataAfterStableRateRebalance;
const calcExpectedScaledATokenBalance = (userDataBeforeAction, index, amountAdded, amountTaken) => {
    return userDataBeforeAction.scaledATokenBalance
        .add(amountAdded.rayDiv(index))
        .sub(amountTaken.rayDiv(index));
};
const calcExpectedATokenBalance = (reserveData, userData, currentTimestamp) => {
    const index = (0, exports.calcExpectedReserveNormalizedIncome)(reserveData, currentTimestamp);
    const { scaledATokenBalance: scaledBalanceBeforeAction } = userData;
    return scaledBalanceBeforeAction.rayMul(index);
};
exports.calcExpectedATokenBalance = calcExpectedATokenBalance;
const calcExpectedAverageStableBorrowRate = (avgStableRateBefore, totalStableDebtBefore, amountChanged, rate) => {
    const weightedTotalBorrows = avgStableRateBefore.mul(totalStableDebtBefore);
    const weightedAmountBorrowed = rate.mul(amountChanged);
    const totalBorrowedStable = totalStableDebtBefore.add(amountChanged);
    if (totalBorrowedStable.eq(0))
        return bignumber_1.BigNumber.from('0');
    return weightedTotalBorrows.add(weightedAmountBorrowed).div(totalBorrowedStable);
};
const calcExpectedAverageStableBorrowRateRebalance = (avgStableRateBefore, totalStableDebtBefore, amountChanged, rate) => {
    const weightedTotalBorrows = avgStableRateBefore.rayMul(totalStableDebtBefore);
    const weightedAmountBorrowed = rate.rayMul(amountChanged.wadToRay());
    const totalBorrowedStable = totalStableDebtBefore.add(amountChanged.wadToRay());
    if (totalBorrowedStable.eq(0))
        return bignumber_1.BigNumber.from('0');
    return weightedTotalBorrows.add(weightedAmountBorrowed).rayDiv(totalBorrowedStable);
};
const calcExpectedVariableDebtTokenBalance = (reserveData, userData, currentTimestamp) => {
    const normalizedDebt = (0, exports.calcExpectedReserveNormalizedDebt)(reserveData.variableBorrowRate, reserveData.variableBorrowIndex, reserveData.lastUpdateTimestamp, currentTimestamp);
    const { scaledVariableDebt } = userData;
    return scaledVariableDebt.rayMul(normalizedDebt);
};
exports.calcExpectedVariableDebtTokenBalance = calcExpectedVariableDebtTokenBalance;
const calcExpectedStableDebtTokenBalance = (principalStableDebt, stableBorrowRate, stableRateLastUpdated, currentTimestamp) => {
    if (stableBorrowRate.eq(0) ||
        currentTimestamp.eq(stableRateLastUpdated) ||
        stableRateLastUpdated.eq(0)) {
        return principalStableDebt;
    }
    const cumulatedInterest = (0, exports.calcCompoundedInterest)(stableBorrowRate, currentTimestamp, stableRateLastUpdated);
    return principalStableDebt.rayMul(cumulatedInterest);
};
exports.calcExpectedStableDebtTokenBalance = calcExpectedStableDebtTokenBalance;
const calcLinearInterest = (rate, currentTimestamp, lastUpdateTimestamp) => {
    const timeDifference = currentTimestamp.sub(lastUpdateTimestamp);
    const cumulatedInterest = rate.mul(timeDifference).div(bignumber_1.BigNumber.from(constants_1.ONE_YEAR)).add(constants_1.RAY);
    return cumulatedInterest;
};
const calcCompoundedInterest = (rate, currentTimestamp, lastUpdateTimestamp) => {
    const timeDifference = currentTimestamp.sub(lastUpdateTimestamp);
    const SECONDS_PER_YEAR = bignumber_1.BigNumber.from(constants_1.ONE_YEAR);
    if (timeDifference.eq(0)) {
        return bignumber_1.BigNumber.from(constants_1.RAY);
    }
    const expMinusOne = timeDifference.sub(1);
    const expMinusTwo = timeDifference.gt(2) ? timeDifference.sub(2) : 0;
    const basePowerTwo = rate.rayMul(rate).div(SECONDS_PER_YEAR.mul(SECONDS_PER_YEAR));
    const basePowerThree = basePowerTwo.rayMul(rate).div(SECONDS_PER_YEAR);
    const secondTerm = timeDifference.mul(expMinusOne).mul(basePowerTwo).div(2);
    const thirdTerm = timeDifference.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree).div(6);
    return bignumber_1.BigNumber.from(constants_1.RAY)
        .add(rate.mul(timeDifference).div(SECONDS_PER_YEAR))
        .add(secondTerm)
        .add(thirdTerm);
};
exports.calcCompoundedInterest = calcCompoundedInterest;
const calcExpectedInterestRates = (reserveSymbol, marketStableRate, totalStableDebt, totalVariableDebt, averageStableBorrowRate, availableLiquidity, totalLiquidity) => {
    const { reservesParams } = exports.configuration;
    const reserveIndex = Object.keys(reservesParams).findIndex((value) => value === reserveSymbol);
    const [, reserveConfiguration] = Object.entries(reservesParams)[reserveIndex];
    const [borrowUsageRatio, supplyUsageRatio] = (0, exports.calcExpectedUsageRatios)(totalStableDebt, totalVariableDebt, availableLiquidity, totalLiquidity);
    let stableBorrowRate = marketStableRate;
    let variableBorrowRate = bignumber_1.BigNumber.from(reserveConfiguration.strategy.baseVariableBorrowRate);
    const OPTIMAL_USAGE_RATIO = bignumber_1.BigNumber.from(reserveConfiguration.strategy.optimalUsageRatio);
    const MAX_EXCESS_USAGE_RATIO = bignumber_1.BigNumber.from(constants_1.RAY).sub(OPTIMAL_USAGE_RATIO);
    const OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = bignumber_1.BigNumber.from(reserveConfiguration.strategy.optimalStableToTotalDebtRatio);
    const MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO = bignumber_1.BigNumber.from(constants_1.RAY).sub(OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO);
    const totalDebt = totalStableDebt.add(totalVariableDebt);
    const stableToTotalDebtRatio = totalStableDebt.gt(0)
        ? totalStableDebt.rayDiv(totalDebt)
        : bignumber_1.BigNumber.from(0);
    if (borrowUsageRatio.gt(OPTIMAL_USAGE_RATIO)) {
        const excessBorrowUsageRatio = borrowUsageRatio
            .sub(reserveConfiguration.strategy.optimalUsageRatio)
            .rayDiv(MAX_EXCESS_USAGE_RATIO);
        stableBorrowRate = stableBorrowRate
            .add(reserveConfiguration.strategy.stableRateSlope1)
            .add(bignumber_1.BigNumber.from(reserveConfiguration.strategy.stableRateSlope2).rayMul(excessBorrowUsageRatio));
        variableBorrowRate = variableBorrowRate
            .add(reserveConfiguration.strategy.variableRateSlope1)
            .add(bignumber_1.BigNumber.from(reserveConfiguration.strategy.variableRateSlope2).rayMul(excessBorrowUsageRatio));
    }
    else {
        stableBorrowRate = stableBorrowRate.add(bignumber_1.BigNumber.from(reserveConfiguration.strategy.stableRateSlope1)
            .rayMul(borrowUsageRatio)
            .rayDiv(bignumber_1.BigNumber.from(OPTIMAL_USAGE_RATIO)));
        variableBorrowRate = variableBorrowRate.add(bignumber_1.BigNumber.from(reserveConfiguration.strategy.variableRateSlope1)
            .rayMul(borrowUsageRatio)
            .rayDiv(OPTIMAL_USAGE_RATIO));
    }
    if (stableToTotalDebtRatio.gt(OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO)) {
        const excessStableDebtRatio = stableToTotalDebtRatio
            .sub(OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO)
            .rayDiv(MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO);
        stableBorrowRate = stableBorrowRate.add(bignumber_1.BigNumber.from(reserveConfiguration.strategy.stableRateExcessOffset).rayMul(excessStableDebtRatio));
    }
    const expectedOverallRate = (0, exports.calcExpectedOverallBorrowRate)(totalStableDebt, totalVariableDebt, variableBorrowRate, averageStableBorrowRate);
    const liquidityRate = expectedOverallRate
        .rayMul(supplyUsageRatio)
        .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reserveConfiguration.reserveFactor));
    return [liquidityRate, stableBorrowRate, variableBorrowRate];
};
exports.calcExpectedInterestRates = calcExpectedInterestRates;
const calcExpectedOverallBorrowRate = (totalStableDebt, totalVariableDebt, currentVariableBorrowRate, currentAverageStableBorrowRate) => {
    const totalBorrows = totalStableDebt.add(totalVariableDebt);
    if (totalBorrows.eq(0))
        return bignumber_1.BigNumber.from(0);
    const weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);
    const weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);
    const overallBorrowRate = weightedVariableRate
        .add(weightedStableRate)
        .rayDiv(totalBorrows.wadToRay());
    return overallBorrowRate;
};
exports.calcExpectedOverallBorrowRate = calcExpectedOverallBorrowRate;
const calcExpectedUsageRatios = (totalStableDebt, totalVariableDebt, availableLiquidity, totalLiquidity) => {
    const totalDebt = totalStableDebt.add(totalVariableDebt);
    const borrowUsageRatio = totalDebt.eq(0)
        ? bignumber_1.BigNumber.from(0)
        : totalDebt.rayDiv(availableLiquidity.add(totalDebt));
    let supplyUsageRatio = totalDebt.eq(0)
        ? bignumber_1.BigNumber.from(0)
        : totalDebt.rayDiv(totalLiquidity.add(totalDebt));
    (0, chai_1.expect)(supplyUsageRatio).to.be.lte(borrowUsageRatio, 'Supply usage ratio > borrow usage ratio');
    return [borrowUsageRatio, supplyUsageRatio];
};
exports.calcExpectedUsageRatios = calcExpectedUsageRatios;
const calcExpectedReserveNormalizedIncome = (reserveData, currentTimestamp) => {
    const { liquidityRate, liquidityIndex, lastUpdateTimestamp } = reserveData;
    //if usage ratio is 0, nothing to compound
    if (liquidityRate.eq('0')) {
        return liquidityIndex;
    }
    const cumulatedInterest = calcLinearInterest(liquidityRate, currentTimestamp, lastUpdateTimestamp);
    const income = cumulatedInterest.rayMul(liquidityIndex);
    return income;
};
exports.calcExpectedReserveNormalizedIncome = calcExpectedReserveNormalizedIncome;
const calcExpectedReserveNormalizedDebt = (variableBorrowRate, variableBorrowIndex, lastUpdateTimestamp, currentTimestamp) => {
    //if usage ratio is 0, nothing to compound
    if (variableBorrowRate.eq('0')) {
        return variableBorrowIndex;
    }
    const cumulatedInterest = (0, exports.calcCompoundedInterest)(variableBorrowRate, currentTimestamp, lastUpdateTimestamp);
    const debt = cumulatedInterest.rayMul(variableBorrowIndex);
    return debt;
};
exports.calcExpectedReserveNormalizedDebt = calcExpectedReserveNormalizedDebt;
const calcExpectedUserStableRate = (balanceBefore, rateBefore, amount, rateNew) => {
    return balanceBefore.mul(rateBefore).add(amount.mul(rateNew)).div(balanceBefore.add(amount));
};
const calcExpectedLiquidityIndex = (reserveData, timestamp) => {
    //if usage ratio is 0, nothing to compound
    if (reserveData.supplyUsageRatio.eq(0)) {
        return reserveData.liquidityIndex;
    }
    const cumulatedInterest = calcLinearInterest(reserveData.liquidityRate, timestamp, reserveData.lastUpdateTimestamp);
    return cumulatedInterest.rayMul(reserveData.liquidityIndex);
};
const calcExpectedVariableBorrowIndex = (reserveData, timestamp) => {
    //if totalVariableDebt is 0, nothing to compound
    if (reserveData.totalVariableDebt.eq('0')) {
        return reserveData.variableBorrowIndex;
    }
    const cumulatedInterest = (0, exports.calcCompoundedInterest)(reserveData.variableBorrowRate, timestamp, reserveData.lastUpdateTimestamp);
    return cumulatedInterest.rayMul(reserveData.variableBorrowIndex);
};
const calcExpectedTotalStableDebt = (principalStableDebt, averageStableBorrowRate, lastUpdateTimestamp, currentTimestamp) => {
    const cumulatedInterest = (0, exports.calcCompoundedInterest)(averageStableBorrowRate, currentTimestamp, lastUpdateTimestamp);
    return cumulatedInterest.rayMul(principalStableDebt);
};
const calcExpectedTotalVariableDebt = (reserveData, expectedVariableDebtIndex) => {
    return reserveData.scaledVariableDebt.rayMul(expectedVariableDebtIndex);
};
const calcExpectedAccrueToTreasury = (reserveData, nextReserveData) => {
    const reserveFactor = reserveData.reserveFactor;
    if (reserveFactor.eq(0)) {
        return reserveData.accruedToTreasuryScaled;
    }
    const prevTotalVariableDebt = reserveData.scaledVariableDebt.rayMul(reserveData.variableBorrowIndex);
    const currTotalVariableDebt = nextReserveData.scaledVariableDebt.rayMul(nextReserveData.variableBorrowIndex);
    // Be aware that the ordering in the calcCompoundInterest is NOT the same as the solidity `calculateCompoundedInterest`
    const cumulatedStableInterest = (0, exports.calcCompoundedInterest)(reserveData.averageStableBorrowRate, reserveData.lastUpdateTimestamp, reserveData.totalStableDebtLastUpdated);
    const prevTotalStableDebt = reserveData.principalStableDebt.rayMul(cumulatedStableInterest);
    const totalDebtAccrued = currTotalVariableDebt
        .add(nextReserveData.totalStableDebt)
        .sub(prevTotalVariableDebt)
        .sub(prevTotalStableDebt);
    const amountToMint = totalDebtAccrued.percentMul(reserveFactor);
    if (amountToMint.gt(0)) {
        return reserveData.accruedToTreasuryScaled.add(amountToMint.rayDiv(nextReserveData.liquidityIndex));
    }
    else {
        return reserveData.accruedToTreasuryScaled;
    }
};
const updateState = (reserveDataBeforeAction, expectedReserveData, txTimestamp) => {
    // Update indexes
    expectedReserveData.liquidityIndex = calcExpectedLiquidityIndex(reserveDataBeforeAction, txTimestamp);
    expectedReserveData.variableBorrowIndex = calcExpectedVariableBorrowIndex(reserveDataBeforeAction, txTimestamp);
    // Update debts
    expectedReserveData.totalStableDebt = calcExpectedTotalStableDebt(reserveDataBeforeAction.principalStableDebt, reserveDataBeforeAction.averageStableBorrowRate, reserveDataBeforeAction.totalStableDebtLastUpdated, txTimestamp);
    expectedReserveData.totalVariableDebt = calcExpectedTotalVariableDebt(reserveDataBeforeAction, expectedReserveData.variableBorrowIndex);
    expectedReserveData.scaledVariableDebt = reserveDataBeforeAction.scaledVariableDebt;
    expectedReserveData.principalStableDebt = reserveDataBeforeAction.principalStableDebt;
    // Accrue to treasury
    expectedReserveData.accruedToTreasuryScaled = calcExpectedAccrueToTreasury(reserveDataBeforeAction, expectedReserveData);
};
const updateLiquidityAndUsageRatios = (reserveDataBeforeAction, expectedReserveData, liquidityAdded, liquidityTaken) => {
    expectedReserveData.availableLiquidity = reserveDataBeforeAction.availableLiquidity
        .add(liquidityAdded)
        .sub(liquidityTaken);
    expectedReserveData.totalLiquidity = expectedReserveData.availableLiquidity.add(expectedReserveData.unbacked);
    [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
        (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
};
const updateTotalLiquidityAndUsageRatio = (expectedReserveData) => {
    expectedReserveData.totalLiquidity = expectedReserveData.availableLiquidity.add(expectedReserveData.unbacked);
    [expectedReserveData.borrowUsageRatio, expectedReserveData.supplyUsageRatio] =
        (0, exports.calcExpectedUsageRatios)(expectedReserveData.totalStableDebt, expectedReserveData.totalVariableDebt, expectedReserveData.availableLiquidity, expectedReserveData.totalLiquidity);
};
