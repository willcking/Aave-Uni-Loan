"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchEvent = exports.getUserData = exports.getReserveData = void 0;
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const bignumber_1 = require("@ethersproject/bignumber");
const deploy_v3_1 = require("@aave/deploy-v3");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const getReserveData = async (helper, reserve) => {
    const [reserveData, tokenAddresses, irStrategyAddress, reserveConfiguration, token] = await Promise.all([
        helper.getReserveData(reserve),
        helper.getReserveTokensAddresses(reserve),
        helper.getInterestRateStrategyAddress(reserve),
        helper.getReserveConfigurationData(reserve),
        (0, deploy_v3_1.getContract)('IERC20Detailed', reserve),
    ]);
    const stableDebtToken = await (0, contract_getters_1.getStableDebtToken)(tokenAddresses.stableDebtTokenAddress);
    const variableDebtToken = await (0, contract_getters_1.getVariableDebtToken)(tokenAddresses.variableDebtTokenAddress);
    const irStrategy = await (0, contract_getters_1.getIRStrategy)(irStrategyAddress);
    const baseStableRate = await irStrategy.getBaseStableBorrowRate();
    const { 0: principalStableDebt } = await stableDebtToken.getSupplyData();
    const totalStableDebtLastUpdated = await stableDebtToken.getTotalSupplyLastUpdated();
    const scaledVariableDebt = await variableDebtToken.scaledTotalSupply();
    const symbol = await token.symbol();
    const decimals = bignumber_1.BigNumber.from(await token.decimals());
    const accruedToTreasuryScaled = reserveData.accruedToTreasuryScaled;
    const unbacked = reserveData.unbacked;
    const aToken = (await (0, contract_getters_1.getAToken)(tokenAddresses.aTokenAddress));
    // Need the reserve factor
    const reserveFactor = reserveConfiguration.reserveFactor;
    const availableLiquidity = await token.balanceOf(aToken.address);
    const totalLiquidity = availableLiquidity.add(unbacked);
    const totalDebt = reserveData.totalStableDebt.add(reserveData.totalVariableDebt);
    const borrowUsageRatio = totalDebt.eq(0)
        ? bignumber_1.BigNumber.from(0)
        : totalDebt.rayDiv(availableLiquidity.add(totalDebt));
    let supplyUsageRatio = totalDebt.eq(0)
        ? bignumber_1.BigNumber.from(0)
        : totalDebt.rayDiv(totalLiquidity.add(totalDebt));
    (0, chai_1.expect)(supplyUsageRatio).to.be.lte(borrowUsageRatio, 'Supply usage ratio > borrow usage ratio');
    return {
        reserveFactor,
        unbacked,
        accruedToTreasuryScaled,
        availableLiquidity,
        totalLiquidity,
        borrowUsageRatio,
        supplyUsageRatio,
        totalStableDebt: reserveData.totalStableDebt,
        totalVariableDebt: reserveData.totalVariableDebt,
        liquidityRate: reserveData.liquidityRate,
        variableBorrowRate: reserveData.variableBorrowRate,
        stableBorrowRate: reserveData.stableBorrowRate,
        averageStableBorrowRate: reserveData.averageStableBorrowRate,
        liquidityIndex: reserveData.liquidityIndex,
        variableBorrowIndex: reserveData.variableBorrowIndex,
        lastUpdateTimestamp: bignumber_1.BigNumber.from(reserveData.lastUpdateTimestamp),
        totalStableDebtLastUpdated: bignumber_1.BigNumber.from(totalStableDebtLastUpdated),
        principalStableDebt: principalStableDebt,
        scaledVariableDebt: scaledVariableDebt,
        address: reserve,
        aTokenAddress: tokenAddresses.aTokenAddress,
        symbol,
        decimals,
        marketStableRate: bignumber_1.BigNumber.from(baseStableRate),
    };
};
exports.getReserveData = getReserveData;
const getUserData = async (pool, helper, reserve, user, sender) => {
    const [userData, scaledATokenBalance] = await Promise.all([
        helper.getUserReserveData(reserve, user),
        getATokenUserData(reserve, user, helper),
    ]);
    const token = await (0, contract_getters_1.getMintableERC20)(reserve);
    const walletBalance = await token.balanceOf(sender || user);
    return {
        scaledATokenBalance: bignumber_1.BigNumber.from(scaledATokenBalance),
        currentATokenBalance: userData.currentATokenBalance,
        currentStableDebt: userData.currentStableDebt,
        currentVariableDebt: userData.currentVariableDebt,
        principalStableDebt: userData.principalStableDebt,
        scaledVariableDebt: userData.scaledVariableDebt,
        stableBorrowRate: userData.stableBorrowRate,
        liquidityRate: userData.liquidityRate,
        usageAsCollateralEnabled: userData.usageAsCollateralEnabled,
        stableRateLastUpdated: bignumber_1.BigNumber.from(userData.stableRateLastUpdated),
        walletBalance,
    };
};
exports.getUserData = getUserData;
const getATokenUserData = async (reserve, user, helpersContract) => {
    const aTokenAddress = (await helpersContract.getReserveTokensAddresses(reserve))
        .aTokenAddress;
    const aToken = await (0, contract_getters_1.getAToken)(aTokenAddress);
    const scaledBalance = await aToken.scaledBalanceOf(user);
    return scaledBalance.toString();
};
const matchEvent = (receipt, name, eventContract, emitterAddress, expectedArgs) => {
    const events = receipt.logs;
    if (events != undefined) {
        // match name from list of events in eventContract, when found, compute the sigHash
        let sigHash;
        for (let contractEvent of Object.keys(eventContract.interface.events)) {
            if (contractEvent.startsWith(name) && contractEvent.charAt(name.length) == '(') {
                sigHash = ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes(contractEvent));
                break;
            }
        }
        // Throw if the sigHash was not found
        if (!sigHash) {
            ethers_1.logger.throwError(`Event "${name}" not found in provided contract. \nAre you sure you're using the right contract?`);
        }
        // Find the given event in the emitted logs
        let invalidParamsButExists = false;
        for (let emittedEvent of events) {
            // If we find one with the correct sigHash, check if it is the one we're looking for
            if (emittedEvent.topics[0] == sigHash) {
                // If an emitter address is passed, validate that this is indeed the correct emitter, if not, continue
                if (emitterAddress) {
                    if (emittedEvent.address != emitterAddress)
                        continue;
                }
                const event = eventContract.interface.parseLog(emittedEvent);
                // If there are expected arguments, validate them, otherwise, return here
                if (expectedArgs) {
                    if (expectedArgs.length != event.args.length) {
                        ethers_1.logger.throwError(`Event "${name}" emitted with correct signature, but expected args are of invalid length`);
                    }
                    invalidParamsButExists = false;
                    // Iterate through arguments and check them, if there is a mismatch, continue with the loop
                    for (let i = 0; i < expectedArgs.length; i++) {
                        // Parse empty arrays as empty bytes
                        if (expectedArgs[i].constructor == Array && expectedArgs[i].length == 0) {
                            expectedArgs[i] = '0x';
                        }
                        // Break out of the expected args loop if there is a mismatch, this will continue the emitted event loop
                        if (bignumber_1.BigNumber.isBigNumber(event.args[i])) {
                            if (!event.args[i].eq(bignumber_1.BigNumber.from(expectedArgs[i]))) {
                                invalidParamsButExists = true;
                                break;
                            }
                        }
                        else if (event.args[i].constructor == Array) {
                            let params = event.args[i];
                            let expected = expectedArgs[i];
                            for (let j = 0; j < params.length; j++) {
                                if (bignumber_1.BigNumber.isBigNumber(params[j])) {
                                    if (!params[j].eq(bignumber_1.BigNumber.from(expected[j]))) {
                                        invalidParamsButExists = true;
                                        break;
                                    }
                                }
                                else if (params[j] != expected[j]) {
                                    invalidParamsButExists = true;
                                    break;
                                }
                            }
                            if (invalidParamsButExists)
                                break;
                        }
                        else if (event.args[i] != expectedArgs[i]) {
                            invalidParamsButExists = true;
                            break;
                        }
                    }
                    // Return if the for loop did not cause a break, so a match has been found, otherwise proceed with the event loop
                    if (!invalidParamsButExists) {
                        return;
                    }
                }
                else {
                    return;
                }
            }
        }
        // Throw if the event args were not expected or the event was not found in the logs
        if (invalidParamsButExists) {
            ethers_1.logger.throwError(`Event "${name}" found in logs but with unexpected args`);
        }
        else {
            ethers_1.logger.throwError(`Event "${name}" not found emitted by "${emitterAddress}" in given transaction log`);
        }
    }
    else {
        ethers_1.logger.throwError('No events were emitted');
    }
};
exports.matchEvent = matchEvent;
