"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStableDebtTokenEvent = exports.printStableDebtTokenEvents = exports.getVariableDebtTokenEvent = exports.printVariableDebtTokenEvents = exports.getATokenEvent = exports.printATokenEvents = exports.repayStableBorrow = exports.stableBorrow = exports.repayVariableBorrow = exports.variableBorrow = exports.transferFrom = exports.transfer = exports.withdraw = exports.supply = void 0;
const MockATokenRepayment__factory_1 = require("./../../../types/factories/mocks/tokens/MockATokenRepayment__factory");
const hardhat_1 = require("hardhat");
const bignumber_1 = require("@ethersproject/bignumber");
const types_1 = require("../../../types");
const constants_1 = require("../../../helpers/constants");
const calculations_1 = require("./calculations");
const actions_1 = require("../actions");
const types_2 = require("../../../helpers/types");
const contracts_helpers_1 = require("../../../helpers/contracts-helpers");
const helpers_1 = require("./helpers");
require("./wadraymath");
const chai_1 = require("chai");
const ATOKEN_EVENTS = [
    { sig: 'Transfer(address,address,uint256)', args: ['from', 'to', 'value'] },
    {
        sig: 'Mint(address,address,uint256,uint256,uint256)',
        args: ['caller', 'onBehalfOf', 'value', 'balanceIncrease', 'index'],
    },
    {
        sig: 'Burn(address,address,uint256,uint256,uint256)',
        args: ['from', 'target', 'value', 'balanceIncrease', 'index'],
    },
    {
        sig: 'BalanceTransfer(address,address,uint256,uint256)',
        args: ['from', 'to', 'value', 'index'],
    },
];
const VARIABLE_DEBT_TOKEN_EVENTS = [
    { sig: 'Transfer(address,address,uint256)', args: ['from', 'to', 'value'] },
    {
        sig: 'Mint(address,address,uint256,uint256,uint256)',
        args: ['caller', 'onBehalfOf', 'value', 'balanceIncrease', 'index'],
    },
    {
        sig: 'Burn(address,address,uint256,uint256,uint256)',
        args: ['from', 'target', 'value', 'balanceIncrease', 'index'],
    },
];
const STABLE_DEBT_TOKEN_EVENTS = [
    { sig: 'Transfer(address,address,uint256)', args: ['from', 'to', 'value'] },
    {
        sig: 'Mint(address,address,uint256,uint256,uint256,uint256,uint256,uint256)',
        args: [
            'user',
            'onBehalfOf',
            'amount',
            'currentBalance',
            'balanceIncrease',
            'newRate',
            'avgStableRate',
            'newTotalSupply',
        ],
    },
    {
        sig: 'Burn(address,uint256,uint256,uint256,uint256,uint256)',
        args: [
            'from',
            'amount',
            'currentBalance',
            'balanceIncrease',
            'avgStableRate',
            'newTotalSupply',
        ],
    },
];
const getBalanceIncrease = (scaledBalance, indexBeforeAction, indexAfterAction) => {
    return scaledBalance.rayMul(indexAfterAction).sub(scaledBalance.rayMul(indexBeforeAction));
};
const supply = async (pool, user, underlying, amountToConvert, onBehalfOf, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const previousIndex = await aToken.getPreviousIndex(onBehalfOf);
    const tx = await pool.connect(user.signer).supply(underlying, amount, onBehalfOf, '0');
    const rcpt = await tx.wait();
    const indexAfter = await pool.getReserveNormalizedIncome(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    const scaledBalance = (await aToken.scaledBalanceOf(onBehalfOf)).sub(addedScaledBalance);
    const balanceIncrease = getBalanceIncrease(scaledBalance, previousIndex, indexAfter);
    if (debug)
        (0, exports.printATokenEvents)(aToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [user.address, aToken.address, amount]);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [
        constants_1.ZERO_ADDRESS,
        onBehalfOf,
        amount.add(balanceIncrease),
    ]);
    (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
        user.address,
        onBehalfOf,
        amount.add(balanceIncrease),
        balanceIncrease,
        indexAfter,
    ]);
    return rcpt;
};
exports.supply = supply;
const withdraw = async (pool, user, underlying, amountToConvert, to, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const previousIndex = await aToken.getPreviousIndex(user.address);
    const tx = await pool.connect(user.signer).withdraw(underlying, amount, to);
    const rcpt = await tx.wait();
    const indexAfter = await pool.getReserveNormalizedIncome(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    const scaledBalance = (await aToken.scaledBalanceOf(user.address)).add(addedScaledBalance);
    const balanceIncrease = getBalanceIncrease(scaledBalance, previousIndex, indexAfter);
    if (debug)
        (0, exports.printATokenEvents)(aToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [aToken.address, to, amount]);
    if (balanceIncrease.gt(amount)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [
            constants_1.ZERO_ADDRESS,
            user.address,
            balanceIncrease.sub(amount),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
            user.address,
            user.address,
            balanceIncrease.sub(amount),
            balanceIncrease,
            indexAfter,
        ]);
    }
    else {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [
            user.address,
            constants_1.ZERO_ADDRESS,
            amount.sub(balanceIncrease),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Burn', aToken, aToken.address, [
            user.address,
            to,
            amount.sub(balanceIncrease),
            balanceIncrease,
            indexAfter,
        ]);
    }
    return rcpt;
};
exports.withdraw = withdraw;
const transfer = async (pool, user, underlying, amountToConvert, to, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress } = await pool.getReserveData(underlying);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const fromPreviousIndex = await aToken.getPreviousIndex(user.address);
    const toPreviousIndex = await aToken.getPreviousIndex(to);
    const tx = await aToken.connect(user.signer).transfer(to, amount);
    const rcpt = await tx.wait();
    const indexAfter = await pool.getReserveNormalizedIncome(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    // The amount of scaled balance transferred is 0 if self-transfer
    const deltaScaledBalance = user.address == to ? bignumber_1.BigNumber.from(0) : addedScaledBalance;
    const fromScaledBalance = (await aToken.scaledBalanceOf(user.address)).add(deltaScaledBalance);
    const toScaledBalance = (await aToken.scaledBalanceOf(to)).sub(deltaScaledBalance);
    const fromBalanceIncrease = getBalanceIncrease(fromScaledBalance, fromPreviousIndex, indexAfter);
    const toBalanceIncrease = getBalanceIncrease(toScaledBalance, toPreviousIndex, indexAfter);
    if (debug)
        (0, exports.printATokenEvents)(aToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [user.address, to, amount]);
    (0, helpers_1.matchEvent)(rcpt, 'BalanceTransfer', aToken, aToken.address, [
        user.address,
        to,
        addedScaledBalance,
        indexAfter,
    ]);
    if (fromBalanceIncrease.gt(0)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [
            constants_1.ZERO_ADDRESS,
            user.address,
            fromBalanceIncrease,
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
            user.address,
            user.address,
            fromBalanceIncrease,
            fromBalanceIncrease,
            indexAfter,
        ]);
    }
    if (user.address != to && toBalanceIncrease.gt(0)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [constants_1.ZERO_ADDRESS, to, toBalanceIncrease]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
            user.address,
            to,
            toBalanceIncrease,
            toBalanceIncrease,
            indexAfter,
        ]);
    }
    return rcpt;
};
exports.transfer = transfer;
const transferFrom = async (pool, user, origin, underlying, amountToConvert, to, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress } = await pool.getReserveData(underlying);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const fromPreviousIndex = await aToken.getPreviousIndex(origin);
    const toPreviousIndex = await aToken.getPreviousIndex(to);
    const tx = await aToken.connect(user.signer).transferFrom(origin, to, amount);
    const rcpt = await tx.wait();
    const indexAfter = await pool.getReserveNormalizedIncome(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    // The amount of scaled balance transferred is 0 if self-transfer
    const deltaScaledBalance = origin == to ? bignumber_1.BigNumber.from(0) : addedScaledBalance;
    const fromScaledBalance = (await aToken.scaledBalanceOf(origin)).add(deltaScaledBalance);
    const toScaledBalance = (await aToken.scaledBalanceOf(to)).sub(deltaScaledBalance);
    const fromBalanceIncrease = getBalanceIncrease(fromScaledBalance, fromPreviousIndex, indexAfter);
    const toBalanceIncrease = getBalanceIncrease(toScaledBalance, toPreviousIndex, indexAfter);
    if (debug)
        (0, exports.printATokenEvents)(aToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [origin, to, amount]);
    (0, helpers_1.matchEvent)(rcpt, 'BalanceTransfer', aToken, aToken.address, [
        origin,
        to,
        addedScaledBalance,
        indexAfter,
    ]);
    if (fromBalanceIncrease.gt(0)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [
            constants_1.ZERO_ADDRESS,
            origin,
            fromBalanceIncrease,
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
            user.address,
            origin,
            fromBalanceIncrease,
            fromBalanceIncrease,
            indexAfter,
        ]);
    }
    if (origin != to && toBalanceIncrease.gt(0)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', aToken, aToken.address, [constants_1.ZERO_ADDRESS, to, toBalanceIncrease]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', aToken, aToken.address, [
            user.address,
            to,
            toBalanceIncrease,
            toBalanceIncrease,
            indexAfter,
        ]);
    }
    return rcpt;
};
exports.transferFrom = transferFrom;
const variableBorrow = async (pool, user, underlying, amountToConvert, onBehalfOf, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress, variableDebtTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const variableDebtToken = types_1.VariableDebtToken__factory.connect(variableDebtTokenAddress, user.signer);
    let previousIndex = await variableDebtToken.getPreviousIndex(onBehalfOf);
    const tx = await pool
        .connect(user.signer)
        .borrow(underlying, amount, types_2.RateMode.Variable, 0, onBehalfOf);
    const rcpt = await tx.wait();
    const indexAfter = await pool.getReserveNormalizedVariableDebt(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    const scaledBalance = (await variableDebtToken.scaledBalanceOf(onBehalfOf)).sub(addedScaledBalance);
    const balanceIncrease = getBalanceIncrease(scaledBalance, previousIndex, indexAfter);
    if (debug)
        (0, exports.printVariableDebtTokenEvents)(variableDebtToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [aToken.address, user.address, amount]);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', variableDebtToken, variableDebtToken.address, [
        constants_1.ZERO_ADDRESS,
        onBehalfOf,
        amount.add(balanceIncrease),
    ]);
    (0, helpers_1.matchEvent)(rcpt, 'Mint', variableDebtToken, variableDebtToken.address, [
        user.address,
        onBehalfOf,
        amount.add(balanceIncrease),
        balanceIncrease,
        indexAfter,
    ]);
    return rcpt;
};
exports.variableBorrow = variableBorrow;
const repayVariableBorrow = async (pool, user, underlying, amountToConvert, onBehalfOf, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress, variableDebtTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const variableDebtToken = types_1.VariableDebtToken__factory.connect(variableDebtTokenAddress, user.signer);
    const previousIndex = await variableDebtToken.getPreviousIndex(onBehalfOf);
    const tx = await pool
        .connect(user.signer)
        .repay(underlying, amount, types_2.RateMode.Variable, onBehalfOf);
    const rcpt = await tx.wait();
    // check handleRepayment function is correctly called
    await (0, chai_1.expect)(tx)
        .to.emit(MockATokenRepayment__factory_1.MockATokenRepayment__factory.connect(aTokenAddress, user.signer), 'MockRepayment')
        .withArgs(user.address, onBehalfOf, amount);
    const indexAfter = await pool.getReserveNormalizedVariableDebt(underlying);
    const addedScaledBalance = amount.rayDiv(indexAfter);
    const scaledBalance = (await variableDebtToken.scaledBalanceOf(onBehalfOf)).add(addedScaledBalance);
    const balanceIncrease = getBalanceIncrease(scaledBalance, previousIndex, indexAfter);
    if (debug)
        (0, exports.printVariableDebtTokenEvents)(variableDebtToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [user.address, aToken.address, amount]);
    if (balanceIncrease.gt(amount)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', variableDebtToken, variableDebtToken.address, [
            constants_1.ZERO_ADDRESS,
            onBehalfOf,
            balanceIncrease.sub(amount),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', variableDebtToken, variableDebtToken.address, [
            onBehalfOf,
            onBehalfOf,
            balanceIncrease.sub(amount),
            balanceIncrease,
            indexAfter,
        ]);
    }
    else {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', variableDebtToken, variableDebtToken.address, [
            onBehalfOf,
            constants_1.ZERO_ADDRESS,
            amount.sub(balanceIncrease),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Burn', variableDebtToken, variableDebtToken.address, [
            onBehalfOf,
            constants_1.ZERO_ADDRESS,
            amount.sub(balanceIncrease),
            balanceIncrease,
            indexAfter,
        ]);
    }
    return rcpt;
};
exports.repayVariableBorrow = repayVariableBorrow;
const stableBorrow = async (pool, user, underlying, amountToConvert, onBehalfOf, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress, stableDebtTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const stableDebtToken = types_1.StableDebtToken__factory.connect(stableDebtTokenAddress, user.signer);
    const previousIndex = await stableDebtToken.getUserStableRate(onBehalfOf);
    const principalBalance = await stableDebtToken.principalBalanceOf(onBehalfOf);
    const lastTimestamp = await stableDebtToken.getUserLastUpdated(onBehalfOf);
    const tx = await pool
        .connect(user.signer)
        .borrow(underlying, amount, types_2.RateMode.Stable, 0, onBehalfOf);
    const rcpt = await tx.wait();
    const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(rcpt);
    const newPrincipalBalance = (0, calculations_1.calcExpectedStableDebtTokenBalance)(principalBalance, previousIndex, bignumber_1.BigNumber.from(lastTimestamp), txTimestamp);
    const balanceIncrease = newPrincipalBalance.sub(principalBalance);
    const currentAvgStableRate = await stableDebtToken.getAverageStableRate();
    const stableRateAfter = await stableDebtToken.getUserStableRate(onBehalfOf);
    const [totalSupply] = await stableDebtToken.getSupplyData();
    if (debug)
        (0, exports.printStableDebtTokenEvents)(stableDebtToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [aToken.address, user.address, amount]);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', stableDebtToken, stableDebtToken.address, [
        constants_1.ZERO_ADDRESS,
        onBehalfOf,
        amount.add(balanceIncrease),
    ]);
    (0, helpers_1.matchEvent)(rcpt, 'Mint', stableDebtToken, stableDebtToken.address, [
        user.address,
        onBehalfOf,
        amount.add(balanceIncrease),
        newPrincipalBalance,
        balanceIncrease,
        stableRateAfter,
        currentAvgStableRate,
        totalSupply,
    ]);
    return rcpt;
};
exports.stableBorrow = stableBorrow;
const repayStableBorrow = async (pool, user, underlying, amountToConvert, onBehalfOf, debug = false) => {
    const amount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(underlying, amountToConvert);
    const { aTokenAddress, stableDebtTokenAddress } = await pool.getReserveData(underlying);
    const underlyingToken = types_1.IERC20__factory.connect(underlying, user.signer);
    const aToken = types_1.AToken__factory.connect(aTokenAddress, user.signer);
    const stableDebtToken = types_1.StableDebtToken__factory.connect(stableDebtTokenAddress, user.signer);
    const principalBalance = await stableDebtToken.principalBalanceOf(onBehalfOf);
    const previousIndex = await stableDebtToken.getUserStableRate(onBehalfOf);
    const lastTimestamp = await stableDebtToken.getUserLastUpdated(onBehalfOf);
    const tx = await pool.connect(user.signer).repay(underlying, amount, types_2.RateMode.Stable, onBehalfOf);
    const rcpt = await tx.wait();
    const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(rcpt);
    const newPrincipalBalance = (0, calculations_1.calcExpectedStableDebtTokenBalance)(principalBalance, previousIndex, bignumber_1.BigNumber.from(lastTimestamp), txTimestamp);
    const balanceIncrease = newPrincipalBalance.sub(principalBalance);
    const currentAvgStableRate = await stableDebtToken.getAverageStableRate();
    const stableRateAfter = await stableDebtToken.getUserStableRate(onBehalfOf);
    const [totalSupply] = await stableDebtToken.getSupplyData();
    if (debug)
        (0, exports.printStableDebtTokenEvents)(stableDebtToken, rcpt);
    (0, helpers_1.matchEvent)(rcpt, 'Transfer', underlyingToken, underlying, [user.address, aToken.address, amount]);
    if (balanceIncrease.gt(amount)) {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', stableDebtToken, stableDebtToken.address, [
            constants_1.ZERO_ADDRESS,
            onBehalfOf,
            balanceIncrease.sub(amount),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Mint', stableDebtToken, stableDebtToken.address, [
            onBehalfOf,
            onBehalfOf,
            balanceIncrease.sub(amount),
            newPrincipalBalance,
            balanceIncrease,
            stableRateAfter,
            currentAvgStableRate,
            totalSupply,
        ]);
    }
    else {
        (0, helpers_1.matchEvent)(rcpt, 'Transfer', stableDebtToken, stableDebtToken.address, [
            onBehalfOf,
            constants_1.ZERO_ADDRESS,
            amount.sub(balanceIncrease),
        ]);
        (0, helpers_1.matchEvent)(rcpt, 'Burn', stableDebtToken, stableDebtToken.address, [
            onBehalfOf,
            amount.sub(balanceIncrease),
            newPrincipalBalance,
            balanceIncrease,
            currentAvgStableRate,
            totalSupply,
        ]);
    }
    return rcpt;
};
exports.repayStableBorrow = repayStableBorrow;
const printATokenEvents = (aToken, receipt) => {
    for (const eventSig of ATOKEN_EVENTS) {
        const eventName = eventSig.sig.split('(')[0];
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == aToken.address);
        for (const rawEvent of rawEvents) {
            const rawParsed = aToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics);
            const parsed = [];
            let i = 0;
            for (const arg of eventSig.args) {
                parsed[i] = ['value', 'balanceIncrease'].includes(arg)
                    ? hardhat_1.ethers.utils.formatEther(rawParsed[arg])
                    : rawParsed[arg];
                i++;
            }
            console.log(`event ${eventName} ${parsed[0]} -> ${parsed[1]}: ${parsed.slice(2).join(' ')}`);
        }
    }
};
exports.printATokenEvents = printATokenEvents;
const getATokenEvent = (aToken, receipt, eventName) => {
    const eventSig = ATOKEN_EVENTS.find((item) => item.sig.split('(')[0] === eventName);
    const results = [];
    if (eventSig) {
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == aToken.address);
        for (const rawEvent of rawEvents) {
            results.push(aToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics));
        }
    }
    return results;
};
exports.getATokenEvent = getATokenEvent;
const printVariableDebtTokenEvents = (variableDebtToken, receipt) => {
    for (const eventSig of VARIABLE_DEBT_TOKEN_EVENTS) {
        const eventName = eventSig.sig.split('(')[0];
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == variableDebtToken.address);
        for (const rawEvent of rawEvents) {
            const rawParsed = variableDebtToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics);
            const parsed = [];
            let i = 0;
            for (const arg of eventSig.args) {
                parsed[i] = ['value', 'balanceIncrease'].includes(arg)
                    ? hardhat_1.ethers.utils.formatEther(rawParsed[arg])
                    : rawParsed[arg];
                i++;
            }
            console.log(`event ${eventName} ${parsed[0]} -> ${parsed[1]}: ${parsed.slice(2).join(' ')}`);
        }
    }
};
exports.printVariableDebtTokenEvents = printVariableDebtTokenEvents;
const getVariableDebtTokenEvent = (variableDebtToken, receipt, eventName) => {
    const eventSig = VARIABLE_DEBT_TOKEN_EVENTS.find((item) => item.sig.split('(')[0] === eventName);
    const results = [];
    if (eventSig) {
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == variableDebtToken.address);
        for (const rawEvent of rawEvents) {
            results.push(variableDebtToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics));
        }
    }
    return results;
};
exports.getVariableDebtTokenEvent = getVariableDebtTokenEvent;
const printStableDebtTokenEvents = (stableDebtToken, receipt) => {
    for (const eventSig of STABLE_DEBT_TOKEN_EVENTS) {
        const eventName = eventSig.sig.split('(')[0];
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == stableDebtToken.address);
        for (const rawEvent of rawEvents) {
            const rawParsed = stableDebtToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics);
            const parsed = [];
            let i = 0;
            for (const arg of eventSig.args) {
                parsed[i] = ['value', 'currentBalance', 'balanceIncrease'].includes(arg)
                    ? hardhat_1.ethers.utils.formatEther(rawParsed[arg])
                    : rawParsed[arg];
                i++;
            }
            console.log(`event ${eventName} ${parsed[0]} -> ${parsed[1]}: ${parsed.slice(2).join(' ')}`);
        }
    }
};
exports.printStableDebtTokenEvents = printStableDebtTokenEvents;
const getStableDebtTokenEvent = (stableDebtToken, receipt, eventName) => {
    const eventSig = STABLE_DEBT_TOKEN_EVENTS.find((item) => item.sig.split('(')[0] === eventName);
    const results = [];
    if (eventSig) {
        const encodedSig = hardhat_1.ethers.utils.keccak256(hardhat_1.ethers.utils.toUtf8Bytes(eventSig.sig));
        const rawEvents = receipt.logs.filter((log) => log.topics[0] === encodedSig && log.address == stableDebtToken.address);
        for (const rawEvent of rawEvents) {
            results.push(stableDebtToken.interface.decodeEventLog(eventName, rawEvent.data, rawEvent.topics));
        }
    }
    return results;
};
exports.getStableDebtTokenEvent = getStableDebtTokenEvent;
