"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const misc_utils_1 = require("../helpers/misc-utils");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const funds_1 = require("./helpers/utils/funds");
const make_suite_1 = require("./helpers/make-suite");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_2 = require("../types");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Interest Rate and Index Overflow', (testEnv) => {
    const { SAFECAST_UINT128_OVERFLOW } = types_1.ProtocolErrors;
    let mockToken;
    let mockStableDebtToken;
    let mockRateStrategy;
    let snap;
    before(async () => {
        const { pool, poolAdmin, configurator, dai, helpersContract, addressesProvider } = testEnv;
        mockToken = await new types_2.MintableERC20__factory(await (0, signer_1.getFirstSigner)()).deploy('MOCK', 'MOCK', '18');
        let stableDebtTokenImplementation = await new types_2.StableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        let variableDebtTokenImplementation = await new types_2.VariableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const aTokenImplementation = await new types_2.AToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        mockRateStrategy = await new types_2.MockReserveInterestRateStrategy__factory(await (0, signer_1.getFirstSigner)()).deploy(addressesProvider.address, 0, 0, 0, 0, 0, 0);
        // Init the reserve
        let initInputParams = [
            {
                aTokenImpl: aTokenImplementation.address,
                stableDebtTokenImpl: stableDebtTokenImplementation.address,
                variableDebtTokenImpl: variableDebtTokenImplementation.address,
                underlyingAssetDecimals: 18,
                interestRateStrategyAddress: mockRateStrategy.address,
                underlyingAsset: mockToken.address,
                treasury: constants_1.ZERO_ADDRESS,
                incentivesController: constants_1.ZERO_ADDRESS,
                aTokenName: 'AMOCK',
                aTokenSymbol: 'AMOCK',
                variableDebtTokenName: 'VMOCK',
                variableDebtTokenSymbol: 'VMOCK',
                stableDebtTokenName: 'SMOCK',
                stableDebtTokenSymbol: 'SMOCK',
                params: '0x10',
            },
        ];
        await configurator.connect(poolAdmin.signer).initReserves(initInputParams);
        // Configuration
        const daiReserveConfigurationData = await helpersContract.getReserveConfigurationData(dai.address);
        const maxCap = 68719476735;
        const inputParams = [
            {
                asset: mockToken.address,
                baseLTV: daiReserveConfigurationData.ltv,
                liquidationThreshold: daiReserveConfigurationData.liquidationThreshold,
                liquidationBonus: daiReserveConfigurationData.liquidationBonus,
                reserveFactor: daiReserveConfigurationData.reserveFactor,
                borrowCap: maxCap,
                supplyCap: maxCap,
                stableBorrowingEnabled: true,
                borrowingEnabled: true,
            },
        ];
        const i = 0;
        await configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(inputParams[i].asset, inputParams[i].baseLTV, inputParams[i].liquidationThreshold, inputParams[i].liquidationBonus);
        await configurator.connect(poolAdmin.signer).setReserveBorrowing(inputParams[i].asset, true);
        await configurator
            .connect(poolAdmin.signer)
            .setSupplyCap(inputParams[i].asset, inputParams[i].supplyCap);
        await configurator
            .connect(poolAdmin.signer)
            .setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);
        const reserveData = await pool.getReserveData(mockToken.address);
        mockStableDebtToken = types_2.StableDebtToken__factory.connect(reserveData.stableDebtTokenAddress, await (0, signer_1.getFirstSigner)());
    });
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('ReserveLogic `updateInterestRates` with nextLiquidityRate > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], faucetMintable } = testEnv;
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await mockRateStrategy.setLiquidityRate(constants_1.MAX_UINT_AMOUNT);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('ReserveLogic `updateInterestRates` with nextStableRate > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], faucetMintable } = testEnv;
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await mockRateStrategy.setStableBorrowRate(constants_1.MAX_UINT_AMOUNT);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('ReserveLogic `updateInterestRates` with nextVariableRate > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], faucetMintable } = testEnv;
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await mockRateStrategy.setVariableBorrowRate(constants_1.MAX_UINT_AMOUNT);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('ReserveLogic `_updateIndexes` with nextLiquidityIndex > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], dai, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0);
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0);
        // Set liquidity rate to max
        await mockRateStrategy.setLiquidityRate(ethers_1.BigNumber.from(2).pow(128).sub(1));
        // Borrow funds
        await pool
            .connect(user.signer)
            .borrow(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100'), types_1.RateMode.Variable, 0, user.address);
        // set borrow rate to max
        await mockRateStrategy.setVariableBorrowRate(ethers_1.BigNumber.from(2).pow(128).sub(1));
        // Increase time such that the next liquidity index overflow because of interest
        await (0, deploy_v3_1.increaseTime)(60 * 60 * 24 * 500);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('ReserveLogic `_updateIndexes` with nextVariableBorrowIndex > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], dai, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'), user.address, 0);
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0);
        await mockRateStrategy.setLiquidityRate(ethers_1.BigNumber.from(10).pow(27));
        await mockRateStrategy.setVariableBorrowRate(ethers_1.BigNumber.from(2).pow(110).sub(1));
        await pool
            .connect(user.signer)
            .borrow(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100'), types_1.RateMode.Variable, 0, user.address);
        await (0, deploy_v3_1.increaseTime)(60 * 60 * 24 * 365);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('ReserveLogic `cumulateToLiquidityIndex` with liquidityIndex > type(uint128).max (revert expected)', async () => {
        const { pool, users: [user], dai, aDai, addressesProvider, faucetMintable } = testEnv;
        const toBorrow = ethers_1.BigNumber.from(2).pow(80);
        await faucetMintable.mint(dai.address, user.address, toBorrow.add(1));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(dai.address, 1, user.address, 0);
        await dai.connect(user.signer).transfer(aDai.address, toBorrow);
        const mockFlashLoan = await new types_2.MockFlashLoanReceiver__factory(await (0, signer_1.getFirstSigner)()).deploy(addressesProvider.address);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .flashLoan(mockFlashLoan.address, [dai.address], [toBorrow], [types_1.RateMode.None], user.address, '0x00', 0)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
    it('StableDebtToken `mint` with nextStableRate > type(uint128).max (revert expected)', async () => {
        const { deployer, pool, users: [user], } = testEnv;
        // Impersonate the Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const rate = ethers_1.BigNumber.from(2).pow(128); // Max + 1
        await (0, chai_1.expect)(mockStableDebtToken
            .connect(poolSigner)
            .mint(user.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockStableDebtToken.address, '100'), rate)).to.be.revertedWith(SAFECAST_UINT128_OVERFLOW);
    });
});
