"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require('chai');
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
const helpers_1 = require("./helpers/utils/helpers");
const actions_1 = require("./helpers/actions");
const test_1 = __importDefault(require("@aave/deploy-v3/dist/markets/test"));
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const calculations_1 = require("./helpers/utils/calculations");
const expectEqual = (actual, expected) => {
    expect(actual).to.be.almostEqualOrEqual(expected);
};
(0, make_suite_1.makeSuite)('Isolation mode', (testEnv) => {
    const ISOLATED_COLLATERAL_SUPPLIER_ROLE = ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('ISOLATED_COLLATERAL_SUPPLIER'));
    const depositAmount = ethers_1.utils.parseEther('1000');
    const borrowAmount = ethers_1.utils.parseEther('200');
    const ceilingAmount = '10000';
    const withdrawAmount = ethers_1.utils.parseEther('100');
    const feeBps = ethers_1.BigNumber.from(30);
    const denominatorBP = ethers_1.BigNumber.from(10000);
    const mintAmount = withdrawAmount.mul(denominatorBP.sub(feeBps)).div(denominatorBP);
    const bridgeProtocolFeeBps = ethers_1.BigNumber.from(2000);
    const { ASSET_NOT_BORROWABLE_IN_ISOLATION, DEBT_CEILING_EXCEEDED, USER_IN_ISOLATION_MODE_OR_LTV_ZERO, } = types_1.ProtocolErrors;
    let aclManager;
    let oracleBaseDecimals;
    let snapshot;
    before(async () => {
        const { configurator, dai, usdc, aave, users, poolAdmin } = testEnv;
        calculations_1.configuration.reservesParams = test_1.default.ReservesConfig;
        //set debt ceiling for aave
        await configurator.setDebtCeiling(aave.address, ceilingAmount);
        //set category 1 for DAI and USDC
        await configurator.setBorrowableInIsolation(dai.address, true);
        await configurator.setBorrowableInIsolation(usdc.address, true);
        // configure bridge
        aclManager = await (0, contract_getters_1.getACLManager)();
        await (0, deploy_v3_1.waitForTx)(await aclManager.addBridge(users[2].address));
        await (0, deploy_v3_1.waitForTx)(await configurator.connect(poolAdmin.signer).updateBridgeProtocolFee(bridgeProtocolFeeBps));
        // configure oracle
        const { aaveOracle, addressesProvider, oracle } = testEnv;
        oracleBaseDecimals = (await aaveOracle.BASE_CURRENCY_UNIT()).toString().length - 1;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
        snapshot = await (0, deploy_v3_1.evmSnapshot)();
    });
    it('User 0 supply 1000 dai.', async () => {
        const { users, pool, dai, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, users[0].address, depositAmount);
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[0].signer).supply(dai.address, depositAmount, users[0].address, 0);
    });
    it('User 1 supply 2 aave. Checks that aave is not activated as collateral.', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { users, pool, aave, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(aave.address, users[1].address, ethers_1.utils.parseEther('2'));
        await aave.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(aave.address, ethers_1.utils.parseEther('2'), users[1].address, 0);
        const userData = await helpersContract.getUserReserveData(aave.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 1 as ISOLATED_COLLATERAL_SUPPLIER_ROLE supply 2 aave to user 2. Checks that aave is activated as isolated collateral.', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { users, pool, aave, helpersContract, deployer, faucetMintable } = testEnv;
        await faucetMintable.mint(aave.address, users[1].address, ethers_1.utils.parseEther('2'));
        await aave.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await aclManager
            .connect(deployer.signer)
            .grantRole(ISOLATED_COLLATERAL_SUPPLIER_ROLE, users[1].address);
        const hasRole = await aclManager
            .connect(users[1].address)
            .hasRole(ISOLATED_COLLATERAL_SUPPLIER_ROLE, users[1].address);
        expect(hasRole).to.be.eq(true);
        await pool
            .connect(users[1].signer)
            .supply(aave.address, ethers_1.utils.parseEther('2'), users[2].address, 0);
        const userData = await helpersContract.getUserReserveData(aave.address, users[2].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(true);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 1 supply 2 aave. Enables collateral. Checks that aave is activated as isolated collateral.', async () => {
        const { users, pool, aave, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(aave.address, users[1].address, ethers_1.utils.parseEther('2'));
        await aave.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(aave.address, ethers_1.utils.parseEther('2'), users[1].address, 0);
        await pool.connect(users[1].signer).setUserUseReserveAsCollateral(aave.address, true);
        const userData = await helpersContract.getUserReserveData(aave.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(true);
    });
    it('User 1 supply 1 eth. Checks that eth is NOT activated as collateral ', async () => {
        const { users, pool, weth, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(weth.address, users[1].address, ethers_1.utils.parseEther('1'));
        await weth.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(weth.address, ethers_1.utils.parseEther('1'), users[1].address, 0);
        const userData = await helpersContract.getUserReserveData(weth.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 1 tries to use eth as collateral (revert expected)', async () => {
        const { users, pool, weth, helpersContract } = testEnv;
        const userDataBefore = await helpersContract.getUserReserveData(weth.address, users[1].address);
        expect(userDataBefore.usageAsCollateralEnabled).to.be.eq(false);
        await expect(pool.connect(users[1].signer).setUserUseReserveAsCollateral(weth.address, true)).to.be.revertedWith(USER_IN_ISOLATION_MODE_OR_LTV_ZERO);
        const userDataAfter = await helpersContract.getUserReserveData(weth.address, users[1].address);
        expect(userDataAfter.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 2 deposit dai and aave, then tries to use aave as collateral (revert expected)', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { users: [, , user2], pool, dai, aave, helpersContract, faucetMintable, } = testEnv;
        await faucetMintable.mint(dai.address, user2.address, ethers_1.utils.parseEther('1'));
        await dai.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user2.signer).supply(dai.address, ethers_1.utils.parseEther('1'), user2.address, 0);
        await faucetMintable.mint(aave.address, user2.address, ethers_1.utils.parseEther('1'));
        await aave.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user2.signer).supply(aave.address, ethers_1.utils.parseEther('1'), user2.address, 0);
        const userDaiDataBefore = await helpersContract.getUserReserveData(dai.address, user2.address);
        expect(userDaiDataBefore.usageAsCollateralEnabled).to.be.eq(true);
        const userAaveDataBefore = await helpersContract.getUserReserveData(aave.address, user2.address);
        expect(userAaveDataBefore.usageAsCollateralEnabled).to.be.eq(false);
        await expect(pool.connect(user2.signer).setUserUseReserveAsCollateral(aave.address, true)).to.be.revertedWith(USER_IN_ISOLATION_MODE_OR_LTV_ZERO);
        const userDataAfter = await helpersContract.getUserReserveData(aave.address, user2.address);
        expect(userDataAfter.usageAsCollateralEnabled).to.be.eq(false);
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User 2 (as bridge) mint 100 unbacked dai to user 1. Checks that dai is NOT activated as collateral', async () => {
        const { users, riskAdmin, pool, configurator, dai, helpersContract } = testEnv;
        // configure unbacked cap for dai
        expect(await configurator.connect(riskAdmin.signer).setUnbackedMintCap(dai.address, '10'));
        expect(await configurator
            .connect(riskAdmin.signer)
            .setUnbackedMintCap(dai.address, constants_1.MAX_UNBACKED_MINT_CAP));
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.connect(users[2].signer).mintUnbacked(dai.address, mintAmount, users[1].address, 0));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const expectedDataAfter = (0, calculations_1.calcExpectedReserveDataAfterMintUnbacked)(mintAmount.toString(), reserveDataBefore, txTimestamp);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        expectEqual(reserveDataAfter, expectedDataAfter);
        const userData = await helpersContract.getUserReserveData(dai.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 2 (as bridge) mint 100 unbacked aave (isolated) to user 3. Checks that aave is NOT activated as collateral', async () => {
        const { users, riskAdmin, pool, configurator, aave, helpersContract } = testEnv;
        // configure unbacked cap for dai
        expect(await configurator.connect(riskAdmin.signer).setUnbackedMintCap(aave.address, '10'));
        expect(await configurator
            .connect(riskAdmin.signer)
            .setUnbackedMintCap(aave.address, constants_1.MAX_UNBACKED_MINT_CAP));
        const reserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(users[2].signer)
            .mintUnbacked(aave.address, mintAmount, users[3].address, 0));
        const { txTimestamp } = await (0, actions_1.getTxCostAndTimestamp)(tx);
        const expectedDataAfter = (0, calculations_1.calcExpectedReserveDataAfterMintUnbacked)(mintAmount.toString(), reserveDataBefore, txTimestamp);
        const reserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        expectEqual(reserveDataAfter, expectedDataAfter);
        const userData = await helpersContract.getUserReserveData(aave.address, users[3].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 2 supply 100 DAI, transfers to user 1. Checks that DAI is NOT activated as collateral for user 1', async () => {
        const { dai, aDai, users, pool, helpersContract, faucetMintable } = testEnv;
        const amount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(dai.address, users[2].address, amount);
        await dai.connect(users[2].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[2].signer).supply(dai.address, amount, users[2].address, 0);
        await aDai.connect(users[2].signer).transfer(users[1].address, amount);
        const userData = await helpersContract.getUserReserveData(dai.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 1 withdraws everything. User supplies WETH then AAVE. Checks AAVE is not enabled as collateral', async () => {
        const { dai, aave, weth, users, pool, helpersContract } = testEnv;
        await pool
            .connect(users[1].signer)
            .withdraw(weth.address, ethers_1.utils.parseEther('1'), users[1].address);
        await pool
            .connect(users[1].signer)
            .withdraw(aave.address, ethers_1.utils.parseEther('2'), users[1].address);
        await pool.connect(users[1].signer).withdraw(dai.address, constants_1.MAX_UINT_AMOUNT, users[1].address);
        const amount = ethers_1.utils.parseEther('1');
        await pool.connect(users[1].signer).supply(weth.address, amount, users[1].address, 0);
        await pool.connect(users[1].signer).supply(aave.address, amount, users[1].address, 0);
        const userData = await helpersContract.getUserReserveData(aave.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 2 supplies DAI, transfers to user 1. Checks DAI is enabled as collateral', async () => {
        const { dai, aDai, users, pool, helpersContract, faucetMintable } = testEnv;
        const amount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(dai.address, users[2].address, amount);
        await pool.connect(users[2].signer).supply(dai.address, amount, users[2].address, 0);
        await aDai.connect(users[2].signer).transfer(users[1].address, amount);
        const userData = await helpersContract.getUserReserveData(dai.address, users[1].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(true);
    });
    it('User 1 withdraws everything. User 2 supplies ETH, User 1 supplies AAVE, tries to borrow ETH (revert expected)', async () => {
        const { dai, aave, weth, users, pool, faucetMintable } = testEnv;
        await pool
            .connect(users[1].signer)
            .withdraw(weth.address, ethers_1.utils.parseEther('1'), users[1].address);
        await pool
            .connect(users[1].signer)
            .withdraw(aave.address, ethers_1.utils.parseEther('1'), users[1].address);
        await pool
            .connect(users[1].signer)
            .withdraw(dai.address, ethers_1.utils.parseEther('100'), users[1].address);
        const wethAmount = ethers_1.utils.parseEther('1');
        await faucetMintable.mint(weth.address, users[2].address, wethAmount);
        await weth.connect(users[2].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[2].signer).supply(weth.address, wethAmount, users[2].address, 0);
        const aaveAmount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(aave.address, users[1].address, aaveAmount);
        await aave.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[1].signer).supply(aave.address, aaveAmount, users[1].address, 0);
        await pool.connect(users[1].signer).setUserUseReserveAsCollateral(aave.address, true);
        await expect(pool
            .connect(users[1].signer)
            .borrow(weth.address, ethers_1.utils.parseEther('0.01'), '2', 0, users[1].address)).to.be.revertedWith(ASSET_NOT_BORROWABLE_IN_ISOLATION);
    });
    it('User 2 tries to borrow some ETH on behalf of User 1 (revert expected)', async () => {
        const { users, pool, dai, weth } = testEnv;
        await expect(pool
            .connect(users[2].signer)
            .borrow(weth.address, ethers_1.utils.parseEther('0.0000001'), types_1.RateMode.Variable, constants_1.AAVE_REFERRAL, users[1].address)).to.be.revertedWith(ASSET_NOT_BORROWABLE_IN_ISOLATION);
    });
    it('User 1 borrows 10 DAI. Check debt ceiling', async () => {
        const { dai, aave, users, pool } = testEnv;
        const borrowAmount = ethers_1.utils.parseEther('10');
        await expect(pool.connect(users[1].signer).borrow(dai.address, borrowAmount, '2', 0, users[1].address))
            .to.emit(pool, 'IsolationModeTotalDebtUpdated')
            .withArgs(aave.address, 1000);
        const reserveData = await pool.getReserveData(aave.address);
        expect(reserveData.isolationModeTotalDebt).to.be.eq('1000');
    });
    it('User 3 deposits 100 AAVE, borrows 10 DAI. Check debt ceiling', async () => {
        const { dai, aave, users, pool, faucetMintable } = testEnv;
        const aaveAmount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(aave.address, users[3].address, aaveAmount);
        await aave.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[3].signer).supply(aave.address, aaveAmount, users[3].address, 0);
        await pool.connect(users[3].signer).setUserUseReserveAsCollateral(aave.address, true);
        const borrowAmount = ethers_1.utils.parseEther('10');
        await expect(pool.connect(users[3].signer).borrow(dai.address, borrowAmount, '2', 0, users[3].address))
            .to.emit(pool, 'IsolationModeTotalDebtUpdated')
            .withArgs(aave.address, 2000);
        const reserveData = await pool.getReserveData(aave.address);
        expect(reserveData.isolationModeTotalDebt).to.be.eq('2000');
    });
    it('User 4 deposits 500 AAVE, tries to borrow past the debt ceiling (revert expected)', async () => {
        const { dai, aave, users, pool, faucetMintable } = testEnv;
        const aaveAmount = ethers_1.utils.parseEther('500');
        await faucetMintable.mint(aave.address, users[3].address, aaveAmount);
        await aave.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[3].signer).supply(aave.address, aaveAmount, users[3].address, 0);
        await pool.connect(users[3].signer).setUserUseReserveAsCollateral(aave.address, true);
        const borrowAmount = ethers_1.utils.parseEther('100');
        await expect(pool.connect(users[3].signer).borrow(dai.address, borrowAmount, '2', 0, users[3].address)).to.be.revertedWith(DEBT_CEILING_EXCEEDED);
    });
    it('Push time forward one year. User 1, User 3 repay debt. Ensure debt ceiling is 0', async () => {
        const { dai, aave, users, pool, faucetMintable } = testEnv;
        await (0, deploy_v3_1.increaseTime)(60 * 60 * 24 * 365);
        const mintAmount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(dai.address, users[3].address, mintAmount);
        await dai.connect(users[3].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[3].signer).repay(dai.address, constants_1.MAX_UINT_AMOUNT, '2', users[3].address);
        await faucetMintable.mint(dai.address, users[1].address, mintAmount);
        await dai.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await expect(pool.connect(users[1].signer).repay(dai.address, constants_1.MAX_UINT_AMOUNT, '2', users[1].address))
            .to.emit(pool, 'IsolationModeTotalDebtUpdated')
            .withArgs(aave.address, 0);
        const reserveData = await pool.getReserveData(aave.address);
        expect(reserveData.isolationModeTotalDebt).to.be.eq('0');
    });
    it('Perform liquidation of isolation mode asset', async () => {
        // We need to look at how the user getting liquidated was positioned. If the asset is isolation mode, then it needs to impact that as well
        const { dai, aave, oracle, faucetMintable, helpersContract, users: [, , , , borrower, liquidator], pool, } = testEnv;
        // Fund depositor and liquidator
        const liquidatorAmount = ethers_1.utils.parseUnits('1000', 18);
        await faucetMintable.mint(dai.address, liquidator.address, liquidatorAmount.mul(2));
        await dai.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(liquidator.signer)
            .supply(dai.address, liquidatorAmount, liquidator.address, 0);
        const userGlobalDataBefore = await pool.getUserAccountData(borrower.address);
        expect(userGlobalDataBefore.totalCollateralBase).to.be.eq(0);
        const depositAmount = ethers_1.utils.parseUnits('1', 18);
        await faucetMintable.mint(aave.address, borrower.address, depositAmount);
        await aave.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(borrower.signer).supply(aave.address, depositAmount, borrower.address, 0);
        await pool.connect(borrower.signer).setUserUseReserveAsCollateral(aave.address, true);
        const userData = await helpersContract.getUserReserveData(aave.address, borrower.address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(true);
        const borrowAmount = ethers_1.utils.parseUnits('50', 18);
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Variable, '0', borrower.address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.mul(10));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        expect(userGlobalData.healthFactor).to.be.lt(ethers_1.utils.parseEther('1'));
        const isolationModeTotalDebtBefore = (await pool.getReserveData(aave.address))
            .isolationModeTotalDebt;
        const expectedAmountAfter = isolationModeTotalDebtBefore.sub(borrowAmount.div(2).div(ethers_1.BigNumber.from(10).pow(16)));
        await expect(pool
            .connect(liquidator.signer)
            .liquidationCall(aave.address, dai.address, borrower.address, borrowAmount.div(2), false))
            .to.emit(pool, 'IsolationModeTotalDebtUpdated')
            .withArgs(aave.address, expectedAmountAfter);
        const isolationModeTotalDebtAfter = (await pool.getReserveData(aave.address))
            .isolationModeTotalDebt;
        expect(isolationModeTotalDebtAfter).to.be.eq(expectedAmountAfter);
    });
    it('User 5 supplies weth and dai. User 6 supplies AAVE and transfers to User 5', async () => {
        const { weth, dai, aave, aAave, users, pool, helpersContract, faucetMintable } = testEnv;
        const wethAmount = ethers_1.utils.parseEther('1');
        await faucetMintable.mint(weth.address, users[5].address, wethAmount);
        await weth.connect(users[5].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[5].signer).supply(weth.address, wethAmount, users[5].address, 0);
        const daiAmount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(dai.address, users[5].address, daiAmount);
        await dai.connect(users[5].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[5].signer).supply(dai.address, daiAmount, users[5].address, 0);
        const aaveAmount = ethers_1.utils.parseEther('100');
        await faucetMintable.mint(aave.address, users[6].address, aaveAmount);
        await aave.connect(users[6].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[6].signer).supply(aave.address, aaveAmount, users[6].address, 0);
        await aAave.connect(users[6].signer).transfer(users[5].address, aaveAmount);
        const wethUserData = await helpersContract.getUserReserveData(weth.address, users[5].address);
        const daiUserData = await helpersContract.getUserReserveData(dai.address, users[5].address);
        const aaveUserData = await helpersContract.getUserReserveData(aave.address, users[5].address);
        expect(daiUserData.usageAsCollateralEnabled).to.be.eq(true);
        expect(wethUserData.usageAsCollateralEnabled).to.be.eq(true);
        expect(aaveUserData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 5 supplies isolation mode asset is liquidated by User 6', async () => {
        const { dai, aave, users, pool, helpersContract, oracle, faucetMintable } = testEnv;
        await (0, deploy_v3_1.evmRevert)(snapshot);
        snapshot = await (0, deploy_v3_1.evmSnapshot)();
        // supply dai as user 6, so user 5 can borrow
        const daiAmount = ethers_1.utils.parseEther('700');
        await faucetMintable.mint(dai.address, users[6].address, daiAmount);
        await dai.connect(users[6].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[6].signer).supply(dai.address, daiAmount, users[6].address, 0);
        const aaveAmount = ethers_1.utils.parseEther('.3');
        await faucetMintable.mint(aave.address, users[5].address, aaveAmount);
        await aave.connect(users[5].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[5].signer).supply(aave.address, aaveAmount, users[5].address, 0);
        await pool.connect(users[5].signer).setUserUseReserveAsCollateral(aave.address, true);
        // borrow with health factor just above 1
        const userGlobalData = await pool.getUserAccountData(users[5].address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        let amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice.toString()).percentMul(9999).toString());
        await pool
            .connect(users[5].signer)
            .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Variable, 0, users[5].address);
        // advance time so health factor is less than one and liquidate
        await (0, deploy_v3_1.advanceTimeAndBlock)(86400 * 365 * 100);
        const userDaiReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, users[5].address);
        const amountToLiquidate = userDaiReserveDataBefore.currentVariableDebt.div(2);
        await faucetMintable.mint(dai.address, users[6].address, daiAmount);
        await dai.connect(users[6].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const tx = await pool
            .connect(users[6].signer)
            .liquidationCall(aave.address, dai.address, users[5].address, amountToLiquidate, true);
        await tx.wait();
        // confirm the newly received aave tokens (in isolation mode) cannot be used as collateral
        const userData = await helpersContract.getUserReserveData(aave.address, users[6].address);
        expect(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 1 supplies AAVE and borrows DAI in isolation, AAVE exits isolation. User 1 repay and withdraw. AAVE enters isolation again', async () => {
        await (0, deploy_v3_1.evmRevert)(snapshot);
        const { pool, configurator, helpersContract, users, poolAdmin, dai, aave, faucetMintable } = testEnv;
        // Depositor supplies DAI
        await faucetMintable.mint(dai.address, users[0].address, depositAmount);
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[0].signer).supply(dai.address, depositAmount, users[0].address, 0);
        // User 1 supplies AAVE in isolation mode
        const aaveAmountToSupply = ethers_1.utils.parseEther('2');
        await faucetMintable.mint(aave.address, users[1].address, aaveAmountToSupply);
        await aave.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(aave.address, aaveAmountToSupply, users[1].address, 0);
        await pool.connect(users[1].signer).setUserUseReserveAsCollateral(aave.address, true);
        // User 1 borrows DAI against isolated AAVE
        const { isolationModeTotalDebt: isolationModeTotalDebtBeforeBorrow } = await pool.getReserveData(aave.address);
        const isolationModeTotalDebtAfterBorrow = isolationModeTotalDebtBeforeBorrow.add(1000);
        const daiAmountToBorrow = ethers_1.utils.parseEther('10');
        expect(await pool
            .connect(users[1].signer)
            .borrow(dai.address, daiAmountToBorrow, '2', 0, users[1].address))
            .to.emit(pool, 'IsolationModeTotalDebtUpdated')
            .withArgs(aave.address, isolationModeTotalDebtAfterBorrow);
        const reserveDataAfterBorrow = await pool.getReserveData(aave.address);
        expect(reserveDataAfterBorrow.isolationModeTotalDebt).to.be.eq(isolationModeTotalDebtAfterBorrow);
        // AAVE exits isolation mode (debt ceiling = 0)
        const oldAaveDebtCeiling = await helpersContract.getDebtCeiling(aave.address);
        const newAaveDebtCeiling = 0;
        expect(await configurator.connect(poolAdmin.signer).setDebtCeiling(aave.address, newAaveDebtCeiling))
            .to.emit(configurator, 'DebtCeilingChanged')
            .withArgs(aave.address, oldAaveDebtCeiling, newAaveDebtCeiling);
        expect(await helpersContract.getDebtCeiling(aave.address)).to.be.eq(newAaveDebtCeiling);
        expect((await pool.getReserveData(aave.address)).isolationModeTotalDebt).to.be.eq(0, 'isolationModeTotalDebt when entering isolation mode');
        // User 1 borrows 1 DAI
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, ethers_1.utils.parseEther('1'), '2', 0, users[1].address);
        // User 1 repays debt and withdraw
        await faucetMintable.mint(dai.address, users[1].address, ethers_1.utils.parseEther('20'));
        await dai.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[1].signer).repay(dai.address, constants_1.MAX_UINT_AMOUNT, '2', users[1].address);
        await pool.connect(users[1].signer).withdraw(aave.address, constants_1.MAX_UINT_AMOUNT, users[1].address);
        // AAVE enters isolation mode again
        expect(await configurator.connect(poolAdmin.signer).setDebtCeiling(aave.address, 100))
            .to.emit(configurator, 'DebtCeilingChanged')
            .withArgs(aave.address, 0, 100);
        expect(await helpersContract.getDebtCeiling(aave.address)).to.be.eq(100);
        expect((await pool.getReserveData(aave.address)).isolationModeTotalDebt).to.be.eq(0, 'isolationModeTotalDebt when entering isolation mode');
    });
});
