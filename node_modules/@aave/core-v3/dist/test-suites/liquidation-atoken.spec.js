"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MockATokenRepayment__factory_1 = require("./../types/factories/mocks/tokens/MockATokenRepayment__factory");
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const calculations_1 = require("./helpers/utils/calculations");
const helpers_1 = require("./helpers/utils/helpers");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Pool Liquidation: Liquidator receiving aToken', (testEnv) => {
    const { HEALTH_FACTOR_NOT_BELOW_THRESHOLD, INVALID_HF, SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER, COLLATERAL_CANNOT_BE_LIQUIDATED, } = types_1.ProtocolErrors;
    let oracleBaseDecimals;
    before(async () => {
        const { aaveOracle, addressesProvider, oracle, deployer, pool, configurator, aDai, dai } = testEnv;
        oracleBaseDecimals = (await (await aaveOracle.BASE_CURRENCY_UNIT()).toString().length) - 1;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
        const aTokenRepayImpl = await new MockATokenRepayment__factory_1.MockATokenRepayment__factory(deployer.signer).deploy(pool.address);
        await configurator.updateAToken({
            asset: dai.address,
            treasury: await aDai.RESERVE_TREASURY_ADDRESS(),
            incentivesController: await aDai.getIncentivesController(),
            name: await aDai.name(),
            symbol: await aDai.symbol(),
            implementation: aTokenRepayImpl.address,
            params: '0x',
        });
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('Deposits WETH, borrows DAI/Check liquidation fails because health factor is above 1', async () => {
        const { dai, weth, users: [depositor, borrower], pool, oracle, faucetMintable, } = testEnv;
        //mints DAI to depositor
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        //approve protocol to access depositor wallet
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 1 deposits DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, amountDAItoDeposit, depositor.address, '0');
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.3');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, amountETHtoDeposit);
        //approve protocol to access borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 2 deposits WETH
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //user 2 borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        const amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice.toString()).percentMul(9500).toString());
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Variable, '0', borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataAfter.currentLiquidationThreshold).to.be.equal(8250, 'Invalid liquidation threshold');
        //someone tries to liquidate user 2
        await (0, chai_1.expect)(pool.liquidationCall(weth.address, dai.address, borrower.address, 1, true)).to.be.revertedWith(HEALTH_FACTOR_NOT_BELOW_THRESHOLD);
    });
    it('Drop the health factor below 1', async () => {
        const { dai, users: [, borrower], pool, oracle, aaveOracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(11500));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.lt(constants_1.oneEther, INVALID_HF);
    });
    it('Tries to liquidate a different currency than the loan principal (revert expected)', async () => {
        const { pool, users: [, borrower], weth, } = testEnv;
        //user 2 tries to borrow
        await (0, chai_1.expect)(pool.liquidationCall(weth.address, weth.address, borrower.address, constants_1.oneEther, true)).to.be.revertedWith(SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER);
    });
    it('Tries to liquidate a different collateral than the borrower collateral (revert expected)', async () => {
        const { pool, dai, users: [, borrower], } = testEnv;
        await (0, chai_1.expect)(pool.liquidationCall(dai.address, dai.address, borrower.address, constants_1.oneEther, true)).to.be.revertedWith(COLLATERAL_CANNOT_BE_LIQUIDATED);
    });
    it('Liquidates the borrow', async () => {
        const { pool, dai, aDai, weth, users: [, borrower], oracle, helpersContract, deployer, faucetMintable } = testEnv;
        //mints dai to the caller
        await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        //approve protocol to access depositor wallet
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const userWethReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, weth.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        // The supply is the same, but there should be a change in who has what. The liquidator should have received what the borrower lost.
        const tx = await pool.liquidationCall(weth.address, dai.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const userWethReserveDataAfter = await helpersContract.getUserReserveData(weth.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(10500)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        (0, chai_1.expect)(expectedCollateralLiquidated).to.be.closeTo(userWethReserveDataBefore.currentATokenBalance.sub(userWethReserveDataAfter.currentATokenBalance), 2, 'Invalid collateral amount liquidated');
        if (!tx.blockNumber) {
            (0, chai_1.expect)(false, 'Invalid block number');
            return;
        }
        const txTimestamp = ethers_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
        const variableDebtBeforeTx = (0, calculations_1.calcExpectedVariableDebtTokenBalance)(daiReserveDataBefore, userReserveDataBefore, txTimestamp);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(constants_1.oneEther, 'Invalid health factor');
        (0, chai_1.expect)(userReserveDataAfter.currentVariableDebt).to.be.closeTo(variableDebtBeforeTx.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(daiReserveDataAfter.totalLiquidity).to.be.closeTo(daiReserveDataBefore.totalLiquidity.add(amountToLiquidate), 2, 'Invalid principal total liquidity');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.gte(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.lt(daiReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        // We need the scaled balances here
        (0, chai_1.expect)(ethReserveDataAfter.totalLiquidity).to.be.closeTo(ethReserveDataBefore.totalLiquidity, 2, 'Invalid collateral total liquidity');
        (0, chai_1.expect)((await helpersContract.getUserReserveData(weth.address, deployer.address))
            .usageAsCollateralEnabled).to.be.true;
        // check handleRepayment function is correctly called
        await (0, chai_1.expect)(tx)
            .to.emit(MockATokenRepayment__factory_1.MockATokenRepayment__factory.connect(aDai.address, borrower.signer), 'MockRepayment')
            .withArgs(deployer.address, borrower.address, amountToLiquidate);
    });
    it('User 3 deposits 2000 USDC, user 4 0.12 WETH, user 4 borrows - drops HF, liquidates the borrow', async () => {
        const { users: [, , , depositor, borrower], pool, usdc, oracle, weth, helpersContract, faucetMintable, deployer } = testEnv;
        //mints USDC to depositor
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '2000'));
        //approve protocol to access depositor wallet
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 3 deposits 1000 USDC
        const amountUSDCtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '2000');
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, amountUSDCtoDeposit, depositor.address, '0');
        //user 4 deposits ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.12');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, amountETHtoDeposit);
        //approve protocol to access borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //user 4 borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        const amountUSDCToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, userGlobalData.availableBorrowsBase.div(usdcPrice).percentMul(9502).toString());
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, amountUSDCToBorrow, types_1.RateMode.Stable, '0', borrower.address);
        //drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(11200));
        //mints dai to the liquidator
        await faucetMintable.mint(usdc.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access depositor wallet
        await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const userWethReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, weth.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        await pool.liquidationCall(weth.address, usdc.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const userWethReserveDataAfter = await helpersContract.getUserReserveData(weth.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(usdc.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(10500)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        (0, chai_1.expect)(expectedCollateralLiquidated).to.be.eq(userWethReserveDataBefore.currentATokenBalance.sub(userWethReserveDataAfter.currentATokenBalance), 'Invalid collateral amount liquidated');
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(constants_1.oneEther, 'Invalid health factor');
        (0, chai_1.expect)(userReserveDataAfter.currentStableDebt).to.be.closeTo(userReserveDataBefore.currentStableDebt.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(usdcReserveDataAfter.totalLiquidity).to.be.closeTo(usdcReserveDataBefore.totalLiquidity.add(amountToLiquidate), 2, 'Invalid principal total liquidity');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(usdcReserveDataAfter.liquidityIndex).to.be.gte(usdcReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(usdcReserveDataAfter.liquidityRate).to.be.lt(usdcReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.totalLiquidity).to.be.closeTo(ethReserveDataBefore.totalLiquidity, 2, 'Invalid collateral total liquidity');
    });
});
