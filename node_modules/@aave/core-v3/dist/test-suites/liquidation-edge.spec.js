"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Pool Liquidation: Edge cases', (testEnv) => {
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    before(async () => {
        const { addressesProvider, oracle } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('ValidationLogic `executeLiquidationCall` where user has variable and stable debt, but variable debt is insufficient to cover the full liquidation amount', async () => {
        const { pool, users, dai, weth, oracle, faucetMintable } = testEnv;
        const depositor = users[0];
        const borrower = users[1];
        // Deposit dai
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000000'));
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000'), depositor.address, 0);
        // Deposit eth, borrow dai
        await faucetMintable.mint(weth.address, borrower.address, ethers_1.utils.parseEther('0.9'));
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, ethers_1.utils.parseEther('0.9'), borrower.address, 0);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentDiv('2700'));
        // Borrow
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '500'), types_1.RateMode.Stable, 0, borrower.address);
        // Borrow
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '220'), types_1.RateMode.Variable, 0, borrower.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(60000));
        (0, chai_1.expect)(await pool
            .connect(depositor.signer)
            .liquidationCall(weth.address, dai.address, borrower.address, constants_1.MAX_UINT_AMOUNT, false));
    });
    it('Liquidation repay asset completely, asset should not be set as borrowed anymore', async () => {
        const { pool, users, dai, usdc, weth, oracle, faucetMintable } = testEnv;
        const depositor = users[0];
        const borrower = users[1];
        // Deposit dai
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000000'));
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000'), depositor.address, 0);
        // Deposit usdc
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'), depositor.address, 0);
        // Deposit eth, borrow dai
        await faucetMintable.mint(weth.address, borrower.address, ethers_1.utils.parseEther('0.9'));
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, ethers_1.utils.parseEther('0.9'), borrower.address, 0);
        // Borrow usdc
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'), types_1.RateMode.Variable, 0, borrower.address);
        // Borrow dai stable
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100'), types_1.RateMode.Stable, 0, borrower.address);
        // Borrow dai variable
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100'), types_1.RateMode.Variable, 0, borrower.address);
        // Increase usdc price to allow liquidation
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        await oracle.setAssetPrice(usdc.address, usdcPrice.mul(10));
        const daiData = await pool.getReserveData(dai.address);
        const variableDebtToken = deploy_v3_1.VariableDebtToken__factory.connect(daiData.variableDebtTokenAddress, depositor.signer);
        const stableDebtToken = deploy_v3_1.StableDebtToken__factory.connect(daiData.stableDebtTokenAddress, depositor.signer);
        (0, chai_1.expect)(await variableDebtToken.balanceOf(borrower.address)).to.be.gt(0);
        (0, chai_1.expect)(await stableDebtToken.balanceOf(borrower.address)).to.be.gt(0);
        const userConfigBefore = ethers_1.BigNumber.from((await pool.getUserConfiguration(borrower.address)).data);
        (0, chai_1.expect)(await pool
            .connect(depositor.signer)
            .liquidationCall(weth.address, dai.address, borrower.address, constants_1.MAX_UINT_AMOUNT, false));
        const userConfigAfter = ethers_1.BigNumber.from((await pool.getUserConfiguration(borrower.address)).data);
        const isBorrowing = (conf, id) => conf
            .div(ethers_1.BigNumber.from(2).pow(ethers_1.BigNumber.from(id).mul(2)))
            .and(1)
            .gt(0);
        (0, chai_1.expect)(await variableDebtToken.balanceOf(borrower.address)).to.be.eq(0);
        (0, chai_1.expect)(await stableDebtToken.balanceOf(borrower.address)).to.be.eq(0);
        (0, chai_1.expect)(isBorrowing(userConfigBefore, daiData.id)).to.be.true;
        (0, chai_1.expect)(isBorrowing(userConfigAfter, daiData.id)).to.be.false;
    });
    it('Liquidate the whole WETH collateral with 10% liquidation fee, asset should not be set as collateralized anymore', async () => {
        const { pool, users, dai, usdc, weth, oracle, configurator, faucetMintable } = testEnv;
        await configurator.setLiquidationProtocolFee(weth.address, '1000'); // 10%
        const depositor = users[0];
        const borrower = users[1];
        // Deposit dai
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000000'));
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000'), depositor.address, 0);
        // Deposit usdc
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000000'));
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'), depositor.address, 0);
        // Deposit eth, borrow dai
        await faucetMintable.mint(weth.address, borrower.address, ethers_1.utils.parseEther('0.9'));
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, ethers_1.utils.parseEther('0.9'), borrower.address, 0);
        // Borrow usdc
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'), types_1.RateMode.Variable, 0, borrower.address);
        // Borrow dai stable
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100'), types_1.RateMode.Stable, 0, borrower.address);
        // Borrow dai variable
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100'), types_1.RateMode.Variable, 0, borrower.address);
        // HF = (0.9 * 0.85) / (1000 * 0.0005 + 100 * 0.0005 + 100 * 0.0005) = 1.275
        // Increase usdc price to allow liquidation
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        await oracle.setAssetPrice(usdc.address, usdcPrice.mul(10));
        // HF = (0.9 * 0.85) / (1000 * 0.005 + 100 * 0.0005 + 100 * 0.0005) = 0.15
        //
        // close factor = 1
        // $WETH_collateral = 0.9
        // $USDC_debt = 1000 * 0.005 = 5
        const wethData = await pool.getReserveData(weth.address);
        const aWETHToken = deploy_v3_1.AToken__factory.connect(wethData.aTokenAddress, depositor.signer);
        (0, chai_1.expect)(await aWETHToken.balanceOf(borrower.address)).to.be.gt(0);
        const userConfigBefore = ethers_1.BigNumber.from((await pool.getUserConfiguration(borrower.address)).data);
        (0, chai_1.expect)(await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(depositor.signer)
            .liquidationCall(weth.address, usdc.address, borrower.address, constants_1.MAX_UINT_AMOUNT, false));
        const userConfigAfter = ethers_1.BigNumber.from((await pool.getUserConfiguration(borrower.address)).data);
        const isUsingAsCollateral = (conf, id) => conf
            .div(ethers_1.BigNumber.from(2).pow(ethers_1.BigNumber.from(id).mul(2).add(1)))
            .and(1)
            .gt(0);
        (0, chai_1.expect)(await aWETHToken.balanceOf(borrower.address)).to.be.eq(0);
        (0, chai_1.expect)(isUsingAsCollateral(userConfigBefore, wethData.id)).to.be.true;
        (0, chai_1.expect)(isUsingAsCollateral(userConfigAfter, wethData.id)).to.be.false;
    });
});
