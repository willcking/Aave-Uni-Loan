"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const calculations_1 = require("./helpers/utils/calculations");
const helpers_1 = require("./helpers/utils/helpers");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Pool Liquidation: Liquidates borrows in eMode through interest', (testEnv) => {
    const { INVALID_HF } = types_1.ProtocolErrors;
    const CATEGORY = {
        id: ethers_1.BigNumber.from('1'),
        ltv: ethers_1.BigNumber.from('9800'),
        lt: ethers_1.BigNumber.from('9850'),
        lb: ethers_1.BigNumber.from('10100'),
        oracle: constants_1.ZERO_ADDRESS,
        label: 'STABLECOINS',
    };
    before(async () => {
        const { addressesProvider, oracle } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('Adds category id 1 (stablecoins)', async () => {
        const { configurator, pool, poolAdmin } = testEnv;
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(CATEGORY.id, CATEGORY.ltv, CATEGORY.lt, CATEGORY.lb, CATEGORY.oracle, CATEGORY.label));
        const categoryData = await pool.getEModeCategoryData(CATEGORY.id);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(CATEGORY.ltv, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(CATEGORY.lt, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(CATEGORY.lb, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(CATEGORY.oracle, 'invalid eMode category price source');
    });
    it('Add DAI and USDC to category id 1', async () => {
        const { configurator, poolAdmin, dai, usdc } = testEnv;
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, CATEGORY.id));
        (0, chai_1.expect)(await configurator.connect(poolAdmin.signer).setAssetEModeCategory(usdc.address, CATEGORY.id));
    });
    it('Someone funds the DAI pool', async () => {
        const { pool, users: [daiFunder], dai, faucetMintable } = testEnv;
        const supplyAmount = ethers_1.utils.parseUnits('10000', 18);
        await faucetMintable.mint(dai.address, daiFunder.address, supplyAmount);
        await dai.connect(daiFunder.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(daiFunder.signer).supply(dai.address, supplyAmount, daiFunder.address, 0);
    });
    it('Deposit USDC with eMode', async () => {
        const { pool, users: [, borrower], usdc, faucetMintable } = testEnv;
        await faucetMintable.mint(usdc.address, borrower.address, ethers_1.utils.parseUnits('10000', 6));
        await usdc.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .supply(usdc.address, ethers_1.utils.parseUnits('10000', 6), borrower.address, 0);
        await pool.connect(borrower.signer).setUserEMode(CATEGORY.id);
    });
    it('Borrow as much DAI as possible', async () => {
        const { pool, users: [, borrower], dai, oracle, } = testEnv;
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        const amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice).toString());
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Variable, 0, borrower.address);
    });
    it('Drop HF below 1', async () => {
        const { users: [, borrower], pool, } = testEnv;
        const userGlobalDataBefore = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataBefore.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        await (0, deploy_v3_1.increaseTime)(60 * 60 * 24 * 3);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
    });
    it('Liquidates the borrow', async () => {
        const { dai, usdc, users: [, borrower, liquidator], pool, oracle, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, liquidator.address, ethers_1.utils.parseUnits('100000', 18));
        await dai.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        const userGlobalDataBefore = await pool.getUserAccountData(borrower.address);
        const tx = await pool
            .connect(liquidator.signer)
            .liquidationCall(usdc.address, dai.address, borrower.address, amountToLiquidate, false);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const userReserveDataAfter = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(userGlobalDataBefore.healthFactor);
        (0, chai_1.expect)(userGlobalDataAfter.totalCollateralBase).to.be.lt(userGlobalDataBefore.totalCollateralBase);
        (0, chai_1.expect)(userGlobalDataAfter.totalDebtBase).to.be.lt(userGlobalDataBefore.totalDebtBase);
        const collateralPrice = await oracle.getAssetPrice(usdc.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(CATEGORY.lb)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        if (!tx.blockNumber) {
            (0, chai_1.expect)(false, 'Invalid block number');
            return;
        }
        const txTimestamp = ethers_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
        const variableDebtBeforeTx = (0, calculations_1.calcExpectedVariableDebtTokenBalance)(daiReserveDataBefore, userReserveDataBefore, txTimestamp);
        (0, chai_1.expect)(userReserveDataAfter.currentVariableDebt).to.be.closeTo(variableDebtBeforeTx.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.gte(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.lt(daiReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.sub(expectedCollateralLiquidated), 2, 'Invalid collateral available liquidity');
    });
});
