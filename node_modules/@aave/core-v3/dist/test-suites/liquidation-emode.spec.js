"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const make_suite_1 = require("./helpers/make-suite");
const helpers_1 = require("./helpers/utils/helpers");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Pool Liquidation: Liquidates borrows in eMode with price change', (testEnv) => {
    const { INVALID_HF } = types_1.ProtocolErrors;
    const CATEGORY = {
        id: ethers_1.BigNumber.from('1'),
        ltv: ethers_1.BigNumber.from('9800'),
        lt: ethers_1.BigNumber.from('9850'),
        lb: ethers_1.BigNumber.from('10100'),
        oracle: constants_1.ZERO_ADDRESS,
        label: 'STABLECOINS',
    };
    let snap;
    before(async () => {
        const { addressesProvider, oracle } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('Adds category id 1 (stablecoins)', async () => {
        const { configurator, pool, poolAdmin } = testEnv;
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(1, CATEGORY.ltv, CATEGORY.lt, CATEGORY.lb, CATEGORY.oracle, CATEGORY.label));
        const categoryData = await pool.getEModeCategoryData(CATEGORY.id);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(CATEGORY.ltv, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(CATEGORY.lt, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(CATEGORY.lb, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(CATEGORY.oracle, 'invalid eMode category price source');
    });
    it('Add DAI and USDC to category id 1', async () => {
        const { configurator, pool, helpersContract, poolAdmin, dai, usdc } = testEnv;
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, CATEGORY.id);
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(usdc.address, CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(dai.address)).to.be.eq(CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(usdc.address)).to.be.eq(CATEGORY.id);
    });
    it('Someone funds the DAI pool', async () => {
        const { pool, users: [daiFunder], dai, faucetMintable } = testEnv;
        const supplyAmount = ethers_1.utils.parseUnits('1', 36);
        await faucetMintable.mint(dai.address, daiFunder.address, supplyAmount);
        await dai.connect(daiFunder.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(daiFunder.signer).supply(dai.address, supplyAmount, daiFunder.address, 0);
    });
    it('Deposit USDC with eMode', async () => {
        const { pool, users: [, depositor], usdc, faucetMintable } = testEnv;
        await faucetMintable.mint(usdc.address, depositor.address, ethers_1.utils.parseUnits('10000', 6));
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .supply(usdc.address, ethers_1.utils.parseUnits('10000', 6), depositor.address, 0);
        await pool.connect(depositor.signer).setUserEMode(CATEGORY.id);
        (0, chai_1.expect)(await pool.getUserEMode(depositor.address)).to.be.eq(CATEGORY.id);
    });
    it('Borrow 98% LTV in dai', async () => {
        const { pool, users: [, depositor], dai, oracle, } = testEnv;
        const userGlobalData = await pool.getUserAccountData(depositor.address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        const amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice).toString());
        await pool
            .connect(depositor.signer)
            .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Variable, 0, depositor.address);
    });
    it('Drop HF below 1', async () => {
        const { dai, users: [, depositor], pool, oracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        const userGlobalDataBefore = await pool.getUserAccountData(depositor.address);
        (0, chai_1.expect)(userGlobalDataBefore.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18));
        await oracle.setAssetPrice(dai.address, daiPrice.mul(userGlobalDataBefore.healthFactor).div(ethers_1.utils.parseUnits('1', 18)));
        const userGlobalDataMid = await pool.getUserAccountData(depositor.address);
        (0, chai_1.expect)(userGlobalDataMid.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18));
        await oracle.setAssetPrice(dai.address, (await oracle.getAssetPrice(dai.address)).add(1));
        const userGlobalDataAfter = await pool.getUserAccountData(depositor.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
    });
    it('Liquidates the borrow', async () => {
        const { dai, usdc, users: [, borrower, , liquidator], pool, oracle, helpersContract, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, liquidator.address, ethers_1.utils.parseUnits('100000', 18));
        await dai.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        const userGlobalDataBefore = await pool.getUserAccountData(borrower.address);
        await pool
            .connect(liquidator.signer)
            .liquidationCall(usdc.address, dai.address, borrower.address, amountToLiquidate, false);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const userReserveDataAfter = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(userGlobalDataBefore.healthFactor);
        (0, chai_1.expect)(userGlobalDataAfter.totalCollateralBase).to.be.lt(userGlobalDataBefore.totalCollateralBase);
        (0, chai_1.expect)(userGlobalDataAfter.totalDebtBase).to.be.lt(userGlobalDataBefore.totalDebtBase);
        const collateralPrice = await oracle.getAssetPrice(usdc.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(CATEGORY.lb)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        (0, chai_1.expect)(userReserveDataAfter.currentVariableDebt).to.be.closeTo(userReserveDataBefore.currentVariableDebt.sub(amountToLiquidate), 3, 'Invalid user borrow balance after liquidation');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.eq(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.eq(0, 'Invalid liquidity APY');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.sub(expectedCollateralLiquidated), 2, 'Invalid collateral available liquidity');
    });
    it('Liquidation of non-eMode collateral with eMode debt for user in EMode', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        snap = await (0, deploy_v3_1.evmSnapshot)();
        const { helpersContract, oracle, configurator, pool, poolAdmin, dai, usdc, weth, aWETH, users: [user1, user2], faucetMintable } = testEnv;
        // Create category
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(1, CATEGORY.ltv, CATEGORY.lt, CATEGORY.lb, CATEGORY.oracle, CATEGORY.label));
        const categoryData = await pool.getEModeCategoryData(CATEGORY.id);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(CATEGORY.ltv, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(CATEGORY.lt, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(CATEGORY.lb, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(CATEGORY.oracle, 'invalid eMode category price source');
        // Add Dai and USDC to category
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, CATEGORY.id);
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(usdc.address, CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(dai.address)).to.be.eq(CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(usdc.address)).to.be.eq(CATEGORY.id);
        // User 1 supply 1 dai + 1 eth, user 2 supply 10000 usdc
        const wethSupplyAmount = ethers_1.utils.parseUnits('1', 18);
        const daiSupplyAmount = ethers_1.utils.parseUnits('1', 18);
        const usdcSupplyAmount = ethers_1.utils.parseUnits('10000', 6);
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, user1.address, daiSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, user1.address, wethSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(usdc.address, user2.address, usdcSupplyAmount.mul(2)));
        (0, chai_1.expect)(await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await usdc.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(dai.address, daiSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(weth.address, wethSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user2.signer).supply(usdc.address, usdcSupplyAmount, user2.address, 0));
        // Activate emode
        (0, chai_1.expect)(await pool.connect(user1.signer).setUserEMode(CATEGORY.id));
        // Borrow a as much usdc as possible
        const userData = await pool.getUserAccountData(user1.address);
        const toBorrow = userData.availableBorrowsBase.div(100);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .borrow(usdc.address, toBorrow, types_1.RateMode.Variable, 0, user1.address));
        // Drop weth price
        const wethPrice = await oracle.getAssetPrice(weth.address);
        const userGlobalDataBefore = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataBefore.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18));
        await oracle.setAssetPrice(weth.address, wethPrice.percentMul(9000));
        const userGlobalDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        const balanceBefore = await aWETH.balanceOf(user1.address);
        // Liquidate
        await pool
            .connect(user2.signer)
            .liquidationCall(weth.address, usdc.address, user1.address, toBorrow.div(2), false);
        const balanceAfter = await aWETH.balanceOf(user1.address);
        const debtPrice = await oracle.getAssetPrice(usdc.address);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const wethConfig = await helpersContract.getReserveConfigurationData(weth.address);
        const expectedCollateralLiquidated = debtPrice
            .mul(toBorrow.div(2))
            .percentMul(wethConfig.liquidationBonus)
            .mul(ethers_1.BigNumber.from(10).pow(18))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(6)));
        const collateralLiquidated = balanceBefore.sub(balanceAfter);
        (0, chai_1.expect)(collateralLiquidated).to.be.closeTo(expectedCollateralLiquidated, 2);
    });
    it('Liquidation of eMode collateral with eMode debt in EMode with custom price feed', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        snap = await (0, deploy_v3_1.evmSnapshot)();
        const { helpersContract, oracle, configurator, pool, poolAdmin, dai, usdc, weth, aDai, users: [user1, user2], faucetMintable } = testEnv;
        // We need an extra oracle for prices. USe user address as asset in price oracle
        const EMODE_ORACLE_ADDRESS = user1.address;
        await oracle.setAssetPrice(EMODE_ORACLE_ADDRESS, ethers_1.utils.parseUnits('1', 8));
        await oracle.setAssetPrice(dai.address, ethers_1.utils.parseUnits('0.99', 8));
        await oracle.setAssetPrice(usdc.address, ethers_1.utils.parseUnits('1.01', 8));
        await oracle.setAssetPrice(weth.address, ethers_1.utils.parseUnits('4000', 8));
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(1, CATEGORY.ltv, CATEGORY.lt, CATEGORY.lb, EMODE_ORACLE_ADDRESS, CATEGORY.label));
        const categoryData = await pool.getEModeCategoryData(CATEGORY.id);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(CATEGORY.ltv, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(CATEGORY.lt, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(CATEGORY.lb, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(EMODE_ORACLE_ADDRESS, 'invalid eMode category price source');
        // Add Dai and USDC to category
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, CATEGORY.id);
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(usdc.address, CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(dai.address)).to.be.eq(CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(usdc.address)).to.be.eq(CATEGORY.id);
        // User 1 supply 5000 dai + 1 eth, user 2 supply 10000 usdc
        const wethSupplyAmount = ethers_1.utils.parseUnits('1', 18);
        const daiSupplyAmount = ethers_1.utils.parseUnits('5000', 18);
        const usdcSupplyAmount = ethers_1.utils.parseUnits('10000', 6);
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, user1.address, daiSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, user1.address, wethSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(usdc.address, user2.address, usdcSupplyAmount.mul(2)));
        (0, chai_1.expect)(await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await usdc.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(dai.address, daiSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(weth.address, wethSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user2.signer).supply(usdc.address, usdcSupplyAmount, user2.address, 0));
        // Activate emode
        (0, chai_1.expect)(await pool.connect(user1.signer).setUserEMode(CATEGORY.id));
        // Borrow as much usdc as possible
        const userData = await pool.getUserAccountData(user1.address);
        const toBorrow = userData.availableBorrowsBase.div(100);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .borrow(usdc.address, toBorrow, types_1.RateMode.Variable, 0, user1.address));
        // Increase EMODE oracle price
        const oraclePrice = await oracle.getAssetPrice(EMODE_ORACLE_ADDRESS);
        const userGlobalDataBefore = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataBefore.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18));
        await oracle.setAssetPrice(EMODE_ORACLE_ADDRESS, oraclePrice.mul(2));
        const userGlobalDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        const balanceBefore = await aDai.balanceOf(user1.address);
        // Liquidate
        await pool
            .connect(user2.signer)
            .liquidationCall(dai.address, usdc.address, user1.address, toBorrow.div(2), false);
        const balanceAfter = await aDai.balanceOf(user1.address);
        const debtPrice = await oracle.getAssetPrice(EMODE_ORACLE_ADDRESS);
        const collateralPrice = await oracle.getAssetPrice(EMODE_ORACLE_ADDRESS);
        const expectedCollateralLiquidated = debtPrice
            .mul(toBorrow.div(2))
            .percentMul(CATEGORY.lb)
            .mul(ethers_1.BigNumber.from(10).pow(18))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(6)));
        const collateralLiquidated = balanceBefore.sub(balanceAfter);
        (0, chai_1.expect)(collateralLiquidated).to.be.closeTo(expectedCollateralLiquidated, 2);
    });
    it('Liquidation of non-eMode collateral with eMode debt in eMode with custom price feed', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        snap = await (0, deploy_v3_1.evmSnapshot)();
        const { helpersContract, oracle, configurator, pool, poolAdmin, dai, usdc, weth, aWETH, users: [user1, user2], faucetMintable } = testEnv;
        // We need an extra oracle for prices. USe user address as asset in price oracle
        const EMODE_ORACLE_ADDRESS = user1.address;
        await oracle.setAssetPrice(EMODE_ORACLE_ADDRESS, ethers_1.utils.parseUnits('1', 8));
        await oracle.setAssetPrice(dai.address, ethers_1.utils.parseUnits('0.99', 8));
        await oracle.setAssetPrice(usdc.address, ethers_1.utils.parseUnits('1.01', 8));
        await oracle.setAssetPrice(weth.address, ethers_1.utils.parseUnits('4000', 8));
        // Create category
        (0, chai_1.expect)(await configurator
            .connect(poolAdmin.signer)
            .setEModeCategory(1, CATEGORY.ltv, CATEGORY.lt, CATEGORY.lb, EMODE_ORACLE_ADDRESS, CATEGORY.label));
        const categoryData = await pool.getEModeCategoryData(CATEGORY.id);
        (0, chai_1.expect)(categoryData.ltv).to.be.equal(CATEGORY.ltv, 'invalid eMode category ltv');
        (0, chai_1.expect)(categoryData.liquidationThreshold).to.be.equal(CATEGORY.lt, 'invalid eMode category liq threshold');
        (0, chai_1.expect)(categoryData.liquidationBonus).to.be.equal(CATEGORY.lb, 'invalid eMode category liq bonus');
        (0, chai_1.expect)(categoryData.priceSource).to.be.equal(EMODE_ORACLE_ADDRESS, 'invalid eMode category price source');
        // Add Dai and USDC to category
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(dai.address, CATEGORY.id);
        await configurator.connect(poolAdmin.signer).setAssetEModeCategory(usdc.address, CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(dai.address)).to.be.eq(CATEGORY.id);
        (0, chai_1.expect)(await helpersContract.getReserveEModeCategory(usdc.address)).to.be.eq(CATEGORY.id);
        // User 1 supply 1 dai + 1 eth, user 2 supply 10000 usdc
        const wethSupplyAmount = ethers_1.utils.parseUnits('1', 18);
        const daiSupplyAmount = ethers_1.utils.parseUnits('1', 18);
        const usdcSupplyAmount = ethers_1.utils.parseUnits('10000', 6);
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, user1.address, daiSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, user1.address, wethSupplyAmount));
        (0, chai_1.expect)(await faucetMintable.mint(usdc.address, user2.address, usdcSupplyAmount.mul(2)));
        (0, chai_1.expect)(await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await usdc.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(dai.address, daiSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user1.signer).supply(weth.address, wethSupplyAmount, user1.address, 0));
        (0, chai_1.expect)(await pool.connect(user2.signer).supply(usdc.address, usdcSupplyAmount, user2.address, 0));
        // Activate emode
        (0, chai_1.expect)(await pool.connect(user1.signer).setUserEMode(CATEGORY.id));
        // Borrow a as much usdc as possible
        const userData = await pool.getUserAccountData(user1.address);
        const toBorrow = userData.availableBorrowsBase.div(100);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .borrow(usdc.address, toBorrow, types_1.RateMode.Variable, 0, user1.address));
        // Drop weth price
        const oraclePrice = await oracle.getAssetPrice(EMODE_ORACLE_ADDRESS);
        const userGlobalDataBefore = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataBefore.healthFactor).to.be.gt(ethers_1.utils.parseUnits('1', 18));
        await oracle.setAssetPrice(EMODE_ORACLE_ADDRESS, oraclePrice.mul(2));
        const userGlobalDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        const balanceBefore = await aWETH.balanceOf(user1.address);
        // Liquidate
        await pool
            .connect(user2.signer)
            .liquidationCall(weth.address, usdc.address, user1.address, toBorrow.div(2), false);
        const balanceAfter = await aWETH.balanceOf(user1.address);
        const debtPrice = await oracle.getAssetPrice(EMODE_ORACLE_ADDRESS);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const wethConfig = await helpersContract.getReserveConfigurationData(weth.address);
        const expectedCollateralLiquidated = debtPrice
            .mul(toBorrow.div(2))
            .percentMul(wethConfig.liquidationBonus)
            .mul(ethers_1.BigNumber.from(10).pow(18))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(6)));
        const collateralLiquidated = balanceBefore.sub(balanceAfter);
        (0, chai_1.expect)(collateralLiquidated).to.be.closeTo(expectedCollateralLiquidated, 2);
    });
});
