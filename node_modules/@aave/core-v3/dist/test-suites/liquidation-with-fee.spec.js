"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const bignumber_1 = require("@ethersproject/bignumber");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const types_2 = require("../types");
const calculations_1 = require("./helpers/utils/calculations");
const helpers_1 = require("./helpers/utils/helpers");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Pool Liquidation: Add fee to liquidations', (testEnv) => {
    const { INVALID_HF } = types_1.ProtocolErrors;
    before(async () => {
        const { addressesProvider, oracle } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('position should be liquidated when turn on liquidation protocol fee.', async () => {
        const { pool, users: [depositor, borrower, liquidator], usdc, weth, oracle, configurator, helpersContract, faucetMintable, } = testEnv;
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const daiPrice = await oracle.getAssetPrice(usdc.address);
        //1. Depositor supplies 10000 USDC and 10 ETH
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '10000'));
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .supply(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '10000'), depositor.address, 0);
        await faucetMintable.mint(weth.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '10'));
        await weth.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(depositor.signer)
            .supply(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '10'), depositor.address, 0);
        //2. Borrower supplies 10 ETH, and borrows as much USDC as it can
        await faucetMintable.mint(weth.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '10'));
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .supply(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '10'), borrower.address, 0);
        const { availableBorrowsBase } = await pool.getUserAccountData(borrower.address);
        let toBorrow = availableBorrowsBase.div(daiPrice);
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, toBorrow, types_1.RateMode.Variable, 0, borrower.address);
        //3. Liquidator supplies 10000 USDC and borrow 5 ETH
        await faucetMintable.mint(usdc.address, liquidator.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '20000'));
        await usdc.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(liquidator.signer)
            .supply(usdc.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '10000'), liquidator.address, 0);
        await pool
            .connect(liquidator.signer)
            .borrow(weth.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '1'), types_1.RateMode.Variable, 0, liquidator.address);
        //4. Advance block to make ETH income index > 1
        await (0, deploy_v3_1.increaseTime)(86400);
        //5. Decrease weth price to allow liquidation
        await oracle.setAssetPrice(usdc.address, '8000000000000000'); //weth = 500 usdc
        //7. Turn on liquidation protocol fee
        (0, chai_1.expect)(await configurator.setLiquidationProtocolFee(weth.address, 500));
        const wethLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(weth.address);
        (0, chai_1.expect)(wethLiquidationProtocolFee).to.be.eq(500);
        const tryMaxTimes = 20;
        for (let i = 1; i <= tryMaxTimes; i++) {
            const tmpSnap = await (0, deploy_v3_1.evmSnapshot)();
            await (0, deploy_v3_1.increaseTime)(i);
            (0, chai_1.expect)(await pool
                .connect(liquidator.signer)
                .liquidationCall(weth.address, usdc.address, borrower.address, constants_1.MAX_UINT_AMOUNT, false));
            if (i !== tryMaxTimes) {
                await (0, deploy_v3_1.evmRevert)(tmpSnap);
            }
        }
        (0, chai_1.expect)(await weth.balanceOf(liquidator.address)).to.be.gt(await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5'));
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Sets the WETH protocol liquidation fee to 1000 (10.00%)', async () => {
        const { configurator, weth, aave, helpersContract } = testEnv;
        const oldWethLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(weth.address);
        const oldAaveLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(aave.address);
        const wethLiquidationProtocolFeeInput = 1000;
        const aaveLiquidationProtocolFeeInput = 500;
        (0, chai_1.expect)(await configurator.setLiquidationProtocolFee(weth.address, wethLiquidationProtocolFeeInput))
            .to.emit(configurator, 'LiquidationProtocolFeeChanged')
            .withArgs(weth.address, oldWethLiquidationProtocolFee, wethLiquidationProtocolFeeInput);
        (0, chai_1.expect)(await configurator.setLiquidationProtocolFee(aave.address, aaveLiquidationProtocolFeeInput))
            .to.emit(configurator, 'LiquidationProtocolFeeChanged')
            .withArgs(aave.address, oldAaveLiquidationProtocolFee, aaveLiquidationProtocolFeeInput);
        const wethLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(weth.address);
        const aaveLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(aave.address);
        (0, chai_1.expect)(wethLiquidationProtocolFee).to.be.equal(wethLiquidationProtocolFeeInput);
        (0, chai_1.expect)(aaveLiquidationProtocolFee).to.be.equal(aaveLiquidationProtocolFeeInput);
    });
    it('Deposits WETH, borrows DAI', async () => {
        const { dai, weth, users: [depositor, borrower], pool, oracle, faucetMintable, } = testEnv;
        //mints DAI to depositor
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        //approve protocol to access depositor wallet
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, amountDAItoDeposit, depositor.address, '0');
        //user 2 deposits 1 ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.06775');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '1000'));
        //approve protocol to access the borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //user 2 borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const daiPrice = await oracle.getAssetPrice(dai.address);
        const amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice).percentMul(9500).toString());
        await pool
            .connect(borrower.signer)
            .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Stable, '0', borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalDataAfter.currentLiquidationThreshold).to.be.equal(8250, INVALID_HF);
    });
    it('Drop the health factor below 1', async () => {
        const { dai, users: [, borrower], pool, oracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(11800));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.lt(constants_1.oneEther, INVALID_HF);
    });
    it('Liquidates the borrow', async () => {
        const { dai, weth, aWETH, users: [, borrower, , liquidator], pool, oracle, helpersContract, faucetMintable, } = testEnv;
        //mints dai to the liquidator
        await faucetMintable.mint(dai.address, liquidator.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        //approve protocol to access the liquidator wallet
        await dai.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const liquidatorBalanceBefore = await weth.balanceOf(liquidator.address);
        const treasuryAddress = await aWETH.RESERVE_TREASURY_ADDRESS();
        const treasuryDataBefore = await helpersContract.getUserReserveData(weth.address, treasuryAddress);
        const treasuryBalanceBefore = treasuryDataBefore.currentATokenBalance;
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        const wethLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(weth.address);
        await (0, deploy_v3_1.increaseTime)(100);
        const tx = await pool
            .connect(liquidator.signer)
            .liquidationCall(weth.address, dai.address, borrower.address, amountToLiquidate, false);
        const userReserveDataAfter = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const liquidatorBalanceAfter = await weth.balanceOf(liquidator.address);
        const treasuryDataAfter = await helpersContract.getUserReserveData(weth.address, treasuryAddress);
        const treasuryBalanceAfter = treasuryDataAfter.currentATokenBalance;
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const baseCollateral = principalPrice
            .mul(amountToLiquidate)
            .mul(bignumber_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(bignumber_1.BigNumber.from(10).pow(principalDecimals)));
        const bonusCollateral = baseCollateral.percentMul(10500).sub(baseCollateral);
        const totalCollateralLiquidated = baseCollateral.add(bonusCollateral);
        const liquidationProtocolFees = bonusCollateral.percentMul(wethLiquidationProtocolFee);
        const expectedLiquidationReward = totalCollateralLiquidated.sub(liquidationProtocolFees);
        if (!tx.blockNumber) {
            (0, chai_1.expect)(false, 'Invalid block number');
            return;
        }
        const txTimestamp = bignumber_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
        const stableDebtBeforeTx = (0, calculations_1.calcExpectedStableDebtTokenBalance)(userReserveDataBefore.principalStableDebt, userReserveDataBefore.stableBorrowRate, userReserveDataBefore.stableRateLastUpdated, txTimestamp);
        (0, chai_1.expect)(userReserveDataAfter.currentStableDebt).to.be.closeTo(stableDebtBeforeTx.sub(amountToLiquidate), 2, 'Invalid user debt after liquidation');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.gte(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.lt(daiReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity.sub(expectedLiquidationReward), 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(treasuryBalanceAfter).to.be.closeTo(treasuryBalanceBefore.add(liquidationProtocolFees), 2, 'Invalid treasury increase');
        (0, chai_1.expect)(liquidatorBalanceAfter).to.be.closeTo(liquidatorBalanceBefore.add(expectedLiquidationReward), 2, 'Invalid liquidator balance');
        (0, chai_1.expect)(daiReserveDataAfter.totalLiquidity).to.be.closeTo(daiReserveDataBefore.totalLiquidity.add(amountToLiquidate), 2, 'Invalid principal total liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.totalLiquidity).to.be.closeTo(ethReserveDataBefore.totalLiquidity.sub(totalCollateralLiquidated.sub(liquidationProtocolFees)), 2, 'Invalid collateral total liquidity');
    });
    it('User 3 deposits 1000 USDC, user 4 0.06775 WETH, user 4 borrows - drops HF, liquidates the borrow', async () => {
        const { usdc, users: [, , , depositor, borrower, liquidator], pool, oracle, weth, aWETH, helpersContract, faucetMintable, } = testEnv;
        //mints USDC to depositor
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access depositor wallet
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //depositor deposits 1000 USDC
        const amountUSDCtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, amountUSDCtoDeposit, depositor.address, '0');
        //borrower deposits 1 ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.06775');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '1000'));
        //approve protocol to access the borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //borrower borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        const amountUSDCToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, userGlobalData.availableBorrowsBase.div(usdcPrice).percentMul(9502).toString());
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, amountUSDCToBorrow, types_1.RateMode.Stable, '0', borrower.address);
        //drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(11200));
        //mints usdc to the liquidator
        await faucetMintable.mint(usdc.address, liquidator.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access liquidator wallet
        await usdc.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const liquidatorBalanceBefore = await weth.balanceOf(liquidator.address);
        const treasuryAddress = await aWETH.RESERVE_TREASURY_ADDRESS();
        const treasuryDataBefore = await helpersContract.getUserReserveData(weth.address, treasuryAddress);
        const treasuryBalanceBefore = treasuryDataBefore.currentATokenBalance;
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        const wethLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(weth.address);
        await pool
            .connect(liquidator.signer)
            .liquidationCall(weth.address, usdc.address, borrower.address, amountToLiquidate, false);
        const userReserveDataAfter = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const liquidatorBalanceAfter = await weth.balanceOf(liquidator.address);
        const treasuryDataAfter = await helpersContract.getUserReserveData(weth.address, treasuryAddress);
        const treasuryBalanceAfter = treasuryDataAfter.currentATokenBalance;
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(usdc.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const baseCollateral = principalPrice
            .mul(amountToLiquidate)
            .mul(bignumber_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(bignumber_1.BigNumber.from(10).pow(principalDecimals)));
        const bonusCollateral = baseCollateral.percentMul(10500).sub(baseCollateral);
        const totalCollateralLiquidated = baseCollateral.add(bonusCollateral);
        const liquidationProtocolFees = bonusCollateral.percentMul(wethLiquidationProtocolFee);
        const expectedLiquidationReward = totalCollateralLiquidated.sub(liquidationProtocolFees);
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(constants_1.oneEther, 'Invalid health factor');
        (0, chai_1.expect)(userReserveDataAfter.currentStableDebt).to.be.closeTo(userReserveDataBefore.currentStableDebt.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(usdcReserveDataAfter.liquidityIndex).to.be.gte(usdcReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(usdcReserveDataAfter.liquidityRate).to.be.lt(usdcReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity.sub(expectedLiquidationReward), 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(treasuryBalanceAfter).to.be.closeTo(treasuryBalanceBefore.add(liquidationProtocolFees), 2, 'Invalid treasury increase');
        (0, chai_1.expect)(liquidatorBalanceAfter).to.be.closeTo(liquidatorBalanceBefore.add(expectedLiquidationReward), 2, 'Invalid liquidator balance');
        (0, chai_1.expect)(usdcReserveDataAfter.totalLiquidity).to.be.closeTo(usdcReserveDataBefore.totalLiquidity.add(amountToLiquidate), 2, 'Invalid principal total liquidity');
        (0, chai_1.expect)(ethReserveDataAfter.totalLiquidity).to.be.closeTo(ethReserveDataBefore.totalLiquidity.sub(totalCollateralLiquidated.sub(liquidationProtocolFees)), 2, 'Invalid collateral total liquidity');
    });
    it('User 4 deposits 0.03 AAVE - drops HF, liquidates the AAVE, which results on a lower amount being liquidated', async () => {
        const snap = await (0, deploy_v3_1.evmSnapshot)();
        const { aave, usdc, users: [, , , , borrower, liquidator], pool, oracle, helpersContract, faucetMintable, } = testEnv;
        //mints AAVE to borrower
        await faucetMintable.mint(aave.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(aave.address, '0.03'));
        //approve protocol to access the borrower wallet
        await aave.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //borrower deposits AAVE
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(aave.address, '0.03');
        await pool
            .connect(borrower.signer)
            .deposit(aave.address, amountToDeposit, borrower.address, '0');
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        //drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(11400));
        //mints usdc to the liquidator
        await faucetMintable.mint(usdc.address, liquidator.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access liquidator wallet
        await usdc.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const aaveReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        const collateralPrice = await oracle.getAssetPrice(aave.address);
        const principalPrice = await oracle.getAssetPrice(usdc.address);
        const aaveTokenAddresses = await helpersContract.getReserveTokensAddresses(aave.address);
        const aAaveTokenAddress = await aaveTokenAddresses.aTokenAddress;
        const aAaveTokenContract = await types_2.AToken__factory.connect(aAaveTokenAddress, hre.ethers.provider);
        const aAaveTokenBalanceBefore = await aAaveTokenContract.balanceOf(liquidator.address);
        const borrowerATokenBalance = await aAaveTokenContract.balanceOf(borrower.address);
        const treasuryAddress = await aAaveTokenContract.RESERVE_TREASURY_ADDRESS();
        const treasuryDataBefore = await helpersContract.getUserReserveData(aave.address, treasuryAddress);
        const treasuryBalanceBefore = treasuryDataBefore.currentATokenBalance;
        await pool
            .connect(liquidator.signer)
            .liquidationCall(aave.address, usdc.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const aaveReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        const aaveConfiguration = await helpersContract.getReserveConfigurationData(aave.address);
        const collateralDecimals = aaveConfiguration.decimals;
        const liquidationBonus = aaveConfiguration.liquidationBonus;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const expectedCollateralLiquidated = constants_1.oneEther.mul(30).div(1000);
        const aaveLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(aave.address);
        const expectedPrincipal = collateralPrice
            .mul(expectedCollateralLiquidated)
            .mul(bignumber_1.BigNumber.from(10).pow(principalDecimals))
            .div(principalPrice.mul(bignumber_1.BigNumber.from(10).pow(collateralDecimals)))
            .percentDiv(liquidationBonus);
        const bonusCollateral = borrowerATokenBalance.sub(borrowerATokenBalance.percentDiv(liquidationBonus));
        const liquidationProtocolFee = bonusCollateral.percentMul(aaveLiquidationProtocolFee);
        const expectedLiquidationReward = borrowerATokenBalance.sub(liquidationProtocolFee);
        const aAaveTokenBalanceAfter = await aAaveTokenContract.balanceOf(liquidator.address);
        const treasuryDataAfter = await helpersContract.getUserReserveData(aave.address, treasuryAddress);
        const treasuryBalanceAfter = treasuryDataAfter.currentATokenBalance;
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(constants_1.oneEther, 'Invalid health factor');
        (0, chai_1.expect)(userReserveDataAfter.currentStableDebt).to.be.closeTo(userReserveDataBefore.currentStableDebt.sub(expectedPrincipal), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.add(expectedPrincipal), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(aaveReserveDataAfter.availableLiquidity).to.be.closeTo(aaveReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(usdcReserveDataAfter.totalLiquidity).to.be.closeTo(usdcReserveDataBefore.totalLiquidity.add(expectedPrincipal), 2, 'Invalid principal total liquidity');
        (0, chai_1.expect)(aaveReserveDataAfter.totalLiquidity).to.be.closeTo(aaveReserveDataBefore.totalLiquidity, 2, 'Invalid collateral total liquidity');
        (0, chai_1.expect)(aAaveTokenBalanceBefore).to.be.equal(aAaveTokenBalanceAfter.sub(expectedLiquidationReward), 'Liquidator aToken balance incorrect');
        (0, chai_1.expect)(treasuryBalanceBefore).to.be.equal(treasuryBalanceAfter.sub(liquidationProtocolFee), 'Treasury aToken balance incorrect');
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Set liquidationProtocolFee to 0. User 4 deposits 0.03 AAVE - drops HF, liquidates the AAVE, which results on a lower amount being liquidated', async () => {
        const { aave, usdc, users: [, , , , borrower, liquidator], pool, oracle, helpersContract, configurator, faucetMintable, } = testEnv;
        const oldAaveLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(aave.address);
        (0, chai_1.expect)(await configurator.setLiquidationProtocolFee(aave.address, 0))
            .to.emit(configurator, 'LiquidationProtocolFeeChanged')
            .withArgs(aave.address, oldAaveLiquidationProtocolFee, 0);
        //mints AAVE to borrower
        await faucetMintable.mint(aave.address, borrower.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(aave.address, '0.03'));
        //approve protocol to access the borrower wallet
        await aave.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //borrower deposits AAVE
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(aave.address, '0.03');
        await pool
            .connect(borrower.signer)
            .deposit(aave.address, amountToDeposit, borrower.address, '0');
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        //drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(11400));
        //mints usdc to the liquidator
        await faucetMintable.mint(usdc.address, liquidator.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access liquidator wallet
        await usdc.connect(liquidator.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const usdcReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const aaveReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        const collateralPrice = await oracle.getAssetPrice(aave.address);
        const principalPrice = await oracle.getAssetPrice(usdc.address);
        const aaveTokenAddresses = await helpersContract.getReserveTokensAddresses(aave.address);
        const aAaveTokenAddress = await aaveTokenAddresses.aTokenAddress;
        const aAaveTokenContract = await types_2.AToken__factory.connect(aAaveTokenAddress, hre.ethers.provider);
        const aAaveTokenBalanceBefore = await aAaveTokenContract.balanceOf(liquidator.address);
        const borrowerATokenBalance = await aAaveTokenContract.balanceOf(borrower.address);
        const treasuryAddress = await aAaveTokenContract.RESERVE_TREASURY_ADDRESS();
        const treasuryDataBefore = await helpersContract.getUserReserveData(aave.address, treasuryAddress);
        const treasuryBalanceBefore = treasuryDataBefore.currentATokenBalance;
        await pool
            .connect(liquidator.signer)
            .liquidationCall(aave.address, usdc.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const usdcReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, usdc.address);
        const aaveReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, aave.address);
        const aaveConfiguration = await helpersContract.getReserveConfigurationData(aave.address);
        const collateralDecimals = aaveConfiguration.decimals;
        const liquidationBonus = aaveConfiguration.liquidationBonus;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(usdc.address))
            .decimals;
        const expectedCollateralLiquidated = constants_1.oneEther.mul(30).div(1000);
        const aaveLiquidationProtocolFee = await helpersContract.getLiquidationProtocolFee(aave.address);
        const expectedPrincipal = collateralPrice
            .mul(expectedCollateralLiquidated)
            .mul(bignumber_1.BigNumber.from(10).pow(principalDecimals))
            .div(principalPrice.mul(bignumber_1.BigNumber.from(10).pow(collateralDecimals)))
            .percentDiv(liquidationBonus);
        const bonusCollateral = borrowerATokenBalance.sub(borrowerATokenBalance.percentDiv(liquidationBonus));
        const liquidationProtocolFee = bonusCollateral.percentMul(aaveLiquidationProtocolFee);
        const expectedLiquidationReward = borrowerATokenBalance.sub(liquidationProtocolFee);
        const aAaveTokenBalanceAfter = await aAaveTokenContract.balanceOf(liquidator.address);
        const treasuryDataAfter = await helpersContract.getUserReserveData(aave.address, treasuryAddress);
        const treasuryBalanceAfter = treasuryDataAfter.currentATokenBalance;
        (0, chai_1.expect)(userGlobalDataAfter.healthFactor).to.be.gt(constants_1.oneEther, 'Invalid health factor');
        (0, chai_1.expect)(userReserveDataAfter.currentStableDebt).to.be.closeTo(userReserveDataBefore.currentStableDebt.sub(expectedPrincipal), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(usdcReserveDataAfter.availableLiquidity).to.be.closeTo(usdcReserveDataBefore.availableLiquidity.add(expectedPrincipal), 2, 'Invalid principal available liquidity');
        (0, chai_1.expect)(aaveReserveDataAfter.availableLiquidity).to.be.closeTo(aaveReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)(usdcReserveDataAfter.totalLiquidity).to.be.closeTo(usdcReserveDataBefore.totalLiquidity.add(expectedPrincipal), 2, 'Invalid principal total liquidity');
        (0, chai_1.expect)(aaveReserveDataAfter.totalLiquidity).to.be.closeTo(aaveReserveDataBefore.totalLiquidity, 2, 'Invalid collateral total liquidity');
        (0, chai_1.expect)(aAaveTokenBalanceBefore).to.be.equal(aAaveTokenBalanceAfter.sub(expectedLiquidationReward), 'Liquidator aToken balance incorrect');
        (0, chai_1.expect)(treasuryBalanceBefore).to.be.equal(treasuryBalanceAfter.sub(liquidationProtocolFee), 'Treasury aToken balance incorrect');
    });
});
