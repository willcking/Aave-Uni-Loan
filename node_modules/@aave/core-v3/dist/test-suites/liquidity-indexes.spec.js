"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const bignumber_1 = require("@ethersproject/bignumber");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
require("./helpers/utils/wadraymath");
(0, make_suite_1.makeSuite)('Pool: liquidity indexes misc tests', (testEnv) => {
    const TOTAL_PREMIUM = 9;
    const PREMIUM_TO_PROTOCOL = 3000;
    let _mockFlashLoanReceiver = {};
    let snap;
    const setupForFlashloan = async (testEnv) => {
        const { configurator, pool, weth, aave, dai, users: [user0], faucetMintable, deployer, } = testEnv;
        _mockFlashLoanReceiver = await (0, deploy_v3_1.getMockFlashLoanReceiver)();
        await configurator.updateFlashloanPremiumTotal(TOTAL_PREMIUM);
        await configurator.updateFlashloanPremiumToProtocol(PREMIUM_TO_PROTOCOL);
        const userAddress = user0.address;
        const amountToDeposit = ethers_1.ethers.utils.parseEther('1');
        await faucetMintable.mint(weth.address, deployer.address, amountToDeposit);
        await weth.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(weth.address, amountToDeposit, userAddress, '0');
        await faucetMintable.mint(aave.address, deployer.address, amountToDeposit);
        await aave.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(aave.address, amountToDeposit, userAddress, '0');
        await faucetMintable.mint(dai.address, deployer.address, amountToDeposit);
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(dai.address, amountToDeposit, userAddress, '0');
    };
    before(async () => {
        await setupForFlashloan(testEnv);
    });
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Validates that the flash loan fee properly takes into account both aToken supply and accruedToTreasury', async () => {
        const { pool, helpersContract, weth, aWETH, users: [depositorWeth], } = testEnv;
        /**
         * 1. Flashes 0.8 WETH
         * 2. Flashes again 0.8 ETH (to have accruedToTreasury)
         * 3. Validates that liquidity index took into account both aToken supply and accruedToTreasury
         */
        const wethFlashBorrowedAmount = ethers_1.ethers.utils.parseEther('0.8');
        await pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], [wethFlashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0');
        await pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], [wethFlashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0');
        const wethReserveDataAfterSecondFlash = await helpersContract.getReserveData(weth.address);
        const totalScaledWithTreasuryAfterSecondFlash = (await aWETH.scaledBalanceOf(depositorWeth.address)).add(wethReserveDataAfterSecondFlash.accruedToTreasuryScaled.toString());
        (0, chai_1.expect)(await weth.balanceOf(aWETH.address)).to.be.closeTo(bignumber_1.BigNumber.from(totalScaledWithTreasuryAfterSecondFlash.toString()).rayMul(wethReserveDataAfterSecondFlash.liquidityIndex), 1, 'Scaled total supply not (+/- 1) equal to WETH balance of aWETH');
    });
});
