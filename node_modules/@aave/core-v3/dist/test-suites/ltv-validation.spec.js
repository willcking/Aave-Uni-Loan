"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
const utils_1 = require("ethers/lib/utils");
(0, make_suite_1.makeSuite)('LTV validation', (testEnv) => {
    const { LTV_VALIDATION_FAILED, USER_IN_ISOLATION_MODE_OR_LTV_ZERO } = types_1.ProtocolErrors;
    let snap;
    before(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    it('User 1 deposits 10 Dai, 10 USDC, user 2 deposits 0.071 WETH', async () => {
        const { pool, dai, usdc, weth, users: [user1, user2], faucetMintable } = testEnv;
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        const usdcAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '10');
        const wethAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.071');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await usdc.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await weth.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await faucetMintable.mint(usdc.address, user1.address, usdcAmount);
        await faucetMintable.mint(weth.address, user2.address, wethAmount);
        await pool.connect(user1.signer).deposit(dai.address, daiAmount, user1.address, 0);
        await pool.connect(user1.signer).deposit(usdc.address, usdcAmount, user1.address, 0);
        await pool.connect(user2.signer).deposit(weth.address, wethAmount, user2.address, 0);
    });
    it('Sets the LTV of DAI to 0', async () => {
        const { configurator, dai, helpersContract, users: [], } = testEnv;
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
    });
    it('Borrows 0.000414 WETH', async () => {
        const { pool, weth, users: [user1], } = testEnv;
        const borrowedAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.000414');
        (0, chai_1.expect)(await pool.connect(user1.signer).borrow(weth.address, borrowedAmount, 1, 0, user1.address));
    });
    it('Tries to withdraw USDC (revert expected)', async () => {
        const { pool, usdc, users: [user1], } = testEnv;
        const withdrawnAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1');
        await (0, chai_1.expect)(pool.connect(user1.signer).withdraw(usdc.address, withdrawnAmount, user1.address)).to.be.revertedWith(LTV_VALIDATION_FAILED);
    });
    it('Withdraws DAI', async () => {
        const { pool, dai, aDai, users: [user1], } = testEnv;
        const aDaiBalanceBefore = await aDai.balanceOf(user1.address);
        const withdrawnAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1');
        (0, chai_1.expect)(await pool.connect(user1.signer).withdraw(dai.address, withdrawnAmount, user1.address));
        const aDaiBalanceAfter = await aDai.balanceOf(user1.address);
        (0, chai_1.expect)(aDaiBalanceAfter).to.be.eq(aDaiBalanceBefore.sub(withdrawnAmount));
    });
    it('User 1 deposit dai, DAI ltv drops to 0, then tries borrow', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        const { pool, dai, weth, users: [user1, user2], configurator, helpersContract, faucetMintable } = testEnv;
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        const wethAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '10');
        const borrowWethAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await weth.connect(user2.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await faucetMintable.mint(weth.address, user1.address, wethAmount);
        await pool.connect(user1.signer).supply(dai.address, daiAmount, user1.address, 0);
        await pool.connect(user2.signer).supply(weth.address, wethAmount, user2.address, 0);
        // Set DAI LTV = 0
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
        // Borrow all the weth because of issue in collateral needed.
        await (0, chai_1.expect)(pool
            .connect(user1.signer)
            .borrow(weth.address, borrowWethAmount, types_1.RateMode.Variable, 0, user1.address)).to.be.revertedWith(LTV_VALIDATION_FAILED);
        const userData = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userData.totalCollateralBase).to.be.eq((0, utils_1.parseUnits)('10', 8));
        (0, chai_1.expect)(userData.totalDebtBase).to.be.eq(0);
    });
    it('User 1 deposit dai as collateral, ltv drops to 0, tries to enable as collateral (nothing should happen)', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        const { pool, dai, users: [user1], configurator, helpersContract, faucetMintable } = testEnv;
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await pool.connect(user1.signer).supply(dai.address, daiAmount, user1.address, 0);
        // Set DAI LTV = 0
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
        const userDataBefore = await helpersContract.getUserReserveData(dai.address, user1.address);
        (0, chai_1.expect)(userDataBefore.usageAsCollateralEnabled).to.be.eq(true);
        await pool.connect(user1.signer).setUserUseReserveAsCollateral(dai.address, true);
        const userDataAfter = await helpersContract.getUserReserveData(dai.address, user1.address);
        (0, chai_1.expect)(userDataAfter.usageAsCollateralEnabled).to.be.eq(true);
    });
    it('User 1 deposit zero ltv dai, tries to enable as collateral (revert expected)', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        const { pool, dai, users: [user1], configurator, helpersContract, faucetMintable } = testEnv;
        // Clean user's state by withdrawing all aDAI
        await pool.connect(user1.signer).withdraw(dai.address, constants_1.MAX_UINT_AMOUNT, user1.address);
        // Set DAI LTV = 0
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await pool.connect(user1.signer).supply(dai.address, daiAmount, user1.address, 0);
        await (0, chai_1.expect)(pool.connect(user1.signer).setUserUseReserveAsCollateral(dai.address, true)).to.be.revertedWith(USER_IN_ISOLATION_MODE_OR_LTV_ZERO);
    });
    it('User 1 deposit zero ltv dai, dai should not be enabled as collateral', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        const { pool, dai, users: [user1], configurator, helpersContract, faucetMintable } = testEnv;
        // Set DAI LTV = 0
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await pool.connect(user1.signer).supply(dai.address, daiAmount, user1.address, 0);
        const userData = await helpersContract.getUserReserveData(dai.address, user1.address);
        (0, chai_1.expect)(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
    it('User 1 deposit dai, DAI ltv drops to 0, transfers dai, dai should not be enabled as collateral for receiver', async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
        const { pool, dai, aDai, users: [user1, user2], configurator, helpersContract, faucetMintable } = testEnv;
        const daiAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10');
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(dai.address, user1.address, daiAmount);
        await pool.connect(user1.signer).supply(dai.address, daiAmount, user1.address, 0);
        // Set DAI LTV = 0
        (0, chai_1.expect)(await configurator.configureReserveAsCollateral(dai.address, 0, 8000, 10500))
            .to.emit(configurator, 'CollateralConfigurationChanged')
            .withArgs(dai.address, 0, 8000, 10500);
        const ltv = (await helpersContract.getReserveConfigurationData(dai.address)).ltv;
        (0, chai_1.expect)(ltv).to.be.equal(0);
        // Transfer 0 LTV DAI to user2
        await aDai.connect(user1.signer).transfer(user2.address, 1);
        const userData = await helpersContract.getUserReserveData(dai.address, user2.address);
        (0, chai_1.expect)(userData.usageAsCollateralEnabled).to.be.eq(false);
    });
});
