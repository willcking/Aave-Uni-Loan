"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Mint To Treasury', (testEnv) => {
    it('User 0 deposits 1000 DAI. Borrower borrows 100 DAI. Clock moved forward one year. Calculates and verifies the amount accrued to the treasury', async () => {
        const { users, pool, dai, helpersContract, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        const amountDAItoBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '100');
        await (0, chai_1.expect)(await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit));
        // user 0 deposits 1000 DAI
        await (0, chai_1.expect)(await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        await (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        await (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .borrow(dai.address, amountDAItoBorrow, types_1.RateMode.Variable, '0', users[0].address));
        const { reserveFactor } = await helpersContract.getReserveConfigurationData(dai.address);
        await (0, deploy_v3_1.advanceTimeAndBlock)(parseInt(constants_1.ONE_YEAR));
        await (0, chai_1.expect)(await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit));
        await (0, chai_1.expect)(await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0'));
        const { liquidityIndex, variableBorrowIndex } = await pool.getReserveData(dai.address);
        const expectedAccruedToTreasury = amountDAItoBorrow
            .rayMul(variableBorrowIndex)
            .sub(amountDAItoBorrow)
            .percentMul(reserveFactor)
            .rayDiv(liquidityIndex);
        const { accruedToTreasury } = await pool.getReserveData(dai.address);
        (0, chai_1.expect)(accruedToTreasury).to.be.closeTo(expectedAccruedToTreasury, 2);
    });
    it('Mints the accrued to the treasury', async () => {
        const { users, pool, dai, aDai } = testEnv;
        const treasuryAddress = await aDai.RESERVE_TREASURY_ADDRESS();
        const { accruedToTreasury } = await pool.getReserveData(dai.address);
        await (0, chai_1.expect)(await pool.connect(users[0].signer).mintToTreasury([dai.address]));
        const normalizedIncome = await pool.getReserveNormalizedIncome(dai.address);
        const treasuryBalance = await aDai.balanceOf(treasuryAddress);
        const expectedTreasuryBalance = accruedToTreasury.rayMul(normalizedIncome);
        (0, chai_1.expect)(treasuryBalance).to.be.closeTo(expectedTreasuryBalance, 2, 'Invalid treasury balance after minting');
    });
});
