"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const types_2 = require("../types");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const make_suite_1 = require("./helpers/make-suite");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const misc_utils_1 = require("../helpers/misc-utils");
(0, make_suite_1.makeSuite)('Reserve Without Incentives Controller', (testEnv) => {
    let mockToken;
    let aMockToken;
    let mockStableDebt;
    let mockVariableDebt;
    before(async () => {
        const { pool, poolAdmin, configurator, dai, helpersContract } = testEnv;
        mockToken = await new types_2.MintableERC20__factory(await (0, signer_1.getFirstSigner)()).deploy('MOCK', 'MOCK', '18');
        const stableDebtTokenImplementation = await new types_2.StableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const variableDebtTokenImplementation = await new types_2.VariableDebtToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const aTokenImplementation = await new types_2.AToken__factory(await (0, signer_1.getFirstSigner)()).deploy(pool.address);
        const daiData = await pool.getReserveData(dai.address);
        const interestRateStrategyAddress = daiData.interestRateStrategyAddress;
        // Init the reserve
        const initInputParams = [
            {
                aTokenImpl: aTokenImplementation.address,
                stableDebtTokenImpl: stableDebtTokenImplementation.address,
                variableDebtTokenImpl: variableDebtTokenImplementation.address,
                underlyingAssetDecimals: 18,
                interestRateStrategyAddress: interestRateStrategyAddress,
                underlyingAsset: mockToken.address,
                treasury: constants_1.ZERO_ADDRESS,
                incentivesController: constants_1.ZERO_ADDRESS,
                aTokenName: 'AMOCK',
                aTokenSymbol: 'AMOCK',
                variableDebtTokenName: 'VMOCK',
                variableDebtTokenSymbol: 'VMOCK',
                stableDebtTokenName: 'SMOCK',
                stableDebtTokenSymbol: 'SMOCK',
                params: '0x10',
            },
        ];
        // Add the mock reserve
        await configurator.connect(poolAdmin.signer).initReserves(initInputParams);
        // Configuration
        const daiReserveConfigurationData = await helpersContract.getReserveConfigurationData(dai.address);
        const inputParams = [
            {
                asset: mockToken.address,
                baseLTV: daiReserveConfigurationData.ltv,
                liquidationThreshold: daiReserveConfigurationData.liquidationThreshold,
                liquidationBonus: daiReserveConfigurationData.liquidationBonus,
                reserveFactor: daiReserveConfigurationData.reserveFactor,
                borrowCap: 68719476735,
                supplyCap: 68719476735,
                stableBorrowingEnabled: true,
                borrowingEnabled: true,
            },
        ];
        const i = 0;
        await configurator
            .connect(poolAdmin.signer)
            .configureReserveAsCollateral(inputParams[i].asset, inputParams[i].baseLTV, inputParams[i].liquidationThreshold, inputParams[i].liquidationBonus);
        await configurator.connect(poolAdmin.signer).setReserveBorrowing(inputParams[i].asset, true);
        await configurator.setBorrowCap(inputParams[i].asset, inputParams[i].borrowCap);
        await configurator.setReserveStableRateBorrowing(inputParams[i].asset, inputParams[i].stableBorrowingEnabled);
        await configurator
            .connect(poolAdmin.signer)
            .setSupplyCap(inputParams[i].asset, inputParams[i].supplyCap);
        await configurator
            .connect(poolAdmin.signer)
            .setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor);
        const reserveData = await pool.getReserveData(mockToken.address);
        aMockToken = types_2.ERC20__factory.connect(reserveData.aTokenAddress, await (0, signer_1.getFirstSigner)());
        mockStableDebt = types_2.ERC20__factory.connect(reserveData.stableDebtTokenAddress, await (0, signer_1.getFirstSigner)());
        mockVariableDebt = types_2.ERC20__factory.connect(reserveData.variableDebtTokenAddress, await (0, signer_1.getFirstSigner)());
    });
    it('Deposit mock tokens into aave', async () => {
        const { pool, users: [user], faucetMintable } = testEnv;
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        await faucetMintable.mint(mockToken.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '10000'));
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '1000'), user.address, 0);
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aMockToken.address, '1000'));
    });
    it('Transfer aMock tokens', async () => {
        const { users: [sender, receiver], } = testEnv;
        (0, chai_1.expect)(await aMockToken.balanceOf(sender.address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aMockToken.address, '1000'));
        (0, chai_1.expect)(await aMockToken.balanceOf(receiver.address)).to.be.eq(0);
        await aMockToken
            .connect(sender.signer)
            .transfer(receiver.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(aMockToken.address, '1000'));
        (0, chai_1.expect)(await aMockToken.balanceOf(sender.address)).to.be.eq(0);
        (0, chai_1.expect)(await aMockToken.balanceOf(receiver.address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(aMockToken.address, '1000'));
    });
    it('Borrow mock tokens with stable rate', async () => {
        const { pool, users: [, , user], dai, faucetMintable } = testEnv;
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockVariableDebt.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockStableDebt.balanceOf(user.address)).to.be.eq(0);
        await faucetMintable.mint(dai.address, user.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000'));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000'), user.address, 0);
        await pool
            .connect(user.signer)
            .borrow(mockToken.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100'), types_1.RateMode.Stable, 0, user.address);
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100'));
        (0, chai_1.expect)(await mockVariableDebt.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockStableDebt.balanceOf(user.address)).to.be.eq(await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockStableDebt.address, '100'));
    });
    it('Repay mock tokens', async () => {
        const { pool, users: [, , user], faucetMintable } = testEnv;
        const mintAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100');
        await faucetMintable.mint(mockToken.address, user.address, mintAmount);
        const expectedMockTokenBalance = mintAmount.add(await (0, contracts_helpers_1.convertToCurrencyDecimals)(mockToken.address, '100'));
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(expectedMockTokenBalance);
        (0, chai_1.expect)(await mockVariableDebt.balanceOf(user.address)).to.be.eq(0);
        await mockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const time = await (0, misc_utils_1.timeLatest)();
        await (0, misc_utils_1.setBlocktime)(time.add(1).toNumber());
        const stableDebtBefore = await mockStableDebt.balanceOf(user.address, { blockTag: 'pending' });
        await pool
            .connect(user.signer)
            .repay(mockToken.address, stableDebtBefore, types_1.RateMode.Stable, user.address);
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(expectedMockTokenBalance.sub(stableDebtBefore));
        (0, chai_1.expect)(await mockVariableDebt.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockStableDebt.balanceOf(user.address)).to.be.eq(0);
    });
    it('Withdraw aMock tokens', async () => {
        const { pool, users: [, user], } = testEnv;
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(0);
        const aMockTokenBalanceBefore = await aMockToken.balanceOf(user.address, {
            blockTag: 'pending',
        });
        await aMockToken.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .withdraw(mockToken.address, aMockTokenBalanceBefore, user.address);
        (0, chai_1.expect)(await aMockToken.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await mockToken.balanceOf(user.address)).to.be.eq(aMockTokenBalanceBefore);
    });
});
