"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const contract_deployments_1 = require("@aave/deploy-v3/dist/helpers/contract-deployments");
const types_2 = require("../types");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('PausablePool', (testEnv) => {
    let _mockFlashLoanReceiver = {};
    const { RESERVE_PAUSED, INVALID_FROM_BALANCE_AFTER_TRANSFER, INVALID_TO_BALANCE_AFTER_TRANSFER } = types_1.ProtocolErrors;
    before(async () => {
        _mockFlashLoanReceiver = await (0, contract_getters_1.getMockFlashLoanReceiver)();
    });
    it('User 0 deposits 1000 DAI. Configurator pauses pool. Transfers to user 1 reverts. Configurator unpauses the network and next transfer succeeds', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0');
        const user0Balance = await aDai.balanceOf(users[0].address);
        const user1Balance = await aDai.balanceOf(users[1].address);
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // User 0 tries the transfer to User 1
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit)).to.revertedWith(RESERVE_PAUSED);
        const pausedFromBalance = await aDai.balanceOf(users[0].address);
        const pausedToBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(pausedFromBalance).to.be.equal(user0Balance.toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(pausedToBalance.toString()).to.be.equal(user1Balance.toString(), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setPoolPause(false);
        // User 0 succeeds transfer to User 1
        await aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit);
        const fromBalance = await aDai.balanceOf(users[0].address);
        const toBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(fromBalance.toString()).to.be.equal(user0Balance.sub(amountDAItoDeposit), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(toBalance.toString()).to.be.equal(user1Balance.add(amountDAItoDeposit), INVALID_TO_BALANCE_AFTER_TRANSFER);
    });
    it('Deposit', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        await (0, chai_1.expect)(pool.connect(users[0].signer).deposit(dai.address, amountDAItoDeposit, users[0].address, '0')).to.revertedWith(RESERVE_PAUSED);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Withdraw', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0');
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // user tries to burn
        await (0, chai_1.expect)(pool.connect(users[0].signer).withdraw(dai.address, amountDAItoDeposit, users[0].address)).to.revertedWith(RESERVE_PAUSED);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Borrow', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause the pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // Try to execute liquidation
        await (0, chai_1.expect)(pool.connect(user.signer).borrow(dai.address, '1', '1', '0', user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause the pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Repay', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause the pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // Try to execute liquidation
        await (0, chai_1.expect)(pool.connect(user.signer).repay(dai.address, '1', '1', user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause the pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Flash loan', async () => {
        const { dai, pool, weth, users, configurator } = testEnv;
        const caller = users[3];
        const flashAmount = ethers_1.utils.parseEther('0.8');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        // Pause pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], caller.address, '0x10', '0')).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Liquidation call', async () => {
        const { users, pool, usdc, oracle, weth, configurator, helpersContract, faucetMintable, deployer } = testEnv;
        const depositor = users[3];
        const borrower = users[4];
        //mints USDC to depositor
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access depositor wallet
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 3 deposits 1000 USDC
        const amountUSDCtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, amountUSDCtoDeposit, depositor.address, '0');
        //user 4 deposits ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.06775');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, amountETHtoDeposit);
        //approve protocol to access borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //user 4 borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        const amountUSDCToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, userGlobalData.availableBorrowsBase.div(usdcPrice).percentMul(9502).toString());
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, amountUSDCToBorrow, types_1.RateMode.Stable, '0', borrower.address);
        // Drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(12000));
        //mints dai to the liquidator
        await faucetMintable.mint(usdc.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2).toString();
        // Pause pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // Do liquidation
        await (0, chai_1.expect)(pool.liquidationCall(weth.address, usdc.address, borrower.address, amountToLiquidate, true)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('SwapBorrowRateMode', async () => {
        const { pool, weth, dai, usdc, users, configurator, faucetMintable } = testEnv;
        const user = users[1];
        const amountWETHToDeposit = ethers_1.utils.parseEther('10');
        const amountDAIToDeposit = ethers_1.utils.parseEther('120');
        const amountToBorrow = ethers_1.utils.parseUnits('65', 6);
        await faucetMintable.mint(weth.address, user.address, amountWETHToDeposit);
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(weth.address, amountWETHToDeposit, user.address, '0');
        await faucetMintable.mint(dai.address, user.address, amountDAIToDeposit);
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(dai.address, amountDAIToDeposit, user.address, '0');
        await pool.connect(user.signer).borrow(usdc.address, amountToBorrow, 2, 0, user.address);
        // Pause pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        // Try to repay
        await (0, chai_1.expect)(pool.connect(user.signer).swapBorrowRateMode(usdc.address, types_1.RateMode.Stable)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('RebalanceStableBorrowRate', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        await (0, chai_1.expect)(pool.connect(user.signer).rebalanceStableBorrowRate(dai.address, user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('setUserUseReserveAsCollateral', async () => {
        const { pool, weth, users, configurator, faucetMintable } = testEnv;
        const user = users[1];
        const amountWETHToDeposit = ethers_1.utils.parseEther('1');
        await faucetMintable.mint(weth.address, user.address, amountWETHToDeposit);
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(weth.address, amountWETHToDeposit, user.address, '0');
        // Pause pool
        await configurator.connect(users[1].signer).setPoolPause(true);
        await (0, chai_1.expect)(pool.connect(user.signer).setUserUseReserveAsCollateral(weth.address, false)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setPoolPause(false);
    });
    it('Configurator pauses Pool with a ZERO_ADDRESS reserve', async () => {
        const { poolAdmin, emergencyAdmin, deployer } = testEnv;
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        // Deploy a mock Pool
        const mockPool = await (0, contract_deployments_1.deployMockPool)();
        // Deploy a new PoolConfigurator
        const configuratorLogic = await (await new types_2.ConfiguratorLogic__factory(await (0, signer_1.getFirstSigner)()).deploy()).deployed();
        const poolConfigurator = await (await new types_2.PoolConfigurator__factory({
            ['contracts/protocol/libraries/logic/ConfiguratorLogic.sol:ConfiguratorLogic']: configuratorLogic.address,
        }, await (0, signer_1.getFirstSigner)()).deploy()).deployed();
        // Deploy a new PoolAddressesProvider
        const MARKET_ID = '1';
        const poolAddressesProvider = await (await new types_2.PoolAddressesProvider__factory(await (0, signer_1.getFirstSigner)()).deploy(MARKET_ID, deployer.address)).deployed();
        // Set the ACL admin
        (0, chai_1.expect)(await poolAddressesProvider.setACLAdmin(poolAdmin.address));
        // Update the ACLManager
        const aclManager = await (await new types_2.ACLManager__factory(await (0, signer_1.getFirstSigner)()).deploy(poolAddressesProvider.address)).deployed();
        await (0, chai_1.expect)(poolAddressesProvider.setACLManager(aclManager.address))
            .to.emit(poolAddressesProvider, 'ACLManagerUpdated')
            .withArgs(constants_1.ZERO_ADDRESS, aclManager.address);
        // Set role of EmergencyAdmin
        const emergencyAdminRole = await aclManager.EMERGENCY_ADMIN_ROLE();
        await (0, chai_1.expect)(aclManager.addEmergencyAdmin(emergencyAdmin.address))
            .to.emit(aclManager, 'RoleGranted')
            .withArgs(emergencyAdminRole, emergencyAdmin.address, poolAdmin.address);
        // Update the Pool impl with a MockPool
        await (0, chai_1.expect)(poolAddressesProvider.setPoolImpl(mockPool.address))
            .to.emit(poolAddressesProvider, 'PoolUpdated')
            .withArgs(constants_1.ZERO_ADDRESS, mockPool.address);
        // Add ZERO_ADDRESS as a reserve
        const proxiedMockPoolAddress = await poolAddressesProvider.getPool();
        const proxiedMockPool = await (0, contract_getters_1.getMockPool)(proxiedMockPoolAddress);
        (0, chai_1.expect)(await proxiedMockPool.addReserveToReservesList(constants_1.ZERO_ADDRESS));
        // Update the PoolConfigurator impl with the PoolConfigurator
        await (0, chai_1.expect)(poolAddressesProvider.setPoolConfiguratorImpl(poolConfigurator.address))
            .to.emit(poolAddressesProvider, 'PoolConfiguratorUpdated')
            .withArgs(constants_1.ZERO_ADDRESS, poolConfigurator.address);
        const proxiedPoolConfiguratorAddress = await poolAddressesProvider.getPoolConfigurator();
        const proxiedPoolConfigurator = await (0, contract_getters_1.getPoolConfiguratorProxy)(proxiedPoolConfiguratorAddress);
        // Pause reserve
        (0, chai_1.expect)(await proxiedPoolConfigurator.connect(emergencyAdmin.signer).setPoolPause(true));
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
});
