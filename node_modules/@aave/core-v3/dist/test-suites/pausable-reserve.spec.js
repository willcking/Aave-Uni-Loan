"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
(0, make_suite_1.makeSuite)('PausableReserve', (testEnv) => {
    let _mockFlashLoanReceiver = {};
    const { RESERVE_PAUSED, INVALID_FROM_BALANCE_AFTER_TRANSFER, INVALID_TO_BALANCE_AFTER_TRANSFER } = types_1.ProtocolErrors;
    before(async () => {
        _mockFlashLoanReceiver = await (0, contract_getters_1.getMockFlashLoanReceiver)();
    });
    it('User 0 deposits 1000 DAI. Configurator pauses pool. Transfers to user 1 reverts. Configurator unpauses the network and next transfer succeeds', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0');
        const user0Balance = await aDai.balanceOf(users[0].address);
        const user1Balance = await aDai.balanceOf(users[1].address);
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        // User 0 tries the transfer to User 1
        await (0, chai_1.expect)(aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit)).to.revertedWith(RESERVE_PAUSED);
        const pausedFromBalance = await aDai.balanceOf(users[0].address);
        const pausedToBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(pausedFromBalance).to.be.equal(user0Balance.toString(), INVALID_TO_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(pausedToBalance.toString()).to.be.equal(user1Balance.toString(), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
        // User 0 succeeds transfer to User 1
        await aDai.connect(users[0].signer).transfer(users[1].address, amountDAItoDeposit);
        const fromBalance = await aDai.balanceOf(users[0].address);
        const toBalance = await aDai.balanceOf(users[1].address);
        (0, chai_1.expect)(fromBalance.toString()).to.be.equal(user0Balance.sub(amountDAItoDeposit), INVALID_FROM_BALANCE_AFTER_TRANSFER);
        (0, chai_1.expect)(toBalance.toString()).to.be.equal(user1Balance.add(amountDAItoDeposit), INVALID_TO_BALANCE_AFTER_TRANSFER);
    });
    it('Deposit', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        await (0, chai_1.expect)(pool.connect(users[0].signer).deposit(dai.address, amountDAItoDeposit, users[0].address, '0')).to.revertedWith(RESERVE_PAUSED);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
    });
    it('Withdraw', async () => {
        const { users, pool, dai, aDai, configurator, faucetMintable } = testEnv;
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await faucetMintable.mint(dai.address, users[0].address, amountDAItoDeposit);
        // user 0 deposits 1000 DAI
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, amountDAItoDeposit, users[0].address, '0');
        // Configurator pauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        // user tries to burn
        await (0, chai_1.expect)(pool.connect(users[0].signer).withdraw(dai.address, amountDAItoDeposit, users[0].address)).to.revertedWith(RESERVE_PAUSED);
        // Configurator unpauses the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
    });
    it('Borrow', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        // Try to execute liquidation
        await (0, chai_1.expect)(pool.connect(user.signer).borrow(dai.address, '1', '1', '0', user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
    });
    it('Repay', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        // Try to execute liquidation
        await (0, chai_1.expect)(pool.connect(user.signer).repay(dai.address, '1', '1', user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause the pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
    });
    it('Flash loan', async () => {
        const { dai, pool, weth, users, configurator } = testEnv;
        const caller = users[3];
        const flashAmount = ethers_1.utils.parseEther('0.8');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        // Pause pool
        await configurator.connect(users[1].signer).setReservePause(weth.address, true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], caller.address, '0x10', '0')).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setReservePause(weth.address, false);
    });
    it('Liquidation call', async () => {
        const { users, pool, usdc, oracle, weth, configurator, helpersContract, faucetMintable, deployer } = testEnv;
        const depositor = users[3];
        const borrower = users[4];
        //mints USDC to depositor
        await faucetMintable.mint(usdc.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        //approve protocol to access depositor wallet
        await usdc.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 3 deposits 1000 USDC
        const amountUSDCtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        await pool
            .connect(depositor.signer)
            .deposit(usdc.address, amountUSDCtoDeposit, depositor.address, '0');
        //user 4 deposits ETH
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.06775');
        //mints WETH to borrower
        await faucetMintable.mint(weth.address, borrower.address, amountETHtoDeposit);
        //approve protocol to access borrower wallet
        await weth.connect(borrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(borrower.signer)
            .deposit(weth.address, amountETHtoDeposit, borrower.address, '0');
        //user 4 borrows
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        const usdcPrice = await oracle.getAssetPrice(usdc.address);
        const amountUSDCToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, userGlobalData.availableBorrowsBase.div(usdcPrice).percentMul(9502).toString());
        await pool
            .connect(borrower.signer)
            .borrow(usdc.address, amountUSDCToBorrow, types_1.RateMode.Stable, '0', borrower.address);
        // Drops HF below 1
        await oracle.setAssetPrice(usdc.address, usdcPrice.percentMul(12000));
        //mints dai to the liquidator
        await faucetMintable.mint(usdc.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await helpersContract.getUserReserveData(usdc.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentStableDebt.div(2);
        // Pause pool
        await configurator.connect(users[1].signer).setReservePause(usdc.address, true);
        // Do liquidation
        await (0, chai_1.expect)(pool.liquidationCall(weth.address, usdc.address, borrower.address, amountToLiquidate, true)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setReservePause(usdc.address, false);
    });
    it('SwapBorrowRateMode', async () => {
        const { pool, weth, dai, usdc, users, configurator, faucetMintable } = testEnv;
        const user = users[1];
        const amountWETHToDeposit = ethers_1.utils.parseEther('10');
        const amountDAIToDeposit = ethers_1.utils.parseEther('120');
        const amountToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '65');
        await faucetMintable.mint(weth.address, user.address, amountWETHToDeposit);
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(weth.address, amountWETHToDeposit, user.address, '0');
        await faucetMintable.mint(dai.address, user.address, amountDAIToDeposit);
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(dai.address, amountDAIToDeposit, user.address, '0');
        await pool.connect(user.signer).borrow(usdc.address, amountToBorrow, 2, 0, user.address);
        // Pause pool
        await configurator.connect(users[1].signer).setReservePause(usdc.address, true);
        // Try to repay
        await (0, chai_1.expect)(pool.connect(user.signer).swapBorrowRateMode(usdc.address, types_1.RateMode.Stable)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setReservePause(usdc.address, false);
    });
    it('RebalanceStableBorrowRate', async () => {
        const { pool, dai, users, configurator } = testEnv;
        const user = users[1];
        // Pause pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, true);
        await (0, chai_1.expect)(pool.connect(user.signer).rebalanceStableBorrowRate(dai.address, user.address)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setReservePause(dai.address, false);
    });
    it('setUserUseReserveAsCollateral', async () => {
        const { pool, weth, users, configurator, faucetMintable } = testEnv;
        const user = users[1];
        const amountWETHToDeposit = ethers_1.utils.parseEther('1');
        await faucetMintable.mint(weth.address, user.address, amountWETHToDeposit);
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(user.signer).deposit(weth.address, amountWETHToDeposit, user.address, '0');
        // Pause pool
        await configurator.connect(users[1].signer).setReservePause(weth.address, true);
        await (0, chai_1.expect)(pool.connect(user.signer).setUserUseReserveAsCollateral(weth.address, false)).to.be.revertedWith(RESERVE_PAUSED);
        // Unpause pool
        await configurator.connect(users[1].signer).setReservePause(weth.address, false);
    });
});
