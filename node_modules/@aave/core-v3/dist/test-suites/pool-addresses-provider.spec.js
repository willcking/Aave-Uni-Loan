"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hardhat_1 = __importDefault(require("hardhat"));
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const misc_utils_1 = require("../helpers/misc-utils");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
const contract_deployments_1 = require("@aave/deploy-v3/dist/helpers/contract-deployments");
const deploy_v3_1 = require("@aave/deploy-v3");
const types_2 = require("../types");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
(0, make_suite_1.makeSuite)('PoolAddressesProvider', (testEnv) => {
    const { OWNABLE_ONLY_OWNER } = types_1.ProtocolErrors;
    it('Test the onlyOwner accessibility of the PoolAddressesProvider', async () => {
        const { addressesProvider, users } = testEnv;
        const mockAddress = (0, misc_utils_1.createRandomAddress)();
        // Transfer ownership to user 1
        await addressesProvider.transferOwnership(users[1].address);
        // Test accessibility with user 0
        for (const contractFunction of [
            addressesProvider.setMarketId,
            addressesProvider.setPoolImpl,
            addressesProvider.setPoolConfiguratorImpl,
            addressesProvider.setPriceOracle,
            addressesProvider.setACLAdmin,
            addressesProvider.setPriceOracleSentinel,
            addressesProvider.setPoolDataProvider,
        ]) {
            await (0, chai_1.expect)(contractFunction(mockAddress)).to.be.revertedWith(OWNABLE_ONLY_OWNER);
        }
        await (0, chai_1.expect)(addressesProvider.setAddress(ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('RANDOM_ID')), mockAddress)).to.be.revertedWith(OWNABLE_ONLY_OWNER);
        await (0, chai_1.expect)(addressesProvider.setAddressAsProxy(ethers_1.utils.keccak256(ethers_1.utils.toUtf8Bytes('RANDOM_ID')), mockAddress)).to.be.revertedWith(OWNABLE_ONLY_OWNER);
    });
    it('Owner adds a new address as proxy', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const mockPool = await (0, contract_deployments_1.deployPool)();
        const proxiedAddressId = ethers_1.utils.formatBytes32String('RANDOM_PROXIED');
        await (0, chai_1.expect)(addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddressAsProxy(proxiedAddressId, mockPool.address))
            .to.emit(addressesProvider, 'AddressSetAsProxy')
            .to.emit(addressesProvider, 'ProxyCreated');
        const proxyAddress = await addressesProvider.getAddress(proxiedAddressId);
        const implAddress = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        (0, chai_1.expect)(implAddress).to.be.eq(mockPool.address);
    });
    it('Owner adds a new address with no proxy', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const mockNonProxiedAddress = (0, misc_utils_1.createRandomAddress)();
        const nonProxiedAddressId = ethers_1.utils.formatBytes32String('RANDOM_NON_PROXIED');
        const oldAddress = await addressesProvider.getAddress(nonProxiedAddressId);
        await (0, chai_1.expect)(addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(nonProxiedAddressId, mockNonProxiedAddress))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(nonProxiedAddressId, oldAddress, mockNonProxiedAddress);
        (0, chai_1.expect)((await addressesProvider.getAddress(nonProxiedAddressId)).toLowerCase()).to.be.eq(mockNonProxiedAddress.toLowerCase());
        const proxyAddress = await addressesProvider.getAddress(nonProxiedAddressId);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress)).to.be.reverted;
    });
    it('Owner adds a new address with no proxy and turns it into a proxy', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const mockPool = await (0, contract_deployments_1.deployPool)();
        const mockConvertibleAddress = mockPool.address;
        const convertibleAddressId = ethers_1.utils.formatBytes32String('CONVERTIBLE_ADDRESS');
        (0, chai_1.expect)(await addressesProvider.getAddress(convertibleAddressId)).to.be.eq(constants_1.ZERO_ADDRESS);
        const oldNonProxiedAddress = await addressesProvider.getAddress(convertibleAddressId);
        // Add address as non proxy
        await (0, chai_1.expect)(addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, mockConvertibleAddress))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, oldNonProxiedAddress, mockConvertibleAddress);
        let registeredAddress = await addressesProvider.getAddress(convertibleAddressId);
        (0, chai_1.expect)(registeredAddress).to.be.eq(mockConvertibleAddress);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, registeredAddress)).to.be
            .reverted;
        // Unregister address as non proxy
        await (0, chai_1.expect)(addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, constants_1.ZERO_ADDRESS))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, mockConvertibleAddress, constants_1.ZERO_ADDRESS);
        // Add address as proxy
        await (0, chai_1.expect)(addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddressAsProxy(convertibleAddressId, mockConvertibleAddress))
            .to.emit(addressesProvider, 'AddressSetAsProxy')
            .to.emit(addressesProvider, 'ProxyCreated');
        const proxyAddress = await addressesProvider.getAddress(convertibleAddressId);
        const implAddress = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        (0, chai_1.expect)(implAddress).to.be.eq(mockConvertibleAddress);
    });
    it('Unregister a proxy address', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const convertibleAddressId = ethers_1.utils.formatBytes32String('CONVERTIBLE_ADDRESS');
        const proxyAddress = await addressesProvider.getAddress(convertibleAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, constants_1.ZERO_ADDRESS))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, proxyAddress, constants_1.ZERO_ADDRESS);
        const proxyAddressAfter = await addressesProvider.getAddress(convertibleAddressId);
        (0, chai_1.expect)(proxyAddressAfter).to.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(proxyAddressAfter).to.be.not.eq(proxyAddress);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddressAfter)).to.be
            .reverted;
    });
    it('Owner adds a new address with proxy and turns it into a no proxy', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const mockPool = await (0, contract_deployments_1.deployPool)();
        const mockConvertibleAddress = mockPool.address;
        const convertibleAddressId = ethers_1.utils.formatBytes32String('CONVERTIBLE_ADDRESS2');
        (0, chai_1.expect)(await addressesProvider.getAddress(convertibleAddressId)).to.be.eq(constants_1.ZERO_ADDRESS);
        // Add address as proxy
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddressAsProxy(convertibleAddressId, mockConvertibleAddress))
            .to.emit(addressesProvider, 'AddressSetAsProxy')
            .to.emit(addressesProvider, 'ProxyCreated');
        const proxyAddress = await addressesProvider.getAddress(convertibleAddressId);
        const implAddress = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        (0, chai_1.expect)(implAddress).to.be.eq(mockConvertibleAddress);
        // Unregister address as proxy
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, constants_1.ZERO_ADDRESS))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, proxyAddress, constants_1.ZERO_ADDRESS);
        // Add address as non proxy
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, mockConvertibleAddress))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, constants_1.ZERO_ADDRESS, mockConvertibleAddress);
        const registeredAddressAfter = await addressesProvider.getAddress(convertibleAddressId);
        (0, chai_1.expect)(registeredAddressAfter).to.be.not.eq(proxyAddress);
        (0, chai_1.expect)(registeredAddressAfter).to.be.eq(mockConvertibleAddress);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, registeredAddressAfter)).to.be
            .reverted;
    });
    it('Unregister a no proxy address', async () => {
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const convertibleAddressId = ethers_1.utils.formatBytes32String('CONVERTIBLE_ADDRESS2');
        const registeredAddress = await addressesProvider.getAddress(convertibleAddressId);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, registeredAddress)).to.be
            .reverted;
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(convertibleAddressId, constants_1.ZERO_ADDRESS))
            .to.emit(addressesProvider, 'AddressSet')
            .withArgs(convertibleAddressId, registeredAddress, constants_1.ZERO_ADDRESS);
        const registeredAddressAfter = await addressesProvider.getAddress(convertibleAddressId);
        (0, chai_1.expect)(registeredAddressAfter).to.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(registeredAddressAfter).to.be.not.eq(registeredAddress);
        await (0, chai_1.expect)((0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, registeredAddress)).to.be
            .reverted;
    });
    it('Owner registers an existing contract (with proxy) and upgrade it', async () => {
        const { addressesProvider, users, poolAdmin } = testEnv;
        const proxyAdminOwner = users[0];
        const currentAddressesProviderOwner = users[1];
        const initialManager = users[1];
        const initialProxyAdmin = users[2];
        const newRegisteredContractId = hardhat_1.default.ethers.utils.keccak256(hardhat_1.default.ethers.utils.toUtf8Bytes('NEW_REGISTERED_CONTRACT'));
        // Deploy the periphery contract that will be registered in the PoolAddressesProvider
        const proxy = await (await new deploy_v3_1.InitializableAdminUpgradeabilityProxy__factory(await (0, deploy_v3_1.getFirstSigner)()).deploy()).deployed();
        // Implementation
        const impleV1 = await (await new types_2.MockPeripheryContractV1__factory(await (0, deploy_v3_1.getFirstSigner)()).deploy()).deployed();
        await impleV1.initialize(initialManager.address, 123);
        // Initialize proxy
        const incentivesInit = impleV1.interface.encodeFunctionData('initialize', [
            initialManager.address,
            123,
        ]);
        await (await proxy['initialize(address,address,bytes)'](impleV1.address, // logic
        initialProxyAdmin.address, // admin
        incentivesInit // data
        )).wait();
        (0, chai_1.expect)(await (0, contracts_helpers_1.getProxyAdmin)(proxy.address)).to.be.eq(initialProxyAdmin.address);
        const contractToRegister = types_2.MockPeripheryContractV1__factory.connect(proxy.address, proxyAdminOwner.signer);
        (0, chai_1.expect)(await contractToRegister.getManager()).to.be.eq(initialManager.address);
        // Register the periphery contract into the PoolAddressesProvider
        (0, chai_1.expect)(await proxy.connect(initialProxyAdmin.signer).changeAdmin(addressesProvider.address));
        (0, chai_1.expect)(await (0, contracts_helpers_1.getProxyAdmin)(proxy.address)).to.be.eq(addressesProvider.address);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddress(newRegisteredContractId, proxy.address));
        (0, chai_1.expect)(await addressesProvider.getAddress(newRegisteredContractId)).to.be.eq(proxy.address);
        // Upgrade periphery contract to V2 from PoolAddressesProvider
        // Note the new implementation contract should has a proper `initialize` function signature
        // New implementation
        const impleV2 = await (await new types_2.MockPeripheryContractV2__factory(await (0, deploy_v3_1.getFirstSigner)()).deploy()).deployed();
        await impleV2.initialize(addressesProvider.address);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setAddressAsProxy(newRegisteredContractId, impleV2.address));
        const upgradedContract = types_2.MockPeripheryContractV2__factory.connect(proxy.address, proxyAdminOwner.signer);
        (0, chai_1.expect)(await upgradedContract.getManager()).to.be.eq(initialManager.address);
        (0, chai_1.expect)(await upgradedContract.getAddressesProvider()).to.be.eq(addressesProvider.address);
    });
    it('Owner updates the implementation of a proxy which is already initialized', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const mockPool = await (0, contract_deployments_1.deployMockPool)();
        // Pool has already a proxy
        const poolAddress = await addressesProvider.getPool();
        (0, chai_1.expect)(poolAddress).to.be.not.eq(constants_1.ZERO_ADDRESS);
        const poolAddressId = ethers_1.utils.formatBytes32String('POOL');
        const proxyAddress = await addressesProvider.getAddress(poolAddressId);
        const implementationAddress = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        // Update the Pool proxy
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setPoolImpl(mockPool.address))
            .to.emit(addressesProvider, 'PoolUpdated')
            .withArgs(implementationAddress, mockPool.address);
        // Pool address should not change
        (0, chai_1.expect)(await addressesProvider.getPool()).to.be.eq(poolAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the MarketId', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const NEW_MARKET_ID = 'NEW_MARKET';
        // Current MarketId
        const oldMarketId = await addressesProvider.getMarketId();
        // Update the MarketId
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setMarketId(NEW_MARKET_ID))
            .to.emit(addressesProvider, 'MarketIdSet')
            .withArgs(oldMarketId, NEW_MARKET_ID);
        (0, chai_1.expect)(await addressesProvider.getMarketId()).to.be.not.eq(oldMarketId);
        (0, chai_1.expect)(await addressesProvider.getMarketId()).to.be.eq(NEW_MARKET_ID);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the PoolConfigurator', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, configurator, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const newPoolConfiguratorImpl = (await (0, contract_deployments_1.deployMockPool)()).address;
        (0, chai_1.expect)(await addressesProvider.getPoolConfigurator(), configurator.address);
        const poolConfiguratorAddressId = ethers_1.utils.formatBytes32String('POOL_CONFIGURATOR');
        const proxyAddress = await addressesProvider.getAddress(poolConfiguratorAddressId);
        const implementationAddress = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setPoolConfiguratorImpl(newPoolConfiguratorImpl))
            .to.emit(addressesProvider, 'PoolConfiguratorUpdated')
            .withArgs(implementationAddress, newPoolConfiguratorImpl);
        (0, chai_1.expect)(await addressesProvider.getPoolConfigurator()).to.be.eq(configurator.address);
        const implementationAddressAfter = await (0, contracts_helpers_1.getProxyImplementation)(addressesProvider.address, proxyAddress);
        (0, chai_1.expect)(implementationAddressAfter).to.be.not.eq(implementationAddress);
        (0, chai_1.expect)(implementationAddressAfter).to.be.eq(newPoolConfiguratorImpl);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the PriceOracle', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, oracle, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const newPriceOracleAddress = (0, misc_utils_1.createRandomAddress)();
        (0, chai_1.expect)(await addressesProvider.getPriceOracle(), oracle.address);
        const priceOracleAddressId = ethers_1.utils.formatBytes32String('PRICE_ORACLE');
        const registeredAddress = await addressesProvider.getAddress(priceOracleAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setPriceOracle(newPriceOracleAddress))
            .to.emit(addressesProvider, 'PriceOracleUpdated')
            .withArgs(registeredAddress, newPriceOracleAddress);
        (0, chai_1.expect)(await addressesProvider.getPriceOracle()).to.be.not.eq(oracle.address);
        (0, chai_1.expect)(await addressesProvider.getPriceOracle()).to.be.eq(newPriceOracleAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the ACLManager', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, users, aclManager } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const newACLManagerAddress = (0, misc_utils_1.createRandomAddress)();
        (0, chai_1.expect)(await addressesProvider.getACLManager(), aclManager.address);
        const aclManagerAddressId = ethers_1.utils.formatBytes32String('ACL_MANAGER');
        const registeredAddress = await addressesProvider.getAddress(aclManagerAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setACLManager(newACLManagerAddress))
            .to.emit(addressesProvider, 'ACLManagerUpdated')
            .withArgs(registeredAddress, newACLManagerAddress);
        (0, chai_1.expect)(await addressesProvider.getACLManager()).to.be.not.eq(aclManager.address);
        (0, chai_1.expect)(await addressesProvider.getACLManager()).to.be.eq(newACLManagerAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the ACLAdmin', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, users } = testEnv;
        const { aclAdmin: aclAdminAddress } = await hardhat_1.default.getNamedAccounts();
        const currentAddressesProviderOwner = users[1];
        const newACLAdminAddress = (0, misc_utils_1.createRandomAddress)();
        (0, chai_1.expect)(await addressesProvider.getACLAdmin(), aclAdminAddress);
        const aclAdminAddressId = ethers_1.utils.formatBytes32String('ACL_ADMIN');
        const registeredAddress = await addressesProvider.getAddress(aclAdminAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setACLAdmin(newACLAdminAddress))
            .to.emit(addressesProvider, 'ACLAdminUpdated')
            .withArgs(registeredAddress, newACLAdminAddress);
        (0, chai_1.expect)(await addressesProvider.getACLAdmin()).to.be.not.eq(aclAdminAddress);
        (0, chai_1.expect)(await addressesProvider.getACLAdmin()).to.be.eq(newACLAdminAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the PriceOracleSentinel', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        const newPriceOracleSentinelAddress = (0, misc_utils_1.createRandomAddress)();
        const priceOracleSentinelAddressId = ethers_1.utils.formatBytes32String('PRICE_ORACLE_SENTINEL');
        const registeredAddress = await addressesProvider.getAddress(priceOracleSentinelAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setPriceOracleSentinel(newPriceOracleSentinelAddress))
            .to.emit(addressesProvider, 'PriceOracleSentinelUpdated')
            .withArgs(registeredAddress, newPriceOracleSentinelAddress);
        (0, chai_1.expect)(await addressesProvider.getPriceOracleSentinel()).to.be.not.eq(registeredAddress);
        (0, chai_1.expect)(await addressesProvider.getPriceOracleSentinel()).to.be.eq(newPriceOracleSentinelAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Owner updates the DataProvider', async () => {
        const snapId = await (0, deploy_v3_1.evmSnapshot)();
        const { addressesProvider, helpersContract, users } = testEnv;
        const currentAddressesProviderOwner = users[1];
        (0, chai_1.expect)(await addressesProvider.getPoolDataProvider(), helpersContract.address);
        const newDataProviderAddress = (0, misc_utils_1.createRandomAddress)();
        const dataProviderAddressId = ethers_1.utils.formatBytes32String('DATA_PROVIDER');
        const registeredAddress = await addressesProvider.getAddress(dataProviderAddressId);
        (0, chai_1.expect)(await addressesProvider
            .connect(currentAddressesProviderOwner.signer)
            .setPoolDataProvider(newDataProviderAddress))
            .to.emit(addressesProvider, 'PoolDataProviderUpdated')
            .withArgs(registeredAddress, newDataProviderAddress);
        (0, chai_1.expect)(await addressesProvider.getPoolDataProvider()).to.be.not.eq(helpersContract.address);
        (0, chai_1.expect)(await addressesProvider.getPoolDataProvider()).to.be.eq(newDataProviderAddress);
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
});
