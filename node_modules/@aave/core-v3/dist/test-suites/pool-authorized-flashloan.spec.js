"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const types_1 = require("../helpers/types");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
(0, make_suite_1.makeSuite)('Pool: Authorized FlashLoan', (testEnv) => {
    let _mockFlashLoanReceiver = {};
    const { COLLATERAL_BALANCE_IS_ZERO, ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE, INVALID_FLASHLOAN_EXECUTOR_RETURN, } = types_1.ProtocolErrors;
    before(async () => {
        _mockFlashLoanReceiver = await (0, contract_getters_1.getMockFlashLoanReceiver)();
    });
    it('Authorize a flash borrower', async () => {
        const { deployer, aclManager } = testEnv;
        const flashBorrowerRole = await aclManager.FLASH_BORROWER_ROLE();
        await (0, chai_1.expect)(aclManager.addFlashBorrower(deployer.address))
            .to.emit(aclManager, 'RoleGranted')
            .withArgs(flashBorrowerRole, deployer.address, deployer.address);
    });
    it('Deposits WETH into the reserve', async () => {
        const { pool, weth, faucetMintable, deployer } = testEnv;
        const userAddress = await pool.signer.getAddress();
        const amountToDeposit = ethers_1.utils.parseEther('1');
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, deployer.address, amountToDeposit));
        (0, chai_1.expect)(await weth.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.deposit(weth.address, amountToDeposit, userAddress, '0'));
    });
    it('Takes WETH flash loan with mode = 0, returns the funds correctly', async () => {
        const { pool, helpersContract, weth } = testEnv;
        (0, chai_1.expect)(await pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.utils.parseEther('0.8')], [0], _mockFlashLoanReceiver.address, '0x10', '0'));
        const reserveData = await helpersContract.getReserveData(weth.address);
        const currentLiquidityRate = reserveData.liquidityRate;
        const currentLiquidityIndex = reserveData.liquidityIndex;
        const totalLiquidity = reserveData.totalAToken.add(reserveData.accruedToTreasuryScaled.rayMul(reserveData.liquidityIndex));
        (0, chai_1.expect)(totalLiquidity).to.be.equal('1000000000000000000');
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal('0');
        (0, chai_1.expect)(currentLiquidityIndex).to.be.equal('1000000000000000000000000000');
    });
    it('Takes an ETH flash loan with mode = 0 as big as the available liquidity', async () => {
        const { pool, helpersContract, weth } = testEnv;
        (0, chai_1.expect)(await pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], ['1000000000000000000'], [0], _mockFlashLoanReceiver.address, '0x10', '0'));
        const reserveData = await helpersContract.getReserveData(weth.address);
        const currentLiquidityRate = reserveData.liquidityRate;
        const currentLiquidityIndex = reserveData.liquidityIndex;
        const totalLiquidity = reserveData.totalAToken.add(reserveData.accruedToTreasuryScaled.rayMul(reserveData.liquidityIndex));
        (0, chai_1.expect)(totalLiquidity).to.be.equal('1000000000000000000');
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal('0');
        (0, chai_1.expect)(currentLiquidityIndex).to.be.equal('1000000000000000000000000000');
    });
    it('Takes WETH flashloan, does not return the funds with mode = 0 (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.utils.parseEther('0.8')], [0], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Takes WETH flash loan, simulating a receiver as EOA (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setSimulateEOA(true));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.utils.parseEther('0.8')], [0], caller.address, '0x10', '0')).to.be.revertedWith(INVALID_FLASHLOAN_EXECUTOR_RETURN);
    });
    it('Takes a WETH flashloan with an invalid mode (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setSimulateEOA(false));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.utils.parseEther('0.8')], [4], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller deposits 1000 DAI as collateral, Takes WETH flashloan with mode = 2, does not return the funds. A variable loan for caller is created', async () => {
        const { dai, pool, weth, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[1];
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, caller.address, amountToDeposit));
        (0, chai_1.expect)(await dai.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(caller.signer).deposit(dai.address, amountToDeposit, caller.address, '0'));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        (0, chai_1.expect)(await pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.utils.parseEther('0.0571')], [2], caller.address, '0x10', '0'));
        const { variableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        const wethDebtToken = await (0, contract_getters_1.getVariableDebtToken)(variableDebtTokenAddress);
        const callerDebt = await wethDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal('57100000000000000', 'Invalid user debt');
    });
    it('Tries to take a flashloan that is bigger than the available liquidity (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        await (0, chai_1.expect)(pool.connect(caller.signer).flashLoan(_mockFlashLoanReceiver.address, [weth.address], ['1000000000000000001'], //slightly higher than the available liquidity
        [2], caller.address, '0x10', '0'), ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE).to.be.reverted;
    });
    it('Tries to take a flashloan using a non contract address as receiver (revert expected)', async () => {
        const { pool, deployer, weth, users } = testEnv;
        const caller = users[1];
        await (0, chai_1.expect)(pool.flashLoan(deployer.address, [weth.address], ['1000000000000000000'], [2], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Deposits USDC into the reserve', async () => {
        const { usdc, pool, faucetMintable, deployer } = testEnv;
        const userAddress = await pool.signer.getAddress();
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(usdc.address, deployer.address, amountToDeposit));
        (0, chai_1.expect)(await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.deposit(usdc.address, amountToDeposit, userAddress, '0'));
    });
    it('Takes out a 500 USDC flashloan, returns the funds correctly', async () => {
        const { usdc, pool, helpersContract, deployer: depositor } = testEnv;
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(false));
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        (0, chai_1.expect)(await pool.flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0'));
        const reserveData = await helpersContract.getReserveData(usdc.address);
        const userData = await helpersContract.getUserReserveData(usdc.address, depositor.address);
        const totalLiquidity = reserveData.totalAToken.add(reserveData.accruedToTreasuryScaled.rayMul(reserveData.liquidityIndex));
        const expectedLiquidity = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        (0, chai_1.expect)(totalLiquidity).to.be.equal(expectedLiquidity, 'Invalid total liquidity');
        (0, chai_1.expect)(reserveData.liquidityRate).to.be.equal('0', 'Invalid liquidity rate');
        (0, chai_1.expect)(reserveData.liquidityIndex).to.be.equal(ethers_1.utils.parseUnits('1', 27), 'Invalid liquidity index');
        (0, chai_1.expect)(userData.currentATokenBalance).to.be.equal(expectedLiquidity, 'Invalid user balance');
    });
    it('Takes out a 500 USDC flashloan with mode = 0, does not return the funds (revert expected)', async () => {
        const { usdc, pool, users } = testEnv;
        const caller = users[2];
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [2], caller.address, '0x10', '0')).to.be.revertedWith(COLLATERAL_BALANCE_IS_ZERO);
    });
    it('Caller deposits 5 WETH as collateral, Takes a USDC flashloan with mode = 2, does not return the funds. A loan for caller is created', async () => {
        const { usdc, pool, weth, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[2];
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(weth.address, caller.address, amountToDeposit));
        (0, chai_1.expect)(await weth.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(caller.signer).deposit(weth.address, amountToDeposit, caller.address, '0'));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        (0, chai_1.expect)(await pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [2], caller.address, '0x10', '0'));
        const { variableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(usdc.address);
        const usdcDebtToken = await (0, contract_getters_1.getVariableDebtToken)(variableDebtTokenAddress);
        const callerDebt = await usdcDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal('500000000', 'Invalid user debt');
    });
    it('Caller deposits 1000 DAI as collateral, Takes a WETH flashloan with mode = 0, does not approve the transfer of the funds (revert expected)', async () => {
        const { dai, pool, weth, users, faucetMintable } = testEnv;
        const caller = users[3];
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, caller.address, amountToDeposit));
        (0, chai_1.expect)(await dai.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool.connect(caller.signer).deposit(dai.address, amountToDeposit, caller.address, '0'));
        const flashAmount = ethers_1.utils.parseEther('0.8');
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(false));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setAmountToApprove(flashAmount.div(2)));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [0], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller takes a WETH flashloan with mode = 1', async () => {
        const { pool, weth, users, helpersContract } = testEnv;
        const caller = users[3];
        const flashAmount = ethers_1.utils.parseEther('0.0571');
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        (0, chai_1.expect)(await pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], caller.address, '0x10', '0'));
        const { stableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        const wethDebtToken = await (0, contract_getters_1.getStableDebtToken)(stableDebtTokenAddress);
        const callerDebt = await wethDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal(flashAmount, 'Invalid user debt');
    });
    it('Caller takes a WETH flashloan with mode = 1 onBehalfOf user without allowance (revert expected)', async () => {
        const { dai, pool, weth, users, faucetMintable } = testEnv;
        const caller = users[5];
        const onBehalfOf = users[4];
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        // Top up user
        (0, chai_1.expect)(await faucetMintable.mint(dai.address, onBehalfOf.address, amountToDeposit));
        // Deposit 1000 dai for onBehalfOf user
        (0, chai_1.expect)(await dai.connect(onBehalfOf.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT));
        (0, chai_1.expect)(await pool
            .connect(onBehalfOf.signer)
            .deposit(dai.address, amountToDeposit, onBehalfOf.address, '0'));
        const flashAmount = ethers_1.utils.parseEther('0.0571');
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], onBehalfOf.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller takes a WETH flashloan with mode = 1 onBehalfOf user with allowance. A loan for onBehalfOf is creatd.', async () => {
        const { pool, weth, users, helpersContract } = testEnv;
        const caller = users[5];
        const onBehalfOf = users[4];
        const flashAmount = ethers_1.utils.parseEther('0.0571');
        const reserveData = await pool.getReserveData(weth.address);
        const stableDebtToken = await (0, contract_getters_1.getStableDebtToken)(reserveData.stableDebtTokenAddress);
        // Deposited for onBehalfOf user already, delegate borrow allowance
        (0, chai_1.expect)(await stableDebtToken
            .connect(onBehalfOf.signer)
            .approveDelegation(caller.address, flashAmount));
        (0, chai_1.expect)(await _mockFlashLoanReceiver.setFailExecutionTransfer(true));
        (0, chai_1.expect)(await pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], onBehalfOf.address, '0x10', '0'));
        const { stableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        const wethDebtToken = await (0, contract_getters_1.getStableDebtToken)(stableDebtTokenAddress);
        const onBehalfOfDebt = await wethDebtToken.balanceOf(onBehalfOf.address);
        (0, chai_1.expect)(onBehalfOfDebt.toString()).to.be.equal('57100000000000000', 'Invalid onBehalfOf user debt');
    });
});
