"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const make_suite_1 = require("./helpers/make-suite");
(0, make_suite_1.makeSuite)('Pool: Drop Reserve', (testEnv) => {
    let _mockFlashLoanReceiver = {};
    const { UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO, STABLE_DEBT_NOT_ZERO, VARIABLE_DEBT_SUPPLY_NOT_ZERO, ASSET_NOT_LISTED, ZERO_ADDRESS_NOT_VALID, } = types_1.ProtocolErrors;
    before(async () => {
        _mockFlashLoanReceiver = await (0, contract_getters_1.getMockFlashLoanReceiver)();
    });
    it('User 1 deposits DAI, User 2 borrow DAI stable and variable, should fail to drop DAI reserve', async () => {
        const { deployer, users: [user1], pool, dai, weth, configurator, faucetMintable, } = testEnv;
        const depositedAmount = ethers_1.utils.parseEther('1000');
        const borrowedAmount = ethers_1.utils.parseEther('100');
        // setting reserve factor to 0 to ease tests, no aToken accrued in reserve
        await configurator.setReserveFactor(dai.address, 0);
        await faucetMintable.mint(dai.address, deployer.address, depositedAmount);
        await dai.approve(pool.address, depositedAmount);
        await faucetMintable.mint(dai.address, user1.address, depositedAmount);
        await dai.connect(user1.signer).approve(pool.address, depositedAmount);
        await faucetMintable.mint(weth.address, user1.address, depositedAmount);
        await weth.connect(user1.signer).approve(pool.address, depositedAmount);
        await pool.deposit(dai.address, depositedAmount, deployer.address, 0);
        await (0, chai_1.expect)(configurator.dropReserve(dai.address)).to.be.revertedWith(UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO);
        await pool.connect(user1.signer).deposit(weth.address, depositedAmount, user1.address, 0);
        await pool.connect(user1.signer).borrow(dai.address, borrowedAmount, 2, 0, user1.address);
        await (0, chai_1.expect)(configurator.dropReserve(dai.address)).to.be.revertedWith(VARIABLE_DEBT_SUPPLY_NOT_ZERO);
        await pool.connect(user1.signer).borrow(dai.address, borrowedAmount, 1, 0, user1.address);
        await (0, chai_1.expect)(configurator.dropReserve(dai.address)).to.be.revertedWith(STABLE_DEBT_NOT_ZERO);
    });
    it('User 2 repays debts, drop DAI reserve should fail', async () => {
        const { users: [user1], pool, dai, configurator, } = testEnv;
        (0, chai_1.expect)(await pool.connect(user1.signer).repay(dai.address, constants_1.MAX_UINT_AMOUNT, 1, user1.address));
        await (0, chai_1.expect)(configurator.dropReserve(dai.address)).to.be.revertedWith(VARIABLE_DEBT_SUPPLY_NOT_ZERO);
        (0, chai_1.expect)(await pool.connect(user1.signer).repay(dai.address, constants_1.MAX_UINT_AMOUNT, 2, user1.address));
        await (0, chai_1.expect)(configurator.dropReserve(dai.address)).to.be.revertedWith(UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO);
    });
    it('User 1 withdraw DAI, drop DAI reserve should succeed', async () => {
        const { deployer, pool, dai, configurator, helpersContract } = testEnv;
        await pool.withdraw(dai.address, constants_1.MAX_UINT_AMOUNT, deployer.address);
        const reserveCount = (await pool.getReservesList()).length;
        (0, chai_1.expect)(await configurator.dropReserve(dai.address));
        const tokens = await pool.getReservesList();
        (0, chai_1.expect)(tokens.length).to.be.eq(reserveCount - 1);
        (0, chai_1.expect)(tokens.includes(dai.address)).to.be.false;
        const { isActive } = await helpersContract.getReserveConfigurationData(dai.address);
        (0, chai_1.expect)(isActive).to.be.false;
    });
    it('Drop an asset that is not a listed reserve should fail', async () => {
        const { users, configurator } = testEnv;
        await (0, chai_1.expect)(configurator.dropReserve(users[5].address)).to.be.revertedWith(ASSET_NOT_LISTED);
    });
    it('Drop an asset that is not a listed reserve should fail', async () => {
        const { users, configurator } = testEnv;
        await (0, chai_1.expect)(configurator.dropReserve(constants_1.ZERO_ADDRESS)).to.be.revertedWith(ZERO_ADDRESS_NOT_VALID);
    });
});
