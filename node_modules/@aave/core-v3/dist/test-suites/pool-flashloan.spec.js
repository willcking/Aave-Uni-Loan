"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
const types_2 = require("../types");
(0, make_suite_1.makeSuite)('Pool: FlashLoan', (testEnv) => {
    let _mockFlashLoanReceiver = {};
    const { COLLATERAL_BALANCE_IS_ZERO, ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE, INVALID_FLASHLOAN_EXECUTOR_RETURN, FLASHLOAN_DISABLED, BORROWING_NOT_ENABLED, } = types_1.ProtocolErrors;
    const TOTAL_PREMIUM = 9;
    const PREMIUM_TO_PROTOCOL = 3000;
    before(async () => {
        const { usdc, aUsdc, pool, configurator, deployer } = testEnv;
        _mockFlashLoanReceiver = await (0, contract_getters_1.getMockFlashLoanReceiver)();
        const aTokenRepayImpl = await new types_2.MockATokenRepayment__factory(deployer.signer).deploy(pool.address);
        await configurator.updateAToken({
            asset: usdc.address,
            treasury: await aUsdc.RESERVE_TREASURY_ADDRESS(),
            incentivesController: await aUsdc.getIncentivesController(),
            name: await aUsdc.name(),
            symbol: await aUsdc.symbol(),
            implementation: aTokenRepayImpl.address,
            params: '0x',
        });
    });
    it('Configurator sets total premium = 9 bps, premium to protocol = 30%', async () => {
        const { configurator, pool } = testEnv;
        await configurator.updateFlashloanPremiumTotal(TOTAL_PREMIUM);
        await configurator.updateFlashloanPremiumToProtocol(PREMIUM_TO_PROTOCOL);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TOTAL()).to.be.equal(TOTAL_PREMIUM);
        (0, chai_1.expect)(await pool.FLASHLOAN_PREMIUM_TO_PROTOCOL()).to.be.equal(PREMIUM_TO_PROTOCOL);
    });
    it('Deposits WETH into the reserve', async () => {
        const { pool, weth, aave, dai, faucetMintable, deployer } = testEnv;
        const userAddress = await pool.signer.getAddress();
        const amountToDeposit = ethers_1.ethers.utils.parseEther('1');
        await faucetMintable.mint(weth.address, deployer.address, amountToDeposit);
        await weth.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(weth.address, amountToDeposit, userAddress, '0');
        await faucetMintable.mint(aave.address, deployer.address, amountToDeposit);
        await aave.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(aave.address, amountToDeposit, userAddress, '0');
        await faucetMintable.mint(dai.address, deployer.address, amountToDeposit);
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.deposit(dai.address, amountToDeposit, userAddress, '0');
    });
    it('Takes WETH + Dai flash loan with mode = 0, returns the funds correctly', async () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const { pool, helpersContract, weth, aWETH, dai, aDai } = testEnv;
        const wethFlashBorrowedAmount = ethers_1.ethers.utils.parseEther('0.8');
        const daiFlashBorrowedAmount = ethers_1.ethers.utils.parseEther('0.3');
        const wethTotalFees = wethFlashBorrowedAmount.mul(TOTAL_PREMIUM).div(10000);
        const wethFeesToProtocol = wethTotalFees.mul(PREMIUM_TO_PROTOCOL).div(10000);
        const wethFeesToLp = wethTotalFees.sub(wethFeesToProtocol);
        const daiTotalFees = daiFlashBorrowedAmount.mul(TOTAL_PREMIUM).div(10000);
        const daiFeesToProtocol = daiTotalFees.mul(PREMIUM_TO_PROTOCOL).div(10000);
        const daiFeesToLp = daiTotalFees.sub(daiFeesToProtocol);
        const wethLiquidityIndexAdded = wethFeesToLp
            .mul(ethers_1.BigNumber.from(10).pow(27))
            .div(await aWETH.totalSupply());
        const daiLiquidityIndexAdded = daiFeesToLp
            .mul(ethers_1.ethers.BigNumber.from(10).pow(27))
            .div(await aDai.totalSupply());
        let wethReserveData = await helpersContract.getReserveData(weth.address);
        let daiReserveData = await helpersContract.getReserveData(dai.address);
        const wethLiquidityIndexBefore = wethReserveData.liquidityIndex;
        const daiLiquidityIndexBefore = daiReserveData.liquidityIndex;
        const wethTotalLiquidityBefore = wethReserveData.totalAToken;
        const daiTotalLiquidityBefore = daiReserveData.totalAToken;
        const wethReservesBefore = await aWETH.balanceOf(await aWETH.RESERVE_TREASURY_ADDRESS());
        const daiReservesBefore = await aDai.balanceOf(await aDai.RESERVE_TREASURY_ADDRESS());
        const tx = await (0, deploy_v3_1.waitForTx)(await pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address, dai.address], [wethFlashBorrowedAmount, daiFlashBorrowedAmount], [0, 0], _mockFlashLoanReceiver.address, '0x10', '0'));
        await pool.mintToTreasury([weth.address, dai.address]);
        wethReserveData = await helpersContract.getReserveData(weth.address);
        daiReserveData = await helpersContract.getReserveData(dai.address);
        const wethCurrentLiquidityRate = wethReserveData.liquidityRate;
        const wethCurrentLiquidityIndex = wethReserveData.liquidityIndex;
        const daiCurrentLiquidityRate = daiReserveData.liquidityRate;
        const daiCurrentLiquidityIndex = daiReserveData.liquidityIndex;
        const wethTotalLiquidityAfter = wethReserveData.totalAToken;
        const daiTotalLiquidityAfter = daiReserveData.totalAToken;
        const wethReservesAfter = await aWETH.balanceOf(await aWETH.RESERVE_TREASURY_ADDRESS());
        const daiReservesAfter = await aDai.balanceOf(await aDai.RESERVE_TREASURY_ADDRESS());
        (0, chai_1.expect)(wethTotalLiquidityBefore.add(wethTotalFees)).to.be.closeTo(wethTotalLiquidityAfter, 2);
        (0, chai_1.expect)(wethCurrentLiquidityRate).to.be.equal(0);
        (0, chai_1.expect)(wethCurrentLiquidityIndex).to.be.equal(wethLiquidityIndexBefore.add(wethLiquidityIndexAdded));
        (0, chai_1.expect)(wethReservesAfter).to.be.equal(wethReservesBefore.add(wethFeesToProtocol));
        (0, chai_1.expect)(daiTotalLiquidityBefore.add(daiTotalFees)).to.be.closeTo(daiTotalLiquidityAfter, 2);
        (0, chai_1.expect)(daiCurrentLiquidityRate).to.be.equal(0);
        (0, chai_1.expect)(daiCurrentLiquidityIndex).to.be.equal(daiLiquidityIndexBefore.add(daiLiquidityIndexAdded));
        (0, chai_1.expect)(daiReservesAfter).to.be.equal(daiReservesBefore.add(daiFeesToProtocol));
        // Check event values for `ReserveDataUpdated`
        const reserveDataUpdatedEvents = (_a = tx.events) === null || _a === void 0 ? void 0 : _a.filter(({ event }) => event === 'ReserveDataUpdated');
        for (const reserveDataUpdatedEvent of reserveDataUpdatedEvents) {
            const reserveData = await helpersContract.getReserveData((_b = reserveDataUpdatedEvent.args) === null || _b === void 0 ? void 0 : _b.reserve);
            (0, chai_1.expect)(reserveData.liquidityRate).to.be.eq((_c = reserveDataUpdatedEvent.args) === null || _c === void 0 ? void 0 : _c.liquidityRate);
            (0, chai_1.expect)(reserveData.stableBorrowRate).to.be.eq((_d = reserveDataUpdatedEvent.args) === null || _d === void 0 ? void 0 : _d.stableBorrowRate);
            (0, chai_1.expect)(reserveData.variableBorrowRate).to.be.eq((_e = reserveDataUpdatedEvent.args) === null || _e === void 0 ? void 0 : _e.variableBorrowRate);
            (0, chai_1.expect)(reserveData.liquidityIndex).to.be.eq((_f = reserveDataUpdatedEvent.args) === null || _f === void 0 ? void 0 : _f.liquidityIndex);
            (0, chai_1.expect)(reserveData.variableBorrowIndex).to.be.eq((_g = reserveDataUpdatedEvent.args) === null || _g === void 0 ? void 0 : _g.variableBorrowIndex);
        }
    });
    it('Takes an authorized AAVE flash loan with mode = 0, returns the funds correctly, premium should be 0', async () => {
        const { pool, helpersContract, aave, aclManager, users: [, , , authorizedUser], } = testEnv;
        (0, chai_1.expect)(await aclManager.addFlashBorrower(authorizedUser.address));
        const flashBorrowedAmount = ethers_1.ethers.utils.parseEther('0.8');
        const totalFees = ethers_1.BigNumber.from(0);
        let reserveData = await helpersContract.getReserveData(aave.address);
        const totalLiquidityBefore = reserveData.totalAToken;
        await (0, chai_1.expect)(pool
            .connect(authorizedUser.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [aave.address], [flashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0'))
            .to.emit(_mockFlashLoanReceiver, 'ExecutedWithSuccess')
            .withArgs([aave.address], [flashBorrowedAmount], [0]);
        await pool.mintToTreasury([aave.address]);
        reserveData = await helpersContract.getReserveData(aave.address);
        const totalLiquidityAfter = reserveData.totalAToken;
        (0, chai_1.expect)(totalLiquidityBefore.add(totalFees)).to.be.closeTo(totalLiquidityAfter, 2);
    });
    it('Takes an ETH flashloan with mode = 0 as big as the available liquidity', async () => {
        const { pool, helpersContract, weth, aWETH, deployer } = testEnv;
        let reserveData = await helpersContract.getReserveData(weth.address);
        const totalLiquidityBefore = reserveData.totalAToken;
        const flashBorrowedAmount = totalLiquidityBefore;
        const totalFees = flashBorrowedAmount.mul(TOTAL_PREMIUM).div(10000);
        const feesToProtocol = totalFees.mul(PREMIUM_TO_PROTOCOL).div(10000);
        const feesToLp = totalFees.sub(feesToProtocol);
        const liquidityIndexBefore = reserveData.liquidityIndex;
        const liquidityIndexAdded = feesToLp
            .mul(ethers_1.BigNumber.from(10).pow(27))
            .div((await aWETH.totalSupply()).toString())
            .mul(liquidityIndexBefore)
            .div(ethers_1.BigNumber.from(10).pow(27));
        const reservesBefore = await aWETH.balanceOf(await aWETH.RESERVE_TREASURY_ADDRESS());
        await (0, chai_1.expect)(pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0'))
            .to.emit(pool, 'FlashLoan')
            .withArgs(_mockFlashLoanReceiver.address, deployer.address, weth.address, flashBorrowedAmount, 0, flashBorrowedAmount.mul(9).div(10000), 0);
        await pool.mintToTreasury([weth.address]);
        reserveData = await helpersContract.getReserveData(weth.address);
        const currentLiquidityRate = reserveData.liquidityRate;
        const currentLiquidityIndex = reserveData.liquidityIndex;
        const totalLiquidityAfter = reserveData.totalAToken;
        const reservesAfter = await aWETH.balanceOf(await aWETH.RESERVE_TREASURY_ADDRESS());
        (0, chai_1.expect)(totalLiquidityBefore.add(totalFees)).to.be.closeTo(totalLiquidityAfter, 2);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(0);
        (0, chai_1.expect)(currentLiquidityIndex).to.be.equal(liquidityIndexBefore.add(liquidityIndexAdded));
        (0, chai_1.expect)(reservesAfter.sub(feesToProtocol).mul(liquidityIndexBefore).div(currentLiquidityIndex)).to.be.closeTo(reservesBefore, 2);
    });
    it('Disable ETH flashloan and takes an ETH flashloan (revert expected)', async () => {
        const { pool, configurator, helpersContract, weth, deployer } = testEnv;
        (0, chai_1.expect)(await configurator.setReserveFlashLoaning(weth.address, false));
        let wethFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(weth.address);
        (0, chai_1.expect)(wethFlashLoanEnabled).to.be.equal(false);
        let reserveData = await helpersContract.getReserveData(weth.address);
        const totalLiquidityBefore = reserveData.totalAToken;
        const flashBorrowedAmount = totalLiquidityBefore;
        await (0, chai_1.expect)(pool.flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0')).to.be.revertedWith(FLASHLOAN_DISABLED);
        await (0, chai_1.expect)(configurator.setReserveFlashLoaning(weth.address, true))
            .to.emit(configurator, 'ReserveFlashLoaning')
            .withArgs(weth.address, true);
        wethFlashLoanEnabled = await helpersContract.getFlashLoanEnabled(weth.address);
        (0, chai_1.expect)(wethFlashLoanEnabled).to.be.equal(true);
    });
    it('Takes WETH flashloan, does not return the funds with mode = 0 (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.ethers.utils.parseEther('0.8')], [0], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Takes WETH flashloan, simulating a receiver as EOA (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await _mockFlashLoanReceiver.setSimulateEOA(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.ethers.utils.parseEther('0.8')], [0], caller.address, '0x10', '0')).to.be.revertedWith(INVALID_FLASHLOAN_EXECUTOR_RETURN);
    });
    it('Takes a WETH flashloan with an invalid mode (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        await _mockFlashLoanReceiver.setSimulateEOA(false);
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [ethers_1.ethers.utils.parseEther('0.8')], [4], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller deposits 1000 DAI as collateral, Takes WETH flashloan with mode = 2, does not return the funds. A variable loan for caller is created', async () => {
        const { dai, pool, weth, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[1];
        await faucetMintable.mint(dai.address, caller.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await pool.connect(caller.signer).deposit(dai.address, amountToDeposit, caller.address, '0');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        let reserveData = await helpersContract.getReserveData(weth.address);
        let totalLiquidityBefore = reserveData.totalAToken;
        const borrowAmount = ethers_1.ethers.utils.parseEther('0.0571');
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [borrowAmount], [2], caller.address, '0x10', '0'))
            .to.emit(pool, 'FlashLoan')
            .withArgs(_mockFlashLoanReceiver.address, caller.address, weth.address, borrowAmount, 2, 0, 0);
        const { variableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        reserveData = await helpersContract.getReserveData(weth.address);
        const totalLiquidityAfter = reserveData.totalAToken;
        (0, chai_1.expect)(totalLiquidityAfter).to.be.closeTo(totalLiquidityBefore, 2);
        const wethDebtToken = await (0, contract_getters_1.getVariableDebtToken)(variableDebtTokenAddress);
        const callerDebt = await wethDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal('57100000000000000', 'Invalid user debt');
        // repays debt for later, so no interest accrue
        await faucetMintable.mint(weth.address, caller.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '1000'));
        await weth.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(caller.signer).repay(weth.address, constants_1.MAX_UINT_AMOUNT, 2, caller.address);
    });
    it('Tries to take a flashloan that is bigger than the available liquidity (revert expected)', async () => {
        const { pool, weth, users } = testEnv;
        const caller = users[1];
        await (0, chai_1.expect)(pool.connect(caller.signer).flashLoan(_mockFlashLoanReceiver.address, [weth.address], ['1004415000000000000'], //slightly higher than the available liquidity
        [2], caller.address, '0x10', '0'), ERC20_TRANSFER_AMOUNT_EXCEEDS_BALANCE).to.be.reverted;
    });
    it('Tries to take a flashloan using a non contract address as receiver (revert expected)', async () => {
        const { pool, deployer, weth, users } = testEnv;
        const caller = users[1];
        await (0, chai_1.expect)(pool.flashLoan(deployer.address, [weth.address], ['1000000000000000000'], [2], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Deposits USDC into the reserve', async () => {
        const { usdc, pool, deployer, faucetMintable } = testEnv;
        const userAddress = await pool.signer.getAddress();
        await faucetMintable.mint(usdc.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000'));
        await usdc.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '1000');
        await pool.deposit(usdc.address, amountToDeposit, userAddress, '0');
    });
    it('Takes out a 500 USDC flashloan, returns the funds correctly', async () => {
        const { usdc, aUsdc, pool, helpersContract, deployer: depositor } = testEnv;
        await _mockFlashLoanReceiver.setFailExecutionTransfer(false);
        const flashBorrowedAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        const totalFees = flashBorrowedAmount.mul(TOTAL_PREMIUM).div(10000);
        const feesToProtocol = totalFees.mul(PREMIUM_TO_PROTOCOL).div(10000);
        const feesToLp = totalFees.sub(feesToProtocol);
        const liquidityIndexAdded = feesToLp
            .mul(ethers_1.ethers.BigNumber.from(10).pow(27))
            .div(await aUsdc.totalSupply());
        let reserveData = await helpersContract.getReserveData(usdc.address);
        const liquidityIndexBefore = reserveData.liquidityIndex;
        const totalLiquidityBefore = reserveData.totalAToken;
        const reservesBefore = await aUsdc.balanceOf(await aUsdc.RESERVE_TREASURY_ADDRESS());
        const tx = await pool.flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashBorrowedAmount], [0], _mockFlashLoanReceiver.address, '0x10', '0');
        await (0, deploy_v3_1.waitForTx)(tx);
        await pool.mintToTreasury([usdc.address]);
        reserveData = await helpersContract.getReserveData(usdc.address);
        const currentLiquidityRate = reserveData.liquidityRate;
        const currentLiquidityIndex = reserveData.liquidityIndex;
        const totalLiquidityAfter = reserveData.totalAToken;
        const reservesAfter = await aUsdc.balanceOf(await aUsdc.RESERVE_TREASURY_ADDRESS());
        (0, chai_1.expect)(totalLiquidityBefore.add(totalFees)).to.be.closeTo(totalLiquidityAfter, 2);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(0);
        (0, chai_1.expect)(currentLiquidityIndex).to.be.equal(liquidityIndexBefore.add(liquidityIndexAdded));
        (0, chai_1.expect)(reservesAfter).to.be.equal(reservesBefore.add(feesToProtocol));
        // Check handleRepayment is correctly called at flash loans
        await (0, chai_1.expect)(tx)
            .to.emit(types_2.MockATokenRepayment__factory.connect(aUsdc.address, depositor.signer), 'MockRepayment')
            .withArgs(_mockFlashLoanReceiver.address, _mockFlashLoanReceiver.address, flashBorrowedAmount.add(totalFees));
    });
    it('Takes out a 500 USDC flashloan with mode = 0, does not return the funds (revert expected)', async () => {
        const { usdc, pool, users } = testEnv;
        const caller = users[2];
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [2], caller.address, '0x10', '0')).to.be.revertedWith(COLLATERAL_BALANCE_IS_ZERO);
    });
    it('Caller deposits 5 WETH as collateral, Takes a USDC flashloan with mode = 2, does not return the funds. A loan for caller is created, premium should be 0', async () => {
        const { usdc, pool, weth, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[2];
        await faucetMintable.mint(weth.address, caller.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5'));
        await weth.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5');
        await pool.connect(caller.signer).deposit(weth.address, amountToDeposit, caller.address, '0');
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(false);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [2], caller.address, '0x10', '0'))
            .to.emit(_mockFlashLoanReceiver, 'ExecutedWithSuccess')
            .withArgs([usdc.address], [flashloanAmount], [0]);
        const { variableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(usdc.address);
        const usdcDebtToken = await (0, contract_getters_1.getVariableDebtToken)(variableDebtTokenAddress);
        const callerDebt = await usdcDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal('500000000', 'Invalid user debt');
    });
    it('Disable USDC borrowing. Caller deposits 5 WETH as collateral, Takes a USDC flashloan with mode = 2, does not return the funds. Revert creating borrow position (revert expected)', async () => {
        const { usdc, pool, weth, configurator, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[2];
        (0, chai_1.expect)(await configurator.setReserveStableRateBorrowing(usdc.address, false));
        (0, chai_1.expect)(await configurator.setReserveBorrowing(usdc.address, false));
        let usdcConfiguration = await helpersContract.getReserveConfigurationData(usdc.address);
        (0, chai_1.expect)(usdcConfiguration.borrowingEnabled).to.be.equal(false);
        await faucetMintable.mint(weth.address, caller.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5'));
        await weth.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '5');
        await pool.connect(caller.signer).deposit(weth.address, amountToDeposit, caller.address, '0');
        const flashloanAmount = await (0, contracts_helpers_1.convertToCurrencyDecimals)(usdc.address, '500');
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [usdc.address], [flashloanAmount], [2], caller.address, '0x10', '0')).to.be.revertedWith(BORROWING_NOT_ENABLED);
    });
    it('Caller deposits 1000 DAI as collateral, Takes a WETH flashloan with mode = 0, does not approve the transfer of the funds', async () => {
        const { dai, pool, weth, users, faucetMintable } = testEnv;
        const caller = users[3];
        await faucetMintable.mint(dai.address, caller.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.connect(caller.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await pool.connect(caller.signer).deposit(dai.address, amountToDeposit, caller.address, '0');
        const flashAmount = ethers_1.ethers.utils.parseEther('0.8');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(false);
        await _mockFlashLoanReceiver.setAmountToApprove(flashAmount.div(2));
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [0], caller.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller takes a WETH flashloan with mode = 1', async () => {
        const { pool, weth, users, helpersContract } = testEnv;
        const caller = users[3];
        const flashAmount = ethers_1.ethers.utils.parseEther('0.0571');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], caller.address, '0x10', '0'))
            .to.emit(pool, 'FlashLoan')
            .withArgs(_mockFlashLoanReceiver.address, caller.address, weth.address, flashAmount, 1, 0, 0);
        const { stableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        const wethDebtToken = await (0, contract_getters_1.getStableDebtToken)(stableDebtTokenAddress);
        const callerDebt = await wethDebtToken.balanceOf(caller.address);
        (0, chai_1.expect)(callerDebt.toString()).to.be.equal('57100000000000000', 'Invalid user debt');
    });
    it('Caller takes a WETH flashloan with mode = 1 onBehalfOf user without allowance', async () => {
        const { dai, pool, weth, users, helpersContract, faucetMintable } = testEnv;
        const caller = users[5];
        const onBehalfOf = users[4];
        // Deposit 1000 dai for onBehalfOf user
        await faucetMintable.mint(dai.address, onBehalfOf.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.connect(onBehalfOf.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const amountToDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000');
        await pool
            .connect(onBehalfOf.signer)
            .deposit(dai.address, amountToDeposit, onBehalfOf.address, '0');
        const flashAmount = ethers_1.ethers.utils.parseEther('0.0571');
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await (0, chai_1.expect)(pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], onBehalfOf.address, '0x10', '0')).to.be.reverted;
    });
    it('Caller takes a WETH flashloan with mode = 1 onBehalfOf user with allowance. A loan for onBehalfOf is creatd.', async () => {
        const { pool, weth, users, helpersContract } = testEnv;
        const caller = users[5];
        const onBehalfOf = users[4];
        const flashAmount = ethers_1.ethers.utils.parseEther('0.0571');
        const reserveData = await pool.getReserveData(weth.address);
        const stableDebtToken = await (0, contract_getters_1.getStableDebtToken)(reserveData.stableDebtTokenAddress);
        // Deposited for onBehalfOf user already, delegate borrow allowance
        await stableDebtToken.connect(onBehalfOf.signer).approveDelegation(caller.address, flashAmount);
        await _mockFlashLoanReceiver.setFailExecutionTransfer(true);
        await pool
            .connect(caller.signer)
            .flashLoan(_mockFlashLoanReceiver.address, [weth.address], [flashAmount], [1], onBehalfOf.address, '0x10', '0');
        const { stableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(weth.address);
        const wethDebtToken = await (0, contract_getters_1.getStableDebtToken)(stableDebtTokenAddress);
        const onBehalfOfDebt = await wethDebtToken.balanceOf(onBehalfOf.address);
        (0, chai_1.expect)(onBehalfOfDebt.toString()).to.be.equal('57100000000000000', 'Invalid onBehalfOf user debt');
    });
});
