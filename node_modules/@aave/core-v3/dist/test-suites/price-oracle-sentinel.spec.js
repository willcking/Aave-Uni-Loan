"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const misc_utils_1 = require("../helpers/misc-utils");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const types_2 = require("../types");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const make_suite_1 = require("./helpers/make-suite");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const calculations_1 = require("./helpers/utils/calculations");
const helpers_1 = require("./helpers/utils/helpers");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('PriceOracleSentinel', (testEnv) => {
    const { PRICE_ORACLE_SENTINEL_CHECK_FAILED, INVALID_HF, CALLER_NOT_POOL_ADMIN, CALLER_NOT_RISK_OR_POOL_ADMIN, } = types_1.ProtocolErrors;
    let sequencerOracle;
    let priceOracleSentinel;
    const GRACE_PERIOD = ethers_1.BigNumber.from(60 * 60);
    before(async () => {
        const { addressesProvider, deployer, oracle } = testEnv;
        // Deploy SequencerOracle
        sequencerOracle = await (await new types_2.SequencerOracle__factory(deployer.signer).deploy(deployer.address)).deployed();
        priceOracleSentinel = await (await new types_2.PriceOracleSentinel__factory(await (0, signer_1.getFirstSigner)()).deploy(addressesProvider.address, sequencerOracle.address, GRACE_PERIOD)).deployed();
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(oracle.address));
    });
    after(async () => {
        const { aaveOracle, addressesProvider } = testEnv;
        await (0, deploy_v3_1.waitForTx)(await addressesProvider.setPriceOracle(aaveOracle.address));
    });
    it('Admin sets a PriceOracleSentinel and activate it for DAI and WETH', async () => {
        const { addressesProvider, poolAdmin } = testEnv;
        await (0, chai_1.expect)(addressesProvider
            .connect(poolAdmin.signer)
            .setPriceOracleSentinel(priceOracleSentinel.address))
            .to.emit(addressesProvider, 'PriceOracleSentinelUpdated')
            .withArgs(constants_1.ZERO_ADDRESS, priceOracleSentinel.address);
        (0, chai_1.expect)(await addressesProvider.getPriceOracleSentinel()).to.be.eq(priceOracleSentinel.address);
        const answer = await sequencerOracle.latestRoundData();
        (0, chai_1.expect)(answer[1]).to.be.eq(0);
        (0, chai_1.expect)(answer[3]).to.be.eq(0);
    });
    it('Pooladmin updates grace period for sentinel', async () => {
        const { poolAdmin } = testEnv;
        const newGracePeriod = 0;
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.be.eq(GRACE_PERIOD);
        await (0, chai_1.expect)(priceOracleSentinel.connect(poolAdmin.signer).setGracePeriod(0))
            .to.emit(priceOracleSentinel, 'GracePeriodUpdated')
            .withArgs(0);
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.be.eq(newGracePeriod);
    });
    it('Risk admin updates grace period for sentinel', async () => {
        const { riskAdmin } = testEnv;
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.be.eq(0);
        await (0, chai_1.expect)(priceOracleSentinel.connect(riskAdmin.signer).setGracePeriod(GRACE_PERIOD))
            .to.emit(priceOracleSentinel, 'GracePeriodUpdated')
            .withArgs(GRACE_PERIOD);
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.be.eq(GRACE_PERIOD);
    });
    it('User tries to set grace period for sentinel', async () => {
        const { users: [user], } = testEnv;
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.be.eq(GRACE_PERIOD);
        await (0, chai_1.expect)(priceOracleSentinel.connect(user.signer).setGracePeriod(0)).to.be.revertedWith(CALLER_NOT_RISK_OR_POOL_ADMIN);
        (0, chai_1.expect)(await priceOracleSentinel.getGracePeriod()).to.not.be.eq(0);
    });
    it('Pooladmin update the sequencer oracle', async () => {
        const { poolAdmin } = testEnv;
        const newSequencerOracle = constants_1.ZERO_ADDRESS;
        (0, chai_1.expect)(await priceOracleSentinel.getSequencerOracle()).to.be.eq(sequencerOracle.address);
        await (0, chai_1.expect)(priceOracleSentinel.connect(poolAdmin.signer).setSequencerOracle(newSequencerOracle))
            .to.emit(priceOracleSentinel, 'SequencerOracleUpdated')
            .withArgs(newSequencerOracle);
        (0, chai_1.expect)(await priceOracleSentinel.getSequencerOracle()).to.be.eq(newSequencerOracle);
        await (0, chai_1.expect)(priceOracleSentinel.connect(poolAdmin.signer).setSequencerOracle(sequencerOracle.address))
            .to.emit(priceOracleSentinel, 'SequencerOracleUpdated')
            .withArgs(sequencerOracle.address);
        (0, chai_1.expect)(await priceOracleSentinel.getSequencerOracle()).to.be.eq(sequencerOracle.address);
    });
    it('User tries to update sequencer oracle', async () => {
        const { users: [user], } = testEnv;
        const newSequencerOracle = constants_1.ZERO_ADDRESS;
        (0, chai_1.expect)(await priceOracleSentinel.getSequencerOracle()).to.be.eq(sequencerOracle.address);
        await (0, chai_1.expect)(priceOracleSentinel.connect(user.signer).setSequencerOracle(newSequencerOracle)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
        (0, chai_1.expect)(await priceOracleSentinel.getSequencerOracle()).to.be.eq(sequencerOracle.address);
    });
    it('Borrow DAI', async () => {
        const { dai, weth, users: [depositor, borrower, borrower2], pool, oracle, faucetMintable } = testEnv;
        //mints DAI to depositor
        await faucetMintable.mint(dai.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '2000'));
        //approve protocol to access depositor wallet
        await dai.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        //user 1 deposits 1000 DAI
        const amountDAItoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '2000');
        await pool
            .connect(depositor.signer)
            .deposit(dai.address, amountDAItoDeposit, depositor.address, '0');
        const amountETHtoDeposit = await (0, contracts_helpers_1.convertToCurrencyDecimals)(weth.address, '0.06775');
        for (let i = 0; i < 2; i++) {
            const borrowers = [borrower, borrower2];
            const currBorrower = borrowers[i];
            //mints WETH to borrower
            await faucetMintable.mint(weth.address, currBorrower.address, amountETHtoDeposit);
            //approve protocol to access borrower wallet
            await weth.connect(currBorrower.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
            //user 2 deposits 1 WETH
            await pool
                .connect(currBorrower.signer)
                .deposit(weth.address, amountETHtoDeposit, currBorrower.address, '0');
            //user 2 borrows
            const userGlobalData = await pool.getUserAccountData(currBorrower.address);
            const daiPrice = await oracle.getAssetPrice(dai.address);
            const amountDAIToBorrow = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, userGlobalData.availableBorrowsBase.div(daiPrice.toString()).percentMul(9500).toString());
            await pool
                .connect(currBorrower.signer)
                .borrow(dai.address, amountDAIToBorrow, types_1.RateMode.Variable, '0', currBorrower.address);
        }
    });
    it('Kill sequencer and drop health factor below 1', async () => {
        const { dai, users: [, borrower], pool, oracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(11000));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        const currAnswer = await sequencerOracle.latestRoundData();
        (0, deploy_v3_1.waitForTx)(await sequencerOracle.setAnswer(true, currAnswer[3]));
    });
    it('Tries to liquidate borrower when sequencer is down (HF > 0.95) (revert expected)', async () => {
        const { pool, dai, weth, users: [, borrower], helpersContract, faucetMintable, deployer } = testEnv;
        await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        await (0, chai_1.expect)(pool.liquidationCall(weth.address, dai.address, borrower.address, amountToLiquidate, true)).to.be.revertedWith(PRICE_ORACLE_SENTINEL_CHECK_FAILED);
    });
    it('Drop health factor lower', async () => {
        const { dai, users: [, borrower], pool, oracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(11000));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
    });
    it('Liquidates borrower when sequencer is down (HF < 0.95)', async () => {
        const { pool, dai, weth, users: [, borrower], oracle, helpersContract, faucetMintable, deployer, } = testEnv;
        await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const userWethReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, weth.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        const tx = await pool.liquidationCall(weth.address, dai.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const userWethReserveDataAfter = await helpersContract.getUserReserveData(weth.address, borrower.address);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(10500)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        (0, chai_1.expect)(expectedCollateralLiquidated).to.be.closeTo(userWethReserveDataBefore.currentATokenBalance.sub(userWethReserveDataAfter.currentATokenBalance), 2, 'Invalid collateral amount liquidated');
        if (!tx.blockNumber) {
            (0, chai_1.expect)(false, 'Invalid block number');
            return;
        }
        const txTimestamp = ethers_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
        const variableDebtBeforeTx = (0, calculations_1.calcExpectedVariableDebtTokenBalance)(daiReserveDataBefore, userReserveDataBefore, txTimestamp);
        (0, chai_1.expect)(userReserveDataAfter.currentVariableDebt).to.be.closeTo(variableDebtBeforeTx.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.gte(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.lt(daiReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)((await helpersContract.getUserReserveData(weth.address, deployer.address))
            .usageAsCollateralEnabled).to.be.true;
    });
    it('User tries to borrow (revert expected)', async () => {
        const { dai, weth, users: [, , , user], pool, faucetMintable, } = testEnv;
        await faucetMintable.mint(weth.address, user.address, ethers_1.utils.parseUnits('0.06775', 18));
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('0.06775', 18), user.address, 0);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseUnits('100', 18), types_1.RateMode.Variable, 0, user.address)).to.be.revertedWith(PRICE_ORACLE_SENTINEL_CHECK_FAILED);
    });
    it('Turn on sequencer', async () => {
        await (0, deploy_v3_1.waitForTx)(await sequencerOracle.setAnswer(false, await (0, misc_utils_1.timeLatest)()));
    });
    it('User tries to borrow (revert expected)', async () => {
        const { dai, weth, users: [, , , user], pool, faucetMintable } = testEnv;
        await faucetMintable.mint(weth.address, user.address, ethers_1.utils.parseUnits('0.06775', 18));
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('0.06775', 18), user.address, 0);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseUnits('100', 18), types_1.RateMode.Variable, 0, user.address)).to.be.revertedWith(PRICE_ORACLE_SENTINEL_CHECK_FAILED);
    });
    it('Turn off sequencer + increase time more than grace period', async () => {
        const currAnswer = await sequencerOracle.latestRoundData();
        await (0, deploy_v3_1.waitForTx)(await sequencerOracle.setAnswer(true, currAnswer[3]));
        await (0, deploy_v3_1.increaseTime)(GRACE_PERIOD.mul(2).toNumber());
    });
    it('User tries to borrow (revert expected)', async () => {
        const { dai, weth, users: [, , , user], pool, faucetMintable } = testEnv;
        await faucetMintable.mint(weth.address, user.address, ethers_1.utils.parseUnits('0.06775', 18));
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('0.06775', 18), user.address, 0);
        await (0, chai_1.expect)(pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseUnits('100', 18), types_1.RateMode.Variable, 0, user.address)).to.be.revertedWith(PRICE_ORACLE_SENTINEL_CHECK_FAILED);
    });
    it('Turn on sequencer + increase time past grace period', async () => {
        await (0, deploy_v3_1.waitForTx)(await sequencerOracle.setAnswer(false, await (0, misc_utils_1.timeLatest)()));
        await (0, deploy_v3_1.increaseTime)(GRACE_PERIOD.mul(2).toNumber());
    });
    it('User tries to borrow', async () => {
        const { dai, weth, users: [, , , user], pool, faucetMintable } = testEnv;
        await faucetMintable.mint(weth.address, user.address, ethers_1.utils.parseUnits('0.06775', 18));
        await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('0.06775', 18), user.address, 0);
        await (0, deploy_v3_1.waitForTx)(await pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseUnits('100', 18), types_1.RateMode.Variable, 0, user.address));
    });
    it('Increase health factor', async () => {
        const { dai, users: [, borrower], pool, oracle, } = testEnv;
        const daiPrice = await oracle.getAssetPrice(dai.address);
        await oracle.setAssetPrice(dai.address, daiPrice.percentMul(9500));
        const userGlobalData = await pool.getUserAccountData(borrower.address);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.lt(ethers_1.utils.parseUnits('1', 18), INVALID_HF);
        (0, chai_1.expect)(userGlobalData.healthFactor).to.be.gt(ethers_1.utils.parseUnits('0.95', 18), INVALID_HF);
    });
    it('Liquidates borrower when sequencer is up again', async () => {
        const { pool, dai, weth, users: [, , borrower], oracle, helpersContract, deployer, faucetMintable } = testEnv;
        await faucetMintable.mint(dai.address, deployer.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const daiReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataBefore = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const userReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, dai.address, borrower.address);
        const userWethReserveDataBefore = await (0, helpers_1.getUserData)(pool, helpersContract, weth.address, borrower.address);
        const amountToLiquidate = userReserveDataBefore.currentVariableDebt.div(2);
        // The supply is the same, but there should be a change in who has what. The liquidator should have received what the borrower lost.
        const tx = await pool.liquidationCall(weth.address, dai.address, borrower.address, amountToLiquidate, true);
        const userReserveDataAfter = await helpersContract.getUserReserveData(dai.address, borrower.address);
        const userWethReserveDataAfter = await helpersContract.getUserReserveData(weth.address, borrower.address);
        const userGlobalDataAfter = await pool.getUserAccountData(borrower.address);
        const daiReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, dai.address);
        const ethReserveDataAfter = await (0, helpers_1.getReserveData)(helpersContract, weth.address);
        const collateralPrice = await oracle.getAssetPrice(weth.address);
        const principalPrice = await oracle.getAssetPrice(dai.address);
        const collateralDecimals = (await helpersContract.getReserveConfigurationData(weth.address))
            .decimals;
        const principalDecimals = (await helpersContract.getReserveConfigurationData(dai.address))
            .decimals;
        const expectedCollateralLiquidated = principalPrice
            .mul(amountToLiquidate)
            .percentMul(10500)
            .mul(ethers_1.BigNumber.from(10).pow(collateralDecimals))
            .div(collateralPrice.mul(ethers_1.BigNumber.from(10).pow(principalDecimals)));
        (0, chai_1.expect)(expectedCollateralLiquidated).to.be.closeTo(userWethReserveDataBefore.currentATokenBalance.sub(userWethReserveDataAfter.currentATokenBalance), 2, 'Invalid collateral amount liquidated');
        if (!tx.blockNumber) {
            (0, chai_1.expect)(false, 'Invalid block number');
            return;
        }
        const txTimestamp = ethers_1.BigNumber.from((await hre.ethers.provider.getBlock(tx.blockNumber)).timestamp);
        const variableDebtBeforeTx = (0, calculations_1.calcExpectedVariableDebtTokenBalance)(daiReserveDataBefore, userReserveDataBefore, txTimestamp);
        (0, chai_1.expect)(userReserveDataAfter.currentVariableDebt).to.be.closeTo(variableDebtBeforeTx.sub(amountToLiquidate), 2, 'Invalid user borrow balance after liquidation');
        (0, chai_1.expect)(daiReserveDataAfter.availableLiquidity).to.be.closeTo(daiReserveDataBefore.availableLiquidity.add(amountToLiquidate), 2, 'Invalid principal available liquidity');
        //the liquidity index of the principal reserve needs to be bigger than the index before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityIndex).to.be.gte(daiReserveDataBefore.liquidityIndex, 'Invalid liquidity index');
        //the principal APY after a liquidation needs to be lower than the APY before
        (0, chai_1.expect)(daiReserveDataAfter.liquidityRate).to.be.lt(daiReserveDataBefore.liquidityRate, 'Invalid liquidity APY');
        (0, chai_1.expect)(ethReserveDataAfter.availableLiquidity).to.be.closeTo(ethReserveDataBefore.availableLiquidity, 2, 'Invalid collateral available liquidity');
        (0, chai_1.expect)((await helpersContract.getUserReserveData(weth.address, deployer.address))
            .usageAsCollateralEnabled).to.be.true;
    });
});
