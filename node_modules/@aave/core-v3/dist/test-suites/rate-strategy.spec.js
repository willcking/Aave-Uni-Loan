"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const bignumber_1 = require("@ethersproject/bignumber");
const contract_deployments_1 = require("@aave/deploy-v3/dist/helpers/contract-deployments");
const constants_1 = require("../helpers/constants");
const reservesConfigs_1 = require("@aave/deploy-v3/dist/markets/test/reservesConfigs");
const rateStrategies_1 = require("@aave/deploy-v3/dist/markets/test/rateStrategies");
const make_suite_1 = require("./helpers/make-suite");
const types_1 = require("../helpers/types");
const units_1 = require("@ethersproject/units");
require("./helpers/utils/wadraymath");
const DEBUG = false;
(0, make_suite_1.makeSuite)('InterestRateStrategy', (testEnv) => {
    let strategyInstance;
    let dai;
    let aDai;
    const baseStableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1).add(rateStrategies_1.rateStrategyStableTwo.baseStableRateOffset);
    const { INVALID_OPTIMAL_USAGE_RATIO, INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO } = types_1.ProtocolErrors;
    before(async () => {
        dai = testEnv.dai;
        aDai = testEnv.aDai;
        const { addressesProvider } = testEnv;
        strategyInstance = await (0, contract_deployments_1.deployDefaultReserveInterestRateStrategy)([
            addressesProvider.address,
            rateStrategies_1.rateStrategyStableTwo.optimalUsageRatio,
            rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.baseStableRateOffset,
            rateStrategies_1.rateStrategyStableTwo.stableRateExcessOffset,
            rateStrategies_1.rateStrategyStableTwo.optimalStableToTotalDebtRatio,
        ]);
    });
    it('Checks rates at 0% usage ratio, empty reserve', async () => {
        let params = {
            unbacked: 0,
            liquidityAdded: 0,
            liquidityTaken: 0,
            totalStableDebt: 0,
            totalVariableDebt: 0,
            averageStableBorrowRate: 0,
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(0, 'Invalid liquidity rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate, 'Invalid stable rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate, 'Invalid variable rate');
    });
    it('Checks rates at 80% usage ratio', async () => {
        let params = {
            unbacked: 0,
            liquidityAdded: '200000000000000000',
            liquidityTaken: 0,
            totalStableDebt: 0,
            totalVariableDebt: '800000000000000000',
            averageStableBorrowRate: 0,
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate).add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedVariableRate
            .percentMul(8000)
            .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor)), 'Invalid liquidity rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate.add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1), 'Invalid stable rate');
        if (DEBUG) {
            console.log(`Current Liquidity Rate: ${(0, units_1.formatUnits)(currentLiquidityRate, 27)}`);
            console.log(`Current Borrow Rate V : ${(0, units_1.formatUnits)(currentVariableBorrowRate, 27)}`);
            console.log(`Current Borrow Rate S : ${(0, units_1.formatUnits)(currentStableBorrowRate, 27)}`);
        }
    });
    it('Checks rates at 100% usage ratio', async () => {
        let params = {
            unbacked: 0,
            liquidityAdded: '0',
            liquidityTaken: 0,
            totalStableDebt: 0,
            totalVariableDebt: '1000000000000000000',
            averageStableBorrowRate: 0,
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate)
            .add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1)
            .add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope2);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedVariableRate.percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor)), 'Invalid liquidity rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate
            .add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1)
            .add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope2), 'Invalid stable rate');
        if (DEBUG) {
            console.log(`Current Liquidity Rate: ${(0, units_1.formatUnits)(currentLiquidityRate, 27)}`);
            console.log(`Current Borrow Rate V : ${(0, units_1.formatUnits)(currentVariableBorrowRate, 27)}`);
            console.log(`Current Borrow Rate S : ${(0, units_1.formatUnits)(currentStableBorrowRate, 27)}`);
        }
    });
    it('Checks rates at 100% usage ratio, 50% stable debt and 50% variable debt, with a 10% avg stable rate', async () => {
        let params = {
            unbacked: 0,
            liquidityAdded: '0',
            liquidityTaken: 0,
            totalStableDebt: '400000000000000000',
            totalVariableDebt: '400000000000000000',
            averageStableBorrowRate: '100000000000000000000000000',
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate)
            .add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1)
            .add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope2);
        const expectedLiquidityRate = bignumber_1.BigNumber.from(currentVariableBorrowRate)
            .add(ethers_1.utils.parseUnits('0.1', 27))
            .div('2')
            .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor));
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedLiquidityRate, 'Invalid liquidity rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate
            .add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1)
            .add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope2)
            .add(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.stableRateExcessOffset).rayMul(bignumber_1.BigNumber.from(ethers_1.utils.parseUnits('0.375', 27)))), 'Invalid stable rate');
    });
    it('Checks rates at 80% borrow usage ratio and 50% supply usage due to minted tokens', async () => {
        let params = {
            unbacked: '600000000000000000',
            liquidityAdded: '200000000000000000',
            liquidityTaken: 0,
            totalStableDebt: '0',
            totalVariableDebt: '800000000000000000',
            averageStableBorrowRate: '0',
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate).add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedVariableRate
            .percentMul(5000)
            .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor)), 'Invalid liquidity rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate.add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1), 'Invalid stable rate');
    });
    it('Checks rates at 80% borrow usage ratio and 0.8% supply usage due to minted tokens', async () => {
        const availableLiquidity = bignumber_1.BigNumber.from('200000000000000000');
        const totalVariableDebt = bignumber_1.BigNumber.from('800000000000000000');
        let params = {
            unbacked: totalVariableDebt.mul('124').sub(availableLiquidity),
            liquidityAdded: availableLiquidity,
            liquidityTaken: 0,
            totalStableDebt: '0',
            totalVariableDebt: totalVariableDebt,
            averageStableBorrowRate: '0',
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate).add(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1);
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedVariableRate
            .percentMul(80)
            .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor)), 'Invalid liquidity rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate.add(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1), 'Invalid stable rate');
        if (DEBUG) {
            console.log(`Current Liquidity Rate: ${(0, units_1.formatUnits)(currentLiquidityRate, 27)}`);
            console.log(`Current Borrow Rate V : ${(0, units_1.formatUnits)(currentVariableBorrowRate, 27)}`);
            console.log(`Current Borrow Rate S : ${(0, units_1.formatUnits)(currentStableBorrowRate, 27)}`);
        }
    });
    it('Checks rates at 0.8% usage', async () => {
        let params = {
            unbacked: 0,
            liquidityAdded: '9920000000000000000000',
            liquidityTaken: 0,
            totalStableDebt: '0',
            totalVariableDebt: '80000000000000000000',
            averageStableBorrowRate: '0',
            reserveFactor: reservesConfigs_1.strategyDAI.reserveFactor,
            reserve: dai.address,
            aToken: aDai.address,
        };
        const { 0: currentLiquidityRate, 1: currentStableBorrowRate, 2: currentVariableBorrowRate, } = await strategyInstance.calculateInterestRates(params);
        const usageRatio = bignumber_1.BigNumber.from(1).ray().percentMul(80);
        const OPTIMAL_USAGE_RATIO = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.optimalUsageRatio);
        const expectedVariableRate = bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate).add(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1).rayMul(usageRatio.rayDiv(OPTIMAL_USAGE_RATIO)));
        (0, chai_1.expect)(currentLiquidityRate).to.be.equal(expectedVariableRate
            .percentMul(80)
            .percentMul(bignumber_1.BigNumber.from(constants_1.PERCENTAGE_FACTOR).sub(reservesConfigs_1.strategyDAI.reserveFactor)), 'Invalid liquidity rate');
        (0, chai_1.expect)(currentVariableBorrowRate).to.be.equal(expectedVariableRate, 'Invalid variable rate');
        (0, chai_1.expect)(currentStableBorrowRate).to.be.equal(baseStableRate.add(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1).rayMul(usageRatio.rayDiv(OPTIMAL_USAGE_RATIO))), 'Invalid stable rate');
        if (DEBUG) {
            console.log(`Current Liquidity Rate: ${(0, units_1.formatUnits)(currentLiquidityRate, 27)}`);
            console.log(`Current Borrow Rate V : ${(0, units_1.formatUnits)(currentVariableBorrowRate, 27)}`);
            console.log(`Current Borrow Rate S : ${(0, units_1.formatUnits)(currentStableBorrowRate, 27)}`);
        }
    });
    it('Checks getters', async () => {
        (0, chai_1.expect)(await strategyInstance.OPTIMAL_USAGE_RATIO()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.optimalUsageRatio);
        (0, chai_1.expect)(await strategyInstance.getBaseVariableBorrowRate()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate);
        (0, chai_1.expect)(await strategyInstance.getVariableRateSlope1()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1);
        (0, chai_1.expect)(await strategyInstance.getVariableRateSlope2()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.variableRateSlope2);
        (0, chai_1.expect)(await strategyInstance.getStableRateSlope1()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.stableRateSlope1);
        (0, chai_1.expect)(await strategyInstance.getStableRateSlope2()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.stableRateSlope2);
        (0, chai_1.expect)(await strategyInstance.getMaxVariableBorrowRate()).to.be.eq(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate)
            .add(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.variableRateSlope1))
            .add(bignumber_1.BigNumber.from(rateStrategies_1.rateStrategyStableTwo.variableRateSlope2)));
        (0, chai_1.expect)(await strategyInstance.MAX_EXCESS_USAGE_RATIO()).to.be.eq(bignumber_1.BigNumber.from(1).ray().sub(rateStrategies_1.rateStrategyStableTwo.optimalUsageRatio));
        (0, chai_1.expect)(await strategyInstance.MAX_EXCESS_STABLE_TO_TOTAL_DEBT_RATIO()).to.be.eq(bignumber_1.BigNumber.from(1).ray().sub(rateStrategies_1.rateStrategyStableTwo.optimalStableToTotalDebtRatio));
        (0, chai_1.expect)(await strategyInstance.getStableRateExcessOffset()).to.be.eq(rateStrategies_1.rateStrategyStableTwo.stableRateExcessOffset);
    });
    it('Deploy an interest rate strategy with optimalUsageRatio out of range (expect revert)', async () => {
        const { addressesProvider } = testEnv;
        await (0, chai_1.expect)((0, contract_deployments_1.deployDefaultReserveInterestRateStrategy)([
            addressesProvider.address,
            ethers_1.utils.parseUnits('1.0', 28),
            rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.baseStableRateOffset,
            rateStrategies_1.rateStrategyStableTwo.stableRateExcessOffset,
            rateStrategies_1.rateStrategyStableTwo.optimalStableToTotalDebtRatio,
        ])).to.be.revertedWith(INVALID_OPTIMAL_USAGE_RATIO);
    });
    it('Deploy an interest rate strategy with optimalStableToTotalDebtRatio out of range (expect revert)', async () => {
        const { addressesProvider } = testEnv;
        await (0, chai_1.expect)((0, contract_deployments_1.deployDefaultReserveInterestRateStrategy)([
            addressesProvider.address,
            rateStrategies_1.rateStrategyStableTwo.optimalUsageRatio,
            rateStrategies_1.rateStrategyStableTwo.baseVariableBorrowRate,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.variableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope1,
            rateStrategies_1.rateStrategyStableTwo.stableRateSlope2,
            rateStrategies_1.rateStrategyStableTwo.baseStableRateOffset,
            rateStrategies_1.rateStrategyStableTwo.stableRateExcessOffset,
            ethers_1.utils.parseUnits('1.0', 28),
        ])).to.be.revertedWith(INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO);
    });
});
