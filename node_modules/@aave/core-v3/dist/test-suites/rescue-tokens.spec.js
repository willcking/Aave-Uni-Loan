"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Rescue tokens', (testEnv) => {
    const { CALLER_NOT_POOL_ADMIN, CALLER_MUST_BE_POOL, UNDERLYING_CANNOT_BE_RESCUED } = types_1.ProtocolErrors;
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('User tries to rescue tokens from Pool (revert expected)', async () => {
        const { pool, usdc, users: [rescuer], } = testEnv;
        const amount = 1;
        await (0, chai_1.expect)(pool.connect(rescuer.signer).rescueTokens(usdc.address, rescuer.address, amount)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('PoolAdmin rescue tokens from Pool', async () => {
        const { poolAdmin, pool, usdc, users: [locker], faucetMintable } = testEnv;
        const amountToLock = ethers_1.utils.parseUnits('10', 18);
        // Lock
        await faucetMintable.mint(usdc.address, locker.address, amountToLock);
        await usdc.connect(locker.signer).transfer(pool.address, amountToLock);
        const lockerBalanceBefore = await usdc.balanceOf(locker.address);
        const poolBalanceBefore = await usdc.balanceOf(pool.address);
        (0, chai_1.expect)(await pool.connect(poolAdmin.signer).rescueTokens(usdc.address, locker.address, amountToLock));
        const poolBalanceAfter = await usdc.balanceOf(pool.address);
        (0, chai_1.expect)(poolBalanceBefore).to.be.eq(poolBalanceAfter.add(amountToLock));
        const lockerBalanceAfter = await usdc.balanceOf(locker.address);
        (0, chai_1.expect)(lockerBalanceBefore).to.be.eq(lockerBalanceAfter.sub(amountToLock));
    });
    it('User tries to rescue tokens from AToken (revert expected)', async () => {
        const { usdc, aDai, users: [rescuer], } = testEnv;
        const amount = 1;
        await (0, chai_1.expect)(aDai.connect(rescuer.signer).rescueTokens(usdc.address, rescuer.address, amount)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('User tries to rescue tokens of underlying from AToken (revert expected)', async () => {
        const { aDai, dai, users: [rescuer], } = testEnv;
        const amount = 1;
        await (0, chai_1.expect)(aDai.connect(rescuer.signer).rescueTokens(dai.address, rescuer.address, amount)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('PoolAdmin tries to rescue tokens of underlying from AToken (revert expected)', async () => {
        const { poolAdmin, aDai, dai, users: [rescuer], } = testEnv;
        const amount = 1;
        await (0, chai_1.expect)(aDai.connect(poolAdmin.signer).rescueTokens(dai.address, rescuer.address, amount)).to.be.revertedWith(UNDERLYING_CANNOT_BE_RESCUED);
    });
    it('PoolAdmin rescue tokens from AToken', async () => {
        const { poolAdmin, dai, usdc, aDai, users: [locker], faucetMintable } = testEnv;
        const amountToLock = ethers_1.utils.parseUnits('10', 18);
        // Lock
        await faucetMintable.mint(usdc.address, locker.address, amountToLock);
        await usdc.connect(locker.signer).transfer(aDai.address, amountToLock);
        const lockerBalanceBefore = await usdc.balanceOf(locker.address);
        const aTokenBalanceBefore = await usdc.balanceOf(aDai.address);
        (0, chai_1.expect)(await aDai.connect(poolAdmin.signer).rescueTokens(usdc.address, locker.address, amountToLock));
        const aTokenBalanceAfter = await usdc.balanceOf(aDai.address);
        (0, chai_1.expect)(aTokenBalanceBefore).to.be.eq(aTokenBalanceAfter.add(amountToLock));
        const lockerBalanceAfter = await usdc.balanceOf(locker.address);
        (0, chai_1.expect)(lockerBalanceBefore).to.be.eq(lockerBalanceAfter.sub(amountToLock));
    });
});
