"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const bignumber_1 = require("@ethersproject/bignumber");
const contract_deployments_1 = require("@aave/deploy-v3/dist/helpers/contract-deployments");
const types_1 = require("../helpers/types");
const deploy_v3_1 = require("@aave/deploy-v3");
describe('ReserveConfiguration', async () => {
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    let configMock;
    const ZERO = bignumber_1.BigNumber.from(0);
    const LTV = bignumber_1.BigNumber.from(8000);
    const LB = bignumber_1.BigNumber.from(500);
    const RESERVE_FACTOR = bignumber_1.BigNumber.from(1000);
    const DECIMALS = bignumber_1.BigNumber.from(18);
    const BORROW_CAP = bignumber_1.BigNumber.from(100);
    const SUPPLY_CAP = bignumber_1.BigNumber.from(200);
    const UNBACKED_MINT_CAP = bignumber_1.BigNumber.from(300);
    const EMODE_CATEGORY = bignumber_1.BigNumber.from(1);
    const MAX_VALID_LTV = bignumber_1.BigNumber.from(65535);
    const MAX_VALID_LIQUIDATION_THRESHOLD = bignumber_1.BigNumber.from(65535);
    const MAX_VALID_DECIMALS = bignumber_1.BigNumber.from(255);
    const MAX_VALID_EMODE_CATEGORY = bignumber_1.BigNumber.from(255);
    const MAX_VALID_RESERVE_FACTOR = bignumber_1.BigNumber.from(65535);
    const MAX_VALID_LIQUIDATION_PROTOCOL_FEE = bignumber_1.BigNumber.from(65535);
    before(async () => {
        configMock = await (0, contract_deployments_1.deployMockReserveConfiguration)();
    });
    const bigNumbersToArrayString = (arr) => arr.map((x) => x.toString());
    it('getLtv()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setLtv(LTV));
        // LTV is the 1st param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([LTV, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(LTV);
        (0, chai_1.expect)(await configMock.setLtv(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
    });
    it('getLiquidationBonus()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationBonus()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setLiquidationBonus(LB));
        // LB is the 3rd param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, LB, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationBonus()).to.be.eq(LB);
        (0, chai_1.expect)(await configMock.setLiquidationBonus(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationBonus()).to.be.eq(ZERO);
    });
    it('getDecimals()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setDecimals(DECIMALS));
        // decimals is the 4th param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, DECIMALS, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(DECIMALS);
        (0, chai_1.expect)(await configMock.setDecimals(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
    });
    it('getEModeCategory()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setEModeCategory(EMODE_CATEGORY));
        // eMode category is the 6th param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, EMODE_CATEGORY]));
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(EMODE_CATEGORY);
        (0, chai_1.expect)(await configMock.setEModeCategory(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
    });
    it('getFrozen()', async () => {
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getFrozen()).to.be.false;
        (0, chai_1.expect)(await configMock.setFrozen(true));
        // frozen is the 2nd flag
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, true, false, false, false]);
        (0, chai_1.expect)(await configMock.getFrozen()).to.be.true;
        (0, chai_1.expect)(await configMock.setFrozen(false));
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getFrozen()).to.be.false;
    });
    it('getBorrowingEnabled()', async () => {
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getBorrowingEnabled()).to.be.false;
        (0, chai_1.expect)(await configMock.setBorrowingEnabled(true));
        // borrowing is the 3rd flag
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, true, false, false]);
        (0, chai_1.expect)(await configMock.getBorrowingEnabled()).to.be.true;
        (0, chai_1.expect)(await configMock.setBorrowingEnabled(false));
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getBorrowingEnabled()).to.be.false;
    });
    it('getStableRateBorrowingEnabled()', async () => {
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getStableRateBorrowingEnabled()).to.be.false;
        (0, chai_1.expect)(await configMock.setStableRateBorrowingEnabled(true));
        // stable borrowing is the 4th flag
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, true, false]);
        (0, chai_1.expect)(await configMock.getStableRateBorrowingEnabled()).to.be.true;
        (0, chai_1.expect)(await configMock.setStableRateBorrowingEnabled(false));
        (0, chai_1.expect)(await configMock.getFlags()).to.be.eql([false, false, false, false, false]);
        (0, chai_1.expect)(await configMock.getStableRateBorrowingEnabled()).to.be.false;
    });
    it('getReserveFactor()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getReserveFactor()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setReserveFactor(RESERVE_FACTOR));
        // reserve factor is the 5th param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, RESERVE_FACTOR, ZERO]));
        (0, chai_1.expect)(await configMock.getReserveFactor()).to.be.eq(RESERVE_FACTOR);
        (0, chai_1.expect)(await configMock.setReserveFactor(ZERO));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getReserveFactor()).to.be.eq(ZERO);
    });
    it('setReserveFactor() with reserveFactor == MAX_VALID_RESERVE_FACTOR', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.setReserveFactor(MAX_VALID_RESERVE_FACTOR));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, MAX_VALID_RESERVE_FACTOR, ZERO]));
    });
    it('setReserveFactor() with reserveFactor > MAX_VALID_RESERVE_FACTOR', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        await (0, chai_1.expect)(configMock.setReserveFactor(MAX_VALID_RESERVE_FACTOR.add(1))).to.be.revertedWith(types_1.ProtocolErrors.INVALID_RESERVE_FACTOR);
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
    });
    it('getBorrowCap()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getBorrowCap()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setBorrowCap(BORROW_CAP));
        // borrow cap is the 1st cap
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([BORROW_CAP, ZERO]));
        (0, chai_1.expect)(await configMock.getBorrowCap()).to.be.eq(BORROW_CAP);
        (0, chai_1.expect)(await configMock.setBorrowCap(ZERO));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getBorrowCap()).to.be.eq(ZERO);
    });
    it('getSupplyCap()', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getSupplyCap()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setSupplyCap(SUPPLY_CAP));
        // supply cap is the 2nd cap
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([ZERO, SUPPLY_CAP]));
        (0, chai_1.expect)(await configMock.getSupplyCap()).to.be.eq(SUPPLY_CAP);
        (0, chai_1.expect)(await configMock.setSupplyCap(ZERO));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getCaps())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getSupplyCap()).to.be.eq(ZERO);
    });
    it('getUnbackedMintCap()', async () => {
        (0, chai_1.expect)(await configMock.getUnbackedMintCap()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setUnbackedMintCap(UNBACKED_MINT_CAP));
        (0, chai_1.expect)(await configMock.getUnbackedMintCap()).to.be.eq(UNBACKED_MINT_CAP);
        (0, chai_1.expect)(await configMock.setUnbackedMintCap(ZERO));
        (0, chai_1.expect)(await configMock.getUnbackedMintCap()).to.be.eq(ZERO);
    });
    it('getFlashLoanEnabled()', async () => {
        (0, chai_1.expect)(await configMock.getFlashLoanEnabled()).to.be.eq(false);
        (0, chai_1.expect)(await configMock.setFlashLoanEnabled(true));
        (0, chai_1.expect)(await configMock.getFlashLoanEnabled()).to.be.eq(true);
        (0, chai_1.expect)(await configMock.setFlashLoanEnabled(false));
    });
    it('setLtv() with ltv = MAX_VALID_LTV', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setLtv(MAX_VALID_LTV));
        // LTV is the 1st param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([MAX_VALID_LTV, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(MAX_VALID_LTV);
        (0, chai_1.expect)(await configMock.setLtv(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
    });
    it('setLtv() with ltv > MAX_VALID_LTV (revert expected)', async () => {
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
        const { INVALID_LTV } = types_1.ProtocolErrors;
        // setLTV to MAX_VALID_LTV + 1
        await (0, chai_1.expect)(configMock.setLtv(MAX_VALID_LTV.add(1))).to.be.revertedWith(INVALID_LTV);
        (0, chai_1.expect)(await configMock.getLtv()).to.be.eq(ZERO);
    });
    it('setLiquidationThreshold() with threshold = MAX_VALID_LIQUIDATION_THRESHOLD', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationThreshold()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setLiquidationThreshold(MAX_VALID_LIQUIDATION_THRESHOLD));
        // LIQ_THRESHOLD is the 2nd param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, MAX_VALID_LIQUIDATION_THRESHOLD, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationThreshold()).to.be.eq(MAX_VALID_LIQUIDATION_THRESHOLD);
        (0, chai_1.expect)(await configMock.setLiquidationThreshold(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getLiquidationThreshold()).to.be.eq(ZERO);
    });
    it('setLiquidationThreshold() with threshold > MAX_VALID_LIQUIDATION_THRESHOLD (revert expected)', async () => {
        (0, chai_1.expect)(await configMock.getLiquidationThreshold()).to.be.eq(ZERO);
        const { INVALID_LIQ_THRESHOLD } = types_1.ProtocolErrors;
        // setLiquidationThreshold to MAX_VALID_LIQUIDATION_THRESHOLD + 1
        await (0, chai_1.expect)(configMock.setLiquidationThreshold(MAX_VALID_LIQUIDATION_THRESHOLD.add(1))).to.be.revertedWith(INVALID_LIQ_THRESHOLD);
        (0, chai_1.expect)(await configMock.getLiquidationThreshold()).to.be.eq(ZERO);
    });
    it('setDecimals() with decimals = MAX_VALID_DECIMALS', async () => {
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setDecimals(MAX_VALID_DECIMALS));
        // Decimals is the 4th param
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, MAX_VALID_DECIMALS, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(MAX_VALID_DECIMALS);
        (0, chai_1.expect)(await configMock.setDecimals(0));
        (0, chai_1.expect)(bigNumbersToArrayString(await configMock.getParams())).to.be.eql(bigNumbersToArrayString([ZERO, ZERO, ZERO, ZERO, ZERO, ZERO]));
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
    });
    it('setDecimals() with decimals > MAX_VALID_DECIMALS (revert expected)', async () => {
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
        const { INVALID_DECIMALS } = types_1.ProtocolErrors;
        // setDecimals to MAX_VALID_DECIMALS + 1
        await (0, chai_1.expect)(configMock.setDecimals(MAX_VALID_DECIMALS.add(1))).to.be.revertedWith(INVALID_DECIMALS);
        (0, chai_1.expect)(await configMock.getDecimals()).to.be.eq(ZERO);
    });
    it('setEModeCategory() with categoryID = MAX_VALID_EMODE_CATEGORY', async () => {
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setEModeCategory(MAX_VALID_EMODE_CATEGORY));
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(MAX_VALID_EMODE_CATEGORY);
        (0, chai_1.expect)(await configMock.setEModeCategory(0));
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
    });
    it('setEModeCategory() with categoryID > MAX_VALID_EMODE_CATEGORY (revert expected)', async () => {
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
        const { INVALID_EMODE_CATEGORY } = types_1.ProtocolErrors;
        await (0, chai_1.expect)(configMock.setEModeCategory(MAX_VALID_EMODE_CATEGORY.add(1))).to.be.revertedWith(INVALID_EMODE_CATEGORY);
        (0, chai_1.expect)(await configMock.getEModeCategory()).to.be.eq(ZERO);
    });
    it('setLiquidationProtocolFee() with liquidationProtocolFee == MAX_VALID_LIQUIDATION_PROTOCOL_FEE', async () => {
        (0, chai_1.expect)(await configMock.getLiquidationProtocolFee()).to.be.eq(ZERO);
        (0, chai_1.expect)(await configMock.setLiquidationProtocolFee(MAX_VALID_LIQUIDATION_PROTOCOL_FEE));
        (0, chai_1.expect)(await configMock.getLiquidationProtocolFee()).to.be.eq(MAX_VALID_LIQUIDATION_PROTOCOL_FEE);
    });
    it('setLiquidationProtocolFee() with liquidationProtocolFee > MAX_VALID_LIQUIDATION_PROTOCOL_FEE', async () => {
        (0, chai_1.expect)(await configMock.getLiquidationProtocolFee()).to.be.eq(ZERO);
        await (0, chai_1.expect)(configMock.setLiquidationProtocolFee(MAX_VALID_LIQUIDATION_PROTOCOL_FEE.add(1))).to.be.revertedWith(types_1.ProtocolErrors.INVALID_LIQUIDATION_PROTOCOL_FEE);
        (0, chai_1.expect)(await configMock.getLiquidationProtocolFee()).to.be.eq(ZERO);
    });
});
