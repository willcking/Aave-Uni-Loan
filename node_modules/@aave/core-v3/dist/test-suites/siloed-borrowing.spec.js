"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require('chai');
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const make_suite_1 = require("./helpers/make-suite");
require("./helpers/utils/wadraymath");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Siloed borrowing', (testEnv) => {
    const { SILOED_BORROWING_VIOLATION } = types_1.ProtocolErrors;
    let snapshot;
    before(async () => {
        snapshot = await (0, deploy_v3_1.evmSnapshot)();
    });
    it('Configure DAI as siloed borrowing asset', async () => {
        const { configurator, helpersContract, dai } = testEnv;
        await configurator.setSiloedBorrowing(dai.address, true);
        const siloed = await helpersContract.getSiloedBorrowing(dai.address);
        expect(siloed).to.be.equal(true, 'Invalid siloed state for DAI');
    });
    it('User 0 supplies DAI, User 1 supplies ETH and USDC, borrows DAI', async () => {
        const { users, pool, dai, weth, usdc, variableDebtDai, faucetMintable } = testEnv;
        const wethSupplyAmount = ethers_1.utils.parseEther('1');
        const daiBorrowAmount = ethers_1.utils.parseEther('10');
        const daiSupplyAmount = ethers_1.utils.parseEther('1000');
        const usdcSupplyAmount = ethers_1.utils.parseUnits('1000', 6);
        await faucetMintable.mint(dai.address, users[0].address, daiSupplyAmount);
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool.connect(users[0].signer).supply(dai.address, daiSupplyAmount, users[0].address, '0');
        await faucetMintable.mint(usdc.address, users[1].address, usdcSupplyAmount);
        await usdc.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(usdc.address, usdcSupplyAmount, users[1].address, '0');
        await faucetMintable.mint(weth.address, users[1].address, wethSupplyAmount);
        await weth.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .supply(weth.address, wethSupplyAmount, users[1].address, '0');
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, daiBorrowAmount, types_1.RateMode.Variable, '0', users[1].address);
        const debtBalance = await variableDebtDai.balanceOf(users[1].address);
        expect(debtBalance).to.be.closeTo(daiBorrowAmount, 2);
    });
    it('User 0 supplies USDC, User 1 tries to borrow USDC (revert expected)', async () => {
        const { users, pool, usdc, faucetMintable } = testEnv;
        const usdcBorrowAmount = ethers_1.utils.parseUnits('1', '6');
        const usdcSupplyAmount = ethers_1.utils.parseUnits('1000', '6');
        await faucetMintable.mint(usdc.address, users[0].address, usdcSupplyAmount);
        await usdc.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .supply(usdc.address, usdcSupplyAmount, users[0].address, '0');
        await expect(pool
            .connect(users[1].signer)
            .borrow(usdc.address, usdcBorrowAmount, types_1.RateMode.Variable, '0', users[1].address)).to.be.revertedWith(SILOED_BORROWING_VIOLATION);
    });
    it('User 1 repays DAI, borrows USDC', async () => {
        const { users, pool, usdc, dai, faucetMintable } = testEnv;
        const usdcBorrowAmount = ethers_1.utils.parseUnits('100', '6');
        const daiMintAmount = ethers_1.utils.parseEther('1000');
        await faucetMintable.mint(dai.address, users[1].address, daiMintAmount);
        await dai.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .repay(dai.address, constants_1.MAX_UINT_AMOUNT, types_1.RateMode.Variable, users[1].address);
        await pool
            .connect(users[1].signer)
            .borrow(usdc.address, usdcBorrowAmount, types_1.RateMode.Variable, '0', users[1].address);
    });
    it('User 1 tries to borrow DAI (revert expected)', async () => {
        const { users, pool, dai } = testEnv;
        const daiBorrowAmount = ethers_1.utils.parseEther('1');
        await expect(pool
            .connect(users[1].signer)
            .borrow(dai.address, daiBorrowAmount, types_1.RateMode.Variable, '0', users[1].address)).to.be.revertedWith(SILOED_BORROWING_VIOLATION);
    });
    it('User 1 borrows ETH, tries to borrow DAI (revert expected)', async () => {
        const { users, pool, dai, weth } = testEnv;
        const wethBorrowAmount = ethers_1.utils.parseEther('0.01');
        const daiBorrowAmount = ethers_1.utils.parseEther('1');
        await pool
            .connect(users[1].signer)
            .borrow(weth.address, wethBorrowAmount, types_1.RateMode.Variable, '0', users[1].address);
        await expect(pool
            .connect(users[1].signer)
            .borrow(dai.address, daiBorrowAmount, types_1.RateMode.Variable, '0', users[1].address)).to.be.revertedWith(SILOED_BORROWING_VIOLATION);
    });
    it('User 1 Repays USDC and WETH debt, set USDC as siloed', async () => {
        const { users, pool, usdc, weth, configurator, helpersContract, faucetMintable } = testEnv;
        const wethMintAmount = ethers_1.utils.parseEther('1');
        const usdcMintAmount = ethers_1.utils.parseEther('1000');
        await faucetMintable.mint(usdc.address, users[1].address, usdcMintAmount);
        await usdc.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .repay(usdc.address, constants_1.MAX_UINT_AMOUNT, types_1.RateMode.Variable, users[1].address);
        await faucetMintable.mint(weth.address, users[1].address, wethMintAmount);
        await pool
            .connect(users[1].signer)
            .repay(weth.address, constants_1.MAX_UINT_AMOUNT, types_1.RateMode.Variable, users[1].address);
        await configurator.setSiloedBorrowing(usdc.address, true);
        const siloed = await helpersContract.getSiloedBorrowing(usdc.address);
        expect(siloed).to.be.equal(true, 'Invalid siloed state for USDC');
    });
    it('User 1 borrows DAI, tries to borrow USDC (revert expected)', async () => {
        const { users, pool, usdc, dai } = testEnv;
        const daiBorrowAmount = ethers_1.utils.parseEther('1');
        const usdcBorrowAmount = ethers_1.utils.parseUnits('1', '6');
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, daiBorrowAmount, types_1.RateMode.Variable, '0', users[1].address);
        await expect(pool
            .connect(users[1].signer)
            .borrow(usdc.address, usdcBorrowAmount, types_1.RateMode.Variable, '0', users[1].address)).to.be.revertedWith(SILOED_BORROWING_VIOLATION);
    });
    it('User 1 borrows more DAI', async () => {
        const { users, pool, dai, variableDebtDai } = testEnv;
        const daiBorrowAmount = ethers_1.utils.parseEther('1');
        const debtBefore = await variableDebtDai.balanceOf(users[1].address);
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, daiBorrowAmount, types_1.RateMode.Variable, '0', users[1].address);
        const debtAfter = await variableDebtDai.balanceOf(users[1].address);
        //large interval to account for interest generated
        expect(debtAfter).to.be.closeTo(debtBefore.add(daiBorrowAmount), 10000000);
    });
});
