"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deploy_v3_1 = require("@aave/deploy-v3");
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const bignumber_1 = require("@ethersproject/bignumber");
const constants_1 = require("../helpers/constants");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const tokenization_events_1 = require("./helpers/utils/tokenization-events");
const DEBUG = false;
let balances = {
    balance: {},
};
const log = (str) => {
    if (DEBUG)
        console.log(str);
};
const printBalance = async (name, debtToken, userAddress) => {
    console.log(name, 'balanceOf', await hardhat_1.ethers.utils.formatEther(await debtToken.balanceOf(userAddress)));
};
const increaseSupplyIndex = async (pool, faucet, depositor, collateral, assetToIncrease) => {
    const collateralToken = deploy_v3_1.MintableERC20__factory.connect(collateral, depositor.signer);
    const borrowingToken = deploy_v3_1.MintableERC20__factory.connect(assetToIncrease, depositor.signer);
    await faucet.mint(collateralToken.address, depositor.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(collateralToken.address, '10000000'));
    await collateralToken.connect(depositor.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
    await pool
        .connect(depositor.signer)
        .deposit(collateral, await (0, contracts_helpers_1.convertToCurrencyDecimals)(collateral, '100000'), depositor.address, '0');
    const { aTokenAddress } = await pool.getReserveData(assetToIncrease);
    const availableLiquidity = await borrowingToken.balanceOf(aTokenAddress);
    await pool
        .connect(depositor.signer)
        .borrow(assetToIncrease, availableLiquidity.percentMul('20'), types_1.RateMode.Variable, 0, depositor.address);
    await (0, deploy_v3_1.advanceTimeAndBlock)(10000000);
};
const updateBalances = (balances, stableDebtDai, receipt) => {
    var _a, _b, _c;
    let events = (0, tokenization_events_1.getStableDebtTokenEvent)(stableDebtDai, receipt, 'Mint');
    for (const ev of events) {
        balances.balance[ev.onBehalfOf] = (_a = balances.balance[ev.onBehalfOf]) === null || _a === void 0 ? void 0 : _a.add(ev.amount);
    }
    events = (0, tokenization_events_1.getStableDebtTokenEvent)(stableDebtDai, receipt, 'Burn');
    for (const ev of events) {
        balances.balance[ev.from] = (_b = balances.balance[ev.from]) === null || _b === void 0 ? void 0 : _b.sub(ev.amount.add(ev.balanceIncrease));
        balances.balance[ev.from] = (_c = balances.balance[ev.from]) === null || _c === void 0 ? void 0 : _c.add(ev.balanceIncrease);
    }
};
(0, make_suite_1.makeSuite)('StableDebtToken: Events', (testEnv) => {
    let alice, bob, depositor, depositor2;
    let snapId;
    before(async () => {
        const { users, pool, dai, weth, faucetMintable } = testEnv;
        [alice, bob, depositor, depositor2] = users;
        const amountToMint = await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '10000000');
        const usersToInit = [alice, bob, depositor, depositor2];
        for (const user of usersToInit) {
            await faucetMintable.mint(dai.address, user.address, amountToMint);
            await faucetMintable.mint(weth.address, user.address, amountToMint);
            await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
            await weth.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        }
        // Depositors
        await pool.connect(depositor.signer).supply(weth.address, amountToMint, depositor.address, '0');
        await pool.connect(depositor.signer).supply(dai.address, amountToMint, depositor.address, '0');
        await pool
            .connect(depositor2.signer)
            .supply(weth.address, amountToMint, depositor2.address, '0');
        await pool
            .connect(depositor2.signer)
            .supply(dai.address, amountToMint, depositor2.address, '0');
    });
    beforeEach(async () => {
        snapId = await (0, deploy_v3_1.evmSnapshot)();
        // Init balances
        balances = {
            balance: {
                [alice.address]: bignumber_1.BigNumber.from(0),
                [bob.address]: bignumber_1.BigNumber.from(0),
            },
        };
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snapId);
    });
    it('Alice borrows 100 DAI, borrows 50 DAI, repays 20 DAI, repays 10 DAI, borrows 100 DAI, repays 220 DAI (without index change)', async () => {
        await testMultipleBorrowsAndRepays(false);
    });
    it('Alice borrows 100 DAI, borrows 50 DAI, repays 20 DAI, repays 10 DAI, borrows 100 DAI, repays 220 DAI (with index change)', async () => {
        await testMultipleBorrowsAndRepays(true);
    });
    const testMultipleBorrowsAndRepays = async (indexChange) => {
        const { pool, dai, stableDebtDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await stableDebtDai.balanceOf(alice.address);
        log('- Alice supplies 1000 WETH');
        await (0, tokenization_events_1.supply)(pool, alice, weth.address, '100000', alice.address, false);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 100 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '100', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 50 DAI more');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '50', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (DEBUG) {
            await printBalance('alice', stableDebtDai, alice.address);
        }
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 20 DAI');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '20', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 10 DAI');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '10', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor2, weth.address, dai.address);
        }
        log('- Alice borrows 100 DAI more');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '100', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor2, weth.address, dai.address);
        }
        log('- Alice repays 220 DAI');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '220', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        // Check final balances
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '1', alice.address);
        updateBalances(balances, stableDebtDai, rcpt);
        const aliceBalanceAfter = await stableDebtDai.balanceOf(alice.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 2);
    };
    it('Alice borrows 100 DAI, Bob borrows 100 DAI, Alice borrows 50 DAI, repays 150 DAI and repays 100 DAI on behalf of Bob, borrows 10 DAI more (without index change)', async () => {
        await testMultipleBorrowsAndRepaysOnBehalf(false);
    });
    it('Alice borrows 100 DAI, Bob borrows 100 DAI, Alice borrows 50 DAI, repays 150 DAI and repays 100 DAI on behalf of Bob, borrows 10 DAI more (with index change)', async () => {
        await testMultipleBorrowsAndRepaysOnBehalf(true);
    });
    const testMultipleBorrowsAndRepaysOnBehalf = async (indexChange) => {
        const { pool, dai, stableDebtDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await stableDebtDai.balanceOf(alice.address);
        let bobBalanceBefore = await stableDebtDai.balanceOf(bob.address);
        log('- Alice supplies 1000 WETH');
        await (0, tokenization_events_1.supply)(pool, alice, weth.address, '1000', alice.address, false);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 100 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '100', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Bob supplies 1000 WETH');
        await (0, tokenization_events_1.supply)(pool, bob, weth.address, '1000', bob.address, false);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Bob borrows 100 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, bob, dai.address, '100', bob.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 50 DAI more');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '50', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 150 DAI');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '150', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 50 DAI on behalf of Bob');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '50', bob.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 50 DAI on behalf of Bob');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '50', bob.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 10 DAI more');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '10', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        if (DEBUG) {
            await printBalance('alice', stableDebtDai, alice.address);
            await printBalance('bob', stableDebtDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '1', alice.address);
        updateBalances(balances, stableDebtDai, rcpt);
        const aliceBalanceAfter = await stableDebtDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, bob, dai.address, '1', bob.address);
        updateBalances(balances, stableDebtDai, rcpt);
        const bobBalanceAfter = await stableDebtDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 5);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 5);
    };
    it('Alice borrows 100 DAI, Bob borrows 100 DAI on behalf of Alice, Bob borrows 50 DAI, Alice borrows 50 DAI, repays 250 DAI and repays 50 DAI on behalf of Bob, borrows 10 DAI more (without index change)', async () => {
        await testMultipleBorrowsOnBehalfAndRepaysOnBehalf(false);
    });
    it('Alice borrows 100 DAI, Bob borrows 100 DAI on behalf of Alice, Bob borrows 50 DAI, Alice borrows 50 DAI, repays 250 DAI and repays 50 DAI on behalf of Bob, borrows 10 DAI more (with index change)', async () => {
        await testMultipleBorrowsOnBehalfAndRepaysOnBehalf(true);
    });
    const testMultipleBorrowsOnBehalfAndRepaysOnBehalf = async (indexChange) => {
        const { pool, dai, stableDebtDai, weth, faucetMintable } = testEnv;
        let rcpt;
        let aliceBalanceBefore = await stableDebtDai.balanceOf(alice.address);
        let bobBalanceBefore = await stableDebtDai.balanceOf(bob.address);
        log('- Alice supplies 1000 WETH');
        await (0, tokenization_events_1.supply)(pool, alice, weth.address, '1000', alice.address, false);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 100 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '100', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Bob borrows 100 DAI on behalf of Alice');
        await stableDebtDai.connect(alice.signer).approveDelegation(bob.address, constants_1.MAX_UINT_AMOUNT);
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, bob, dai.address, '100', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Bob supplies 1000 WETH');
        await (0, tokenization_events_1.supply)(pool, bob, weth.address, '1000', bob.address, false);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Bob borrows 50 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, bob, dai.address, '50', bob.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 50 DAI');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '50', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 250 DAI');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '250', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice repays 50 DAI on behalf of Bob');
        rcpt = await (0, tokenization_events_1.repayStableBorrow)(pool, alice, dai.address, '50', bob.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        log('- Alice borrows 10 DAI more');
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '10', alice.address, DEBUG);
        updateBalances(balances, stableDebtDai, rcpt);
        if (indexChange) {
            log('- Increase index due to great borrow of DAI');
            await increaseSupplyIndex(pool, faucetMintable, depositor, weth.address, dai.address);
        }
        if (DEBUG) {
            await printBalance('alice', stableDebtDai, alice.address);
            await printBalance('bob', stableDebtDai, bob.address);
        }
        // Check final balances
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, alice, dai.address, '1', alice.address);
        updateBalances(balances, stableDebtDai, rcpt);
        const aliceBalanceAfter = await stableDebtDai.balanceOf(alice.address);
        rcpt = await (0, tokenization_events_1.stableBorrow)(pool, bob, dai.address, '1', bob.address);
        updateBalances(balances, stableDebtDai, rcpt);
        const bobBalanceAfter = await stableDebtDai.balanceOf(bob.address);
        (0, chai_1.expect)(aliceBalanceAfter).to.be.closeTo(aliceBalanceBefore.add(balances.balance[alice.address]), 5);
        (0, chai_1.expect)(bobBalanceAfter).to.be.closeTo(bobBalanceBefore.add(balances.balance[bob.address]), 5);
    };
});
