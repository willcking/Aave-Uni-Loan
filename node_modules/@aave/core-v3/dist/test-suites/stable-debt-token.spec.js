"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const misc_utils_1 = require("../helpers/misc-utils");
const make_suite_1 = require("./helpers/make-suite");
const funds_1 = require("./helpers/utils/funds");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const deploy_v3_1 = require("@aave/deploy-v3");
const types_2 = require("../types");
const tokenization_events_1 = require("./helpers/utils/tokenization-events");
(0, make_suite_1.makeSuite)('StableDebtToken', (testEnv) => {
    const { CALLER_MUST_BE_POOL, CALLER_NOT_POOL_ADMIN } = types_1.ProtocolErrors;
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Check initialization', async () => {
        const { pool, weth, dai, helpersContract, users, faucetMintable } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        (0, chai_1.expect)(await stableDebtContract.UNDERLYING_ASSET_ADDRESS()).to.be.eq(dai.address);
        (0, chai_1.expect)(await stableDebtContract.POOL()).to.be.eq(pool.address);
        (0, chai_1.expect)(await stableDebtContract.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        const totSupplyAndRateBefore = await stableDebtContract.getTotalSupplyAndAvgRate();
        (0, chai_1.expect)(totSupplyAndRateBefore[0].toString()).to.be.eq('0');
        (0, chai_1.expect)(totSupplyAndRateBefore[1].toString()).to.be.eq('0');
        // Need to create some debt to do this good
        await faucetMintable.mint(dai.address, users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'), users[0].address, 0);
        await faucetMintable.mint(weth.address, users[1].address, ethers_1.utils.parseEther('10'));
        await weth.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .deposit(weth.address, ethers_1.utils.parseEther('10'), users[1].address, 0);
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '200'), types_1.RateMode.Stable, 0, users[1].address);
        const totSupplyAndRateAfter = await stableDebtContract.getTotalSupplyAndAvgRate();
        (0, chai_1.expect)(totSupplyAndRateAfter[0]).to.be.gt(0);
        (0, chai_1.expect)(totSupplyAndRateAfter[1]).to.be.gt(0);
    });
    it('Tries to mint not being the Pool (revert expected)', async () => {
        const { deployer, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, deployer.signer);
        await (0, chai_1.expect)(stableDebtContract.mint(deployer.address, deployer.address, '1', '1')).to.be.revertedWith(CALLER_MUST_BE_POOL);
    });
    it('Tries to burn not being the Pool (revert expected)', async () => {
        const { deployer, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, deployer.signer);
        const name = await stableDebtContract.name();
        (0, chai_1.expect)(name).to.be.equal('Aave Testnet Stable Debt DAI');
        await (0, chai_1.expect)(stableDebtContract.burn(deployer.address, '1')).to.be.revertedWith(CALLER_MUST_BE_POOL);
    });
    it('Tries to transfer debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(stableDebtContract.connect(users[0].signer).transfer(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Check Mint and Transfer events when borrowing on behalf', async () => {
        // const snapId = await evmSnapshot();
        const { pool, weth, dai, usdc, users: [user1, user2, user3], faucetMintable } = testEnv;
        // Add USDC liquidity
        await faucetMintable.mint(usdc.address, user3.address, ethers_1.utils.parseUnits('1000', 6));
        await usdc.connect(user3.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user3.signer)
            .supply(usdc.address, ethers_1.utils.parseUnits('1000', 6), user3.address, 0);
        // User1 supplies 10 WETH
        await faucetMintable.mint(weth.address, user1.address, ethers_1.utils.parseEther('10'));
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user1.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('10', 18), user1.address, 0);
        const usdcData = await pool.getReserveData(usdc.address);
        const stableDebtToken = types_2.StableDebtToken__factory.connect(usdcData.stableDebtTokenAddress, user1.signer);
        const beforeDebtBalanceUser2 = await stableDebtToken.balanceOf(user2.address);
        // User1 borrows 100 USDC
        const borrowAmount = ethers_1.utils.parseUnits('100', 6);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .borrow(usdc.address, borrowAmount, types_1.RateMode.Stable, 0, user1.address));
        // User1 approves user2 to borrow 1000 USDC
        (0, chai_1.expect)(await stableDebtToken
            .connect(user1.signer)
            .approveDelegation(user2.address, ethers_1.utils.parseUnits('1000', 6)));
        // Increase time so interests accrue
        await (0, deploy_v3_1.increaseTime)(24 * 3600);
        // User2 borrows 1000 USDC on behalf of user1
        const borrowOnBehalfAmount = ethers_1.utils.parseUnits('100', 6);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(user2.signer)
            .borrow(usdc.address, borrowOnBehalfAmount, types_1.RateMode.Stable, 0, user1.address));
        const afterDebtBalanceUser1 = await stableDebtToken.balanceOf(user1.address);
        const afterDebtBalanceUser2 = await stableDebtToken.balanceOf(user2.address);
        // Calculate interests
        const expectedDebtIncreaseUser1 = afterDebtBalanceUser1.sub(borrowOnBehalfAmount.add(borrowAmount));
        const parsedTransferEvents = (0, tokenization_events_1.getStableDebtTokenEvent)(stableDebtToken, tx, 'Transfer');
        const transferAmount = parsedTransferEvents[0].value;
        const parsedMintEvents = (0, tokenization_events_1.getStableDebtTokenEvent)(stableDebtToken, tx, 'Mint');
        const { amount: mintAmount, balanceIncrease } = parsedMintEvents[0];
        (0, chai_1.expect)(expectedDebtIncreaseUser1.add(borrowOnBehalfAmount)).to.be.eq(transferAmount);
        (0, chai_1.expect)(borrowOnBehalfAmount.add(balanceIncrease)).to.be.eq(mintAmount);
        (0, chai_1.expect)(expectedDebtIncreaseUser1).to.be.eq(balanceIncrease);
        (0, chai_1.expect)(afterDebtBalanceUser2).to.be.eq(beforeDebtBalanceUser2);
        // await evmRevert(snapId);
    });
    it('Tries to approve debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(stableDebtContract.connect(users[0].signer).approve(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
        await (0, chai_1.expect)(stableDebtContract.allowance(users[0].address, users[1].address)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to increase allowance of debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(stableDebtContract.connect(users[0].signer).increaseAllowance(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to decrease allowance of debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(stableDebtContract.connect(users[0].signer).decreaseAllowance(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to transferFrom (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiStableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address))
            .stableDebtTokenAddress;
        const stableDebtContract = types_2.StableDebtToken__factory.connect(daiStableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(stableDebtContract
            .connect(users[0].signer)
            .transferFrom(users[0].address, users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Burn stable debt tokens such that `secondTerm >= firstTerm`', async () => {
        // To enter the case where secondTerm >= firstTerm, we also need previousSupply <= amount.
        // The easiest way is to use two users, such that for user 2 his stableRate > average stableRate.
        // In practice to enter the case we can perform the following actions
        // user 1 borrow 2 wei at rate = 10**27
        // user 2 borrow 1 wei rate = 10**30
        // progress time by a year, to accrue significant debt.
        // then let user 2 withdraw sufficient funds such that secondTerm (userStableRate * burnAmount) >= averageRate * supply
        // if we do not have user 1 deposit as well, we will have issues getting past previousSupply <= amount, as amount > supply for secondTerm to be > firstTerm.
        // await evmRevert(snap);
        const rateGuess1 = ethers_1.BigNumber.from(constants_1.RAY);
        const rateGuess2 = ethers_1.BigNumber.from(10).pow(30);
        const amount1 = ethers_1.BigNumber.from(2);
        const amount2 = ethers_1.BigNumber.from(1);
        const { deployer, pool, dai, helpersContract, users } = testEnv;
        // Impersonate the Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const config = await helpersContract.getReserveTokensAddresses(dai.address);
        const stableDebt = types_2.StableDebtToken__factory.connect(config.stableDebtTokenAddress, deployer.signer);
        // Next two txs should be mined in the same block
        await (0, misc_utils_1.setAutomine)(false);
        await stableDebt
            .connect(poolSigner)
            .mint(users[0].address, users[0].address, amount1, rateGuess1);
        await stableDebt
            .connect(poolSigner)
            .mint(users[1].address, users[1].address, amount2, rateGuess2);
        await (0, misc_utils_1.setAutomine)(true);
        await (0, deploy_v3_1.increaseTime)(60 * 60 * 24 * 365);
        const totalSupplyAfterTime = ethers_1.BigNumber.from(18798191);
        await stableDebt.connect(poolSigner).burn(users[1].address, totalSupplyAfterTime.sub(1));
    });
    it('setIncentivesController() ', async () => {
        // const snapshot = await evmSnapshot();
        const { dai, helpersContract, poolAdmin, aclManager, deployer } = testEnv;
        const config = await helpersContract.getReserveTokensAddresses(dai.address);
        const stableDebt = types_2.StableDebtToken__factory.connect(config.stableDebtTokenAddress, deployer.signer);
        (0, chai_1.expect)(await aclManager.connect(deployer.signer).addPoolAdmin(poolAdmin.address));
        (0, chai_1.expect)(await stableDebt.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(await stableDebt.connect(poolAdmin.signer).setIncentivesController(constants_1.ZERO_ADDRESS));
        (0, chai_1.expect)(await stableDebt.getIncentivesController()).to.be.eq(constants_1.ZERO_ADDRESS);
        // await evmRevert(snapshot);
    });
    it('setIncentivesController() from not pool admin (revert expected)', async () => {
        const { dai, helpersContract, users: [user], } = testEnv;
        const config = await helpersContract.getReserveTokensAddresses(dai.address);
        const stableDebt = types_2.StableDebtToken__factory.connect(config.stableDebtTokenAddress, user.signer);
        (0, chai_1.expect)(await stableDebt.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        await (0, chai_1.expect)(stableDebt.connect(user.signer).setIncentivesController(constants_1.ZERO_ADDRESS)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('User borrows and repays in same block with zero fees', async () => {
        const { pool, users, dai, aDai, usdc, stableDebtDai, faucetMintable } = testEnv;
        const user = users[0];
        // We need some debt.
        await faucetMintable.mint(usdc.address, user.address, ethers_1.utils.parseUnits('2000', 18));
        await usdc.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(usdc.address, ethers_1.utils.parseEther('2000'), user.address, 0);
        await faucetMintable.mint(dai.address, user.address, ethers_1.utils.parseEther('2000'));
        await dai.connect(user.signer).transfer(aDai.address, ethers_1.utils.parseEther('2000'));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userDataBefore = await pool.getUserAccountData(user.address);
        (0, chai_1.expect)(await stableDebtDai.balanceOf(user.address)).to.be.eq(0);
        // Turn off automining - pretty sure that coverage is getting messed up here.
        await (0, misc_utils_1.setAutomine)(false);
        // Borrow 500 dai
        await pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('500'), types_1.RateMode.Stable, 0, user.address);
        // Turn on automining, but not mine a new block until next tx
        await (0, misc_utils_1.setAutomineEvm)(true);
        (0, chai_1.expect)(await pool
            .connect(user.signer)
            .repay(dai.address, ethers_1.utils.parseEther('500'), types_1.RateMode.Stable, user.address));
        (0, chai_1.expect)(await stableDebtDai.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(aDai.address)).to.be.eq(ethers_1.utils.parseEther('2000'));
        const userDataAfter = await pool.getUserAccountData(user.address);
        (0, chai_1.expect)(userDataBefore.totalCollateralBase).to.be.lte(userDataAfter.totalCollateralBase);
        (0, chai_1.expect)(userDataBefore.healthFactor).to.be.lte(userDataAfter.healthFactor);
        (0, chai_1.expect)(userDataBefore.totalDebtBase).to.be.eq(userDataAfter.totalDebtBase);
    });
    it('User borrows and repays in same block using credit delegation with zero fees', async () => {
        const { pool, dai, aDai, weth, users: [user1, user2, user3], faucetMintable } = testEnv;
        // Add liquidity
        await faucetMintable.mint(dai.address, user3.address, ethers_1.utils.parseEther('1000'));
        await dai.connect(user3.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user3.signer)
            .supply(dai.address, ethers_1.utils.parseUnits('1000', 18), user3.address, 0);
        // User1 supplies 10 WETH
        await faucetMintable.mint(dai.address, user1.address, ethers_1.utils.parseEther('100'));
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(weth.address, user1.address, ethers_1.utils.parseEther('10'));
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user1.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('10', 18), user1.address, 0);
        const daiData = await pool.getReserveData(dai.address);
        const stableDebtToken = await (0, deploy_v3_1.getStableDebtToken)(daiData.stableDebtTokenAddress);
        // User1 approves User2 to borrow 1000 DAI
        (0, chai_1.expect)(await stableDebtToken
            .connect(user1.signer)
            .approveDelegation(user2.address, ethers_1.utils.parseUnits('1000', 18)));
        const userDataBefore = await pool.getUserAccountData(user1.address);
        // Turn off automining to simulate actions in same block
        await (0, misc_utils_1.setAutomine)(false);
        // User2 borrows 2 DAI on behalf of User1
        (0, chai_1.expect)(await pool
            .connect(user2.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Stable, 0, user1.address));
        // Turn on automining, but not mine a new block until next tx
        await (0, misc_utils_1.setAutomineEvm)(true);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .repay(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Stable, user1.address));
        (0, chai_1.expect)(await stableDebtToken.balanceOf(user1.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(user2.address)).to.be.eq(ethers_1.utils.parseEther('2'));
        (0, chai_1.expect)(await dai.balanceOf(aDai.address)).to.be.eq(ethers_1.utils.parseEther('1000'));
        const userDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userDataBefore.totalCollateralBase).to.be.lte(userDataAfter.totalCollateralBase);
        (0, chai_1.expect)(userDataBefore.healthFactor).to.be.lte(userDataAfter.healthFactor);
        (0, chai_1.expect)(userDataBefore.totalDebtBase).to.be.eq(userDataAfter.totalDebtBase);
    });
});
