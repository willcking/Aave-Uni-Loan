"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const make_suite_1 = require("./helpers/make-suite");
const types_1 = require("../helpers/types");
const constants_1 = require("../helpers/constants");
const contract_getters_1 = require("@aave/deploy-v3/dist/helpers/contract-getters");
const signer_1 = require("@aave/deploy-v3/dist/helpers/utilities/signer");
const contract_deployments_1 = require("@aave/deploy-v3/dist/helpers/contract-deployments");
const types_2 = require("../types");
const deploy_v3_1 = require("@aave/deploy-v3");
(0, make_suite_1.makeSuite)('Upgradeability', (testEnv) => {
    context('VersionedInitializable', async () => {
        it('Call initialize from the constructor function', async () => {
            const initValue = '1';
            const implementation = await (0, contract_deployments_1.deployMockInitializableFromConstructorImple)([initValue]);
            (0, chai_1.expect)(await implementation.value()).to.be.eq(initValue);
        });
        it('Call initialize from the initialize function (reentrant)', async () => {
            const initValue = 1;
            const finalValue = 2;
            const implementation = await (0, contract_deployments_1.deployMockReentrantInitializableImple)();
            (0, chai_1.expect)(await implementation.initialize(initValue));
            (0, chai_1.expect)(await implementation.value()).to.be.eq(finalValue, `value is not ${finalValue}`);
        });
        it('Tries to initialize once it is already initialized (revert expected)', async () => {
            const implementation = await (0, contract_deployments_1.deployMockInitializableImple)();
            (0, chai_1.expect)(await implementation.initialize(10, // value
            'some text', // text
            [10, 20, 30]));
            await (0, chai_1.expect)(implementation.initialize(100, // value
            'some text', // text
            [100, 200, 300])).to.be.revertedWith('Contract instance has already been initialized');
        });
    });
    context('InitializableImmutableAdminUpgradeabilityProxy', async () => {
        let snap;
        let proxyAdminOwner, newAdmin, nonAdmin;
        let implementationV1, implementationV2, proxiedImpl;
        let proxy;
        beforeEach(async () => {
            snap = await (0, deploy_v3_1.evmSnapshot)();
            implementationV1 = await (0, contract_deployments_1.deployMockInitializableImple)();
            implementationV2 = await (0, contract_deployments_1.deployMockInitializableImpleV2)();
            const encodedInitialize = implementationV1.interface.encodeFunctionData('initialize', [
                0,
                'text',
                [1, 2, 3], // values
            ]);
            proxy = await (0, contract_deployments_1.deployInitializableImmutableAdminUpgradeabilityProxy)([proxyAdminOwner.address]);
            (0, chai_1.expect)(await proxy.initialize(implementationV1.address, encodedInitialize));
            proxiedImpl = await (0, contract_getters_1.getMockInitializableImple)(proxy.address);
        });
        afterEach(async () => {
            await (0, deploy_v3_1.evmRevert)(snap);
        });
        before(async () => {
            const { users } = testEnv;
            [proxyAdminOwner, newAdmin, nonAdmin] = users;
            [proxyAdminOwner, newAdmin, nonAdmin] = await (0, deploy_v3_1.getEthersSigners)();
        });
        it('initialize() implementation version is correct', async () => {
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).REVISION()).to.be.eq(1, 'impl revision is not 1');
        });
        it('initialize() implementation initialization is correct', async () => {
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(0, 'impl value is not 0');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).text()).to.be.eq('text', 'impl text is not correct');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(0)).to.be.eq(1, 'impl values[0] is not 1');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(1)).to.be.eq(2, 'impl values[1] is not 2');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(2)).to.be.eq(3, 'impl values[2] is not 3');
        });
        it('initialize() when initializing the proxy once it is already initialized (revert expected)', async () => {
            const encodedInitialize = proxiedImpl.interface.encodeFunctionData('initialize', [
                10,
                'some text',
                [10, 20, 30],
            ]);
            await (0, chai_1.expect)(proxy.initialize(implementationV1.address, encodedInitialize)).to.be.reverted;
        });
        it('initialize() when initializing the impl from non-admin address once it is already initialized (revert expected)', async () => {
            await (0, chai_1.expect)(proxiedImpl.connect(nonAdmin).initialize(10, // value
            'some text', // text
            [10, 20, 30])).to.be.revertedWith('Contract instance has already been initialized');
        });
        it('initialize() when initializing the impl from admin address once it is already initialized (revert expected)', async () => {
            await (0, chai_1.expect)(proxiedImpl.connect(proxyAdminOwner).initialize(10, // value
            'some text', // text
            [10, 20, 30])).to.be.revertedWith('Cannot call fallback function from the proxy admin');
        });
        it('initialize() deploy a proxy and call to initialize() with no initialization data', async () => {
            proxy = await (await new types_2.InitializableImmutableAdminUpgradeabilityProxy__factory(await (0, signer_1.getFirstSigner)()).deploy(proxyAdminOwner.address)).deployed();
            (0, chai_1.expect)(await proxy.initialize(implementationV1.address, Buffer.from('')));
        });
        it('initialize() while calling initialize() with wrong initialization data (revert expected)', async () => {
            proxy = await (await new types_2.InitializableImmutableAdminUpgradeabilityProxy__factory(await (0, signer_1.getFirstSigner)()).deploy(proxyAdminOwner.address)).deployed();
            // Initialize with wrong initialization data
            await (0, chai_1.expect)(proxy.initialize(implementationV1.address, Buffer.from('wrongInitialize'))).to.be
                .reverted;
        });
        it('admin() non-view function from admin address', async () => {
            (0, chai_1.expect)(await proxy.connect(proxyAdminOwner).admin());
        });
        it('admin() non-view function from non-admin address', async () => {
            await (0, chai_1.expect)(proxy.connect(nonAdmin).admin()).to.be.reverted;
        });
        it('admin() callStatic from admin address', async () => {
            (0, chai_1.expect)(await proxy.connect(proxyAdminOwner).callStatic.admin()).to.be.eq(proxyAdminOwner.address, 'proxy admin address not correct');
        });
        it('implementation() non-view function from admin address', async () => {
            (0, chai_1.expect)(await proxy.connect(proxyAdminOwner).implementation());
        });
        it('implementation() non-view function from non-admin address', async () => {
            await (0, chai_1.expect)(proxy.connect(nonAdmin).implementation()).to.be.reverted;
        });
        it('implementation() callStatic from admin address', async () => {
            (0, chai_1.expect)(await proxy.connect(proxyAdminOwner).callStatic.implementation()).to.be.eq(implementationV1.address, 'proxy implementation address not correct');
        });
        it('upgradeTo() to a new imple from non-admin address (revert expected)', async () => {
            await (0, chai_1.expect)(proxy.connect(nonAdmin).upgradeTo(implementationV2.address)).to.be.reverted;
        });
        it('upgradeTo() to a non-contract imple from admin address (revert expected)', async () => {
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeTo(constants_1.ONE_ADDRESS)).to.be.revertedWith('Cannot set a proxy implementation to a non-contract address');
        });
        it('upgradeTo() to a new imple from admin address', async () => {
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).REVISION()).to.be.eq(1, 'impl revision is not 1');
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeTo(implementationV2.address))
                .to.emit(proxy, 'Upgraded')
                .withArgs(implementationV2.address);
            proxiedImpl = await (0, contract_getters_1.getMockInitializableImpleV2)(proxy.address);
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).REVISION()).to.be.eq(2, 'impl revision is not 2');
            // Check proxy storage layout keeps the same
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(0, 'impl value is not 0');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).text()).to.be.eq('text', 'impl text is not correct');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(0)).to.be.eq(1, 'impl values[0] is not 1');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(1)).to.be.eq(2, 'impl values[1] is not 2');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(2)).to.be.eq(3, 'impl values[2] is not 3');
            // Initialize
            await proxiedImpl.connect(nonAdmin).initialize(10, // value
            'some text', // text
            [10, 20, 30]);
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(10, 'impl value is not 0');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).text()).to.be.eq('some text', 'impl text not correct');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(0)).to.be.eq(10, 'impl values[0] not 10');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(1)).to.be.eq(20, 'impl values[1] not 20');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(2)).to.be.eq(30, 'impl values[2] not 30');
        });
        it('upgradeTo() when initializing the new imple from admin address (revert expected)', async () => {
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeTo(implementationV2.address))
                .to.emit(proxy, 'Upgraded')
                .withArgs(implementationV2.address);
            // Initialize
            await proxiedImpl.connect(nonAdmin).initialize(10, // value
            'some text', // text
            [10, 20, 30]);
            await (0, chai_1.expect)(proxiedImpl.connect(nonAdmin).initialize(10, // value
            'some text', // text
            [10, 20, 30])).to.be.revertedWith('Contract instance has already been initialized');
        });
        it('upgradeToAndCall() to a new impl from non-admin address (revert expected)', async () => {
            await (0, chai_1.expect)(proxy.connect(nonAdmin).upgradeToAndCall(implementationV2.address, Buffer.from(''))).to.be.reverted;
        });
        it('upgradeToAndCall() to a non-contract impl from admin address (revert expected)', async () => {
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeToAndCall(constants_1.ONE_ADDRESS, Buffer.from(''))).to.be.revertedWith('Cannot set a proxy implementation to a non-contract address');
        });
        it('upgradeToAndCall() to a new impl from admin address', async () => {
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).REVISION()).to.be.eq(1, 'impl revision is not 1');
            const encodedInitialize = implementationV1.interface.encodeFunctionData('initialize', [
                10,
                'some text',
                [10, 20, 30],
            ]);
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeToAndCall(implementationV2.address, encodedInitialize))
                .to.emit(proxy, 'Upgraded')
                .withArgs(implementationV2.address);
            proxiedImpl = await (0, contract_getters_1.getMockInitializableImpleV2)(proxy.address);
            // Check initialization
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).REVISION()).to.be.eq(2, 'impl revision is not 2');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(10, 'impl value is not 0');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).text()).to.be.eq('some text', 'impl text not correct');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(0)).to.be.eq(10, 'impl values[0] not 10');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(1)).to.be.eq(20, 'impl values[1] not 20');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).values(2)).to.be.eq(30, 'impl values[2] not 30');
        });
        it('upgradeToAndCall() for a new proxied contract with no initialize function (revert expected)', async () => {
            const impl = await (0, contract_deployments_1.deployMockInitializableImple)();
            const encodedInitialize = Buffer.from('');
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeToAndCall(impl.address, encodedInitialize))
                .reverted;
        });
        it('upgradeToAndCall() when initializing the new impl from admin address once it is already initialized (revert expected)', async () => {
            const encodedInitialize = implementationV1.interface.encodeFunctionData('initialize', [
                10,
                'some text',
                [10, 20, 30],
            ]);
            await (0, chai_1.expect)(proxy.connect(proxyAdminOwner).upgradeToAndCall(implementationV2.address, encodedInitialize))
                .to.emit(proxy, 'Upgraded')
                .withArgs(implementationV2.address);
            await (0, chai_1.expect)(proxiedImpl.connect(nonAdmin).initialize(10, // value
            'some text', // text
            [10, 20, 30])).to.be.revertedWith('Contract instance has already been initialized');
        });
        it('implementation.setValue() call through the proxy', async () => {
            const newValue = 123;
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(0, 'value not correct');
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).setValueViaProxy(newValue));
            (0, chai_1.expect)(await proxiedImpl.connect(nonAdmin).value()).to.be.eq(123, 'value not correct');
        });
        it('implementation.setValue() direct call to the implementation', async () => {
            const newValue = 123;
            (0, chai_1.expect)(await implementationV1.value()).to.be.eq(0, 'value not correct');
            (0, chai_1.expect)(await implementationV1.setValue(newValue));
            (0, chai_1.expect)(await implementationV1.value()).to.be.eq(123, 'value not correct');
        });
    });
    context('PoolConfigurator upgrade ability', () => {
        const { CALLER_NOT_POOL_ADMIN } = types_1.ProtocolErrors;
        let newATokenAddress;
        let newStableTokenAddress;
        let newVariableTokenAddress;
        before('deploying instances', async () => {
            const { dai, pool } = testEnv;
            const aTokenInstance = await (0, contract_deployments_1.deployMockAToken)([
                pool.address,
                dai.address,
                constants_1.ZERO_ADDRESS,
                constants_1.ZERO_ADDRESS,
                'Aave Interest bearing DAI updated',
                'aDAI',
                '0x10',
            ]);
            const stableDebtTokenInstance = await (0, contract_deployments_1.deployMockStableDebtToken)([
                pool.address,
                dai.address,
                constants_1.ZERO_ADDRESS,
                'Aave stable debt bearing DAI updated',
                'stableDebtDAI',
                '0x10',
            ]);
            const variableDebtTokenInstance = await (0, contract_deployments_1.deployMockVariableDebtToken)([
                pool.address,
                dai.address,
                constants_1.ZERO_ADDRESS,
                'Aave variable debt bearing DAI updated',
                'variableDebtDAI',
                '0x10',
            ]);
            newATokenAddress = aTokenInstance.address;
            newVariableTokenAddress = variableDebtTokenInstance.address;
            newStableTokenAddress = stableDebtTokenInstance.address;
        });
        it('Tries to update the DAI Atoken implementation with a different address than the poolManager', async () => {
            const { dai, configurator, users } = testEnv;
            const name = await (await (0, contract_getters_1.getAToken)(newATokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getAToken)(newATokenAddress)).symbol();
            const updateATokenInputParams = {
                asset: dai.address,
                treasury: constants_1.ZERO_ADDRESS,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newATokenAddress,
                params: '0x10',
            };
            await (0, chai_1.expect)(configurator.connect(users[1].signer).updateAToken(updateATokenInputParams)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
        });
        it('Upgrades the DAI Atoken implementation ', async () => {
            const { dai, configurator, aDai } = testEnv;
            const name = await (await (0, contract_getters_1.getAToken)(newATokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getAToken)(newATokenAddress)).symbol();
            const updateATokenInputParams = {
                asset: dai.address,
                treasury: constants_1.ZERO_ADDRESS,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newATokenAddress,
                params: '0x10',
            };
            await configurator.updateAToken(updateATokenInputParams);
            const tokenName = await aDai.name();
            (0, chai_1.expect)(tokenName).to.be.eq('Aave Interest bearing DAI updated', 'Invalid token name');
        });
        it('Tries to update the DAI Stable debt token implementation with a different address than the poolManager', async () => {
            const { dai, configurator, users } = testEnv;
            const name = await (await (0, contract_getters_1.getStableDebtToken)(newStableTokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getStableDebtToken)(newStableTokenAddress)).symbol();
            const updateDebtTokenInput = {
                asset: dai.address,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newStableTokenAddress,
                params: '0x10',
            };
            await (0, chai_1.expect)(configurator.connect(users[1].signer).updateStableDebtToken(updateDebtTokenInput)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
        });
        it('Upgrades the DAI stable debt token implementation ', async () => {
            const { dai, configurator, helpersContract } = testEnv;
            const name = await (await (0, contract_getters_1.getStableDebtToken)(newStableTokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getStableDebtToken)(newStableTokenAddress)).symbol();
            const updateDebtTokenInput = {
                asset: dai.address,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newStableTokenAddress,
                params: '0x10',
            };
            await configurator.updateStableDebtToken(updateDebtTokenInput);
            const { stableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(dai.address);
            const debtToken = await (0, contract_getters_1.getMockStableDebtToken)(stableDebtTokenAddress);
            const tokenName = await debtToken.name();
            (0, chai_1.expect)(tokenName).to.be.eq('Aave stable debt bearing DAI updated', 'Invalid token name');
        });
        it('Tries to update the DAI variable debt token implementation with a different address than the poolManager', async () => {
            const { dai, configurator, users } = testEnv;
            const name = await (await (0, contract_getters_1.getVariableDebtToken)(newVariableTokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getVariableDebtToken)(newVariableTokenAddress)).symbol();
            const updateDebtTokenInput = {
                asset: dai.address,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newVariableTokenAddress,
                params: '0x10',
            };
            await (0, chai_1.expect)(configurator.connect(users[1].signer).updateVariableDebtToken(updateDebtTokenInput)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
        });
        it('Upgrades the DAI variable debt token implementation ', async () => {
            const { dai, configurator, helpersContract } = testEnv;
            const name = await (await (0, contract_getters_1.getVariableDebtToken)(newVariableTokenAddress)).name();
            const symbol = await (await (0, contract_getters_1.getVariableDebtToken)(newVariableTokenAddress)).symbol();
            const updateDebtTokenInput = {
                asset: dai.address,
                incentivesController: constants_1.ZERO_ADDRESS,
                name: name,
                symbol: symbol,
                implementation: newVariableTokenAddress,
                params: '0x10',
            };
            (0, chai_1.expect)(await configurator.updateVariableDebtToken(updateDebtTokenInput));
            const { variableDebtTokenAddress } = await helpersContract.getReserveTokensAddresses(dai.address);
            const debtToken = await (0, contract_getters_1.getMockVariableDebtToken)(variableDebtTokenAddress);
            const tokenName = await debtToken.name();
            (0, chai_1.expect)(tokenName).to.be.eq('Aave variable debt bearing DAI updated', 'Invalid token name');
        });
    });
});
