"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const ethers_1 = require("ethers");
const misc_utils_1 = require("../helpers/misc-utils");
const constants_1 = require("../helpers/constants");
const types_1 = require("../helpers/types");
const make_suite_1 = require("./helpers/make-suite");
const funds_1 = require("./helpers/utils/funds");
const contracts_helpers_1 = require("../helpers/contracts-helpers");
const deploy_v3_1 = require("@aave/deploy-v3");
const types_2 = require("../types");
require("./helpers/utils/wadraymath");
const tokenization_events_1 = require("./helpers/utils/tokenization-events");
(0, make_suite_1.makeSuite)('VariableDebtToken', (testEnv) => {
    const { CALLER_MUST_BE_POOL, INVALID_MINT_AMOUNT, INVALID_BURN_AMOUNT, CALLER_NOT_POOL_ADMIN } = types_1.ProtocolErrors;
    let snap;
    beforeEach(async () => {
        snap = await (0, deploy_v3_1.evmSnapshot)();
    });
    afterEach(async () => {
        await (0, deploy_v3_1.evmRevert)(snap);
    });
    it('Check initialization', async () => {
        const { pool, weth, dai, helpersContract, users, faucetMintable } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = await types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        (0, chai_1.expect)(await variableDebtContract.UNDERLYING_ASSET_ADDRESS()).to.be.eq(dai.address);
        (0, chai_1.expect)(await variableDebtContract.POOL()).to.be.eq(pool.address);
        (0, chai_1.expect)(await variableDebtContract.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        const scaledUserBalanceAndSupplyUser0Before = await variableDebtContract.getScaledUserBalanceAndSupply(users[0].address);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser0Before[0]).to.be.eq(0);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser0Before[1]).to.be.eq(0);
        // Need to create some debt to do this good
        await faucetMintable.mint(dai.address, users[0].address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'));
        await dai.connect(users[0].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[0].signer)
            .deposit(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '1000'), users[0].address, 0);
        await faucetMintable.mint(weth.address, users[1].address, ethers_1.utils.parseEther('10'));
        await weth.connect(users[1].signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(users[1].signer)
            .deposit(weth.address, ethers_1.utils.parseEther('10'), users[1].address, 0);
        await pool
            .connect(users[1].signer)
            .borrow(dai.address, await (0, contracts_helpers_1.convertToCurrencyDecimals)(dai.address, '200'), types_1.RateMode.Variable, 0, users[1].address);
        const scaledUserBalanceAndSupplyUser0After = await variableDebtContract.getScaledUserBalanceAndSupply(users[0].address);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser0After[0]).to.be.eq(0);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser0After[1]).to.be.gt(0);
        const scaledUserBalanceAndSupplyUser1After = await variableDebtContract.getScaledUserBalanceAndSupply(users[1].address);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser1After[1]).to.be.gt(0);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser1After[1]).to.be.gt(0);
        (0, chai_1.expect)(scaledUserBalanceAndSupplyUser0After[1]).to.be.eq(scaledUserBalanceAndSupplyUser1After[1]);
    });
    it('Tries to mint not being the Pool (revert expected)', async () => {
        const { deployer, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, deployer.signer);
        await (0, chai_1.expect)(variableDebtContract.mint(deployer.address, deployer.address, '1', '1')).to.be.revertedWith(CALLER_MUST_BE_POOL);
    });
    it('Tries to burn not being the Pool (revert expected)', async () => {
        const { deployer, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, deployer.signer);
        await (0, chai_1.expect)(variableDebtContract.burn(deployer.address, '1', '1')).to.be.revertedWith(CALLER_MUST_BE_POOL);
    });
    it('Tries to mint with amountScaled == 0 (revert expected)', async () => {
        const { deployer, pool, dai, helpersContract, users } = testEnv;
        // Impersonate the Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, deployer.signer);
        await (0, chai_1.expect)(variableDebtContract
            .connect(poolSigner)
            .mint(users[0].address, users[0].address, 0, ethers_1.utils.parseUnits('1', 27))).to.be.revertedWith(INVALID_MINT_AMOUNT);
    });
    it('Tries to burn with amountScaled == 0 (revert expected)', async () => {
        const { deployer, pool, dai, helpersContract, users } = testEnv;
        // Impersonate the Pool
        await (0, funds_1.topUpNonPayableWithEther)(deployer.signer, [pool.address], ethers_1.utils.parseEther('1'));
        await (0, misc_utils_1.impersonateAccountsHardhat)([pool.address]);
        const poolSigner = await hre.ethers.getSigner(pool.address);
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, deployer.signer);
        await (0, chai_1.expect)(variableDebtContract.connect(poolSigner).burn(users[0].address, 0, ethers_1.utils.parseUnits('1', 27))).to.be.revertedWith(INVALID_BURN_AMOUNT);
    });
    it('Tries to transfer debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(variableDebtContract.connect(users[0].signer).transfer(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to approve debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(variableDebtContract.connect(users[0].signer).approve(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
        await (0, chai_1.expect)(variableDebtContract.allowance(users[0].address, users[1].address)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to increaseAllowance (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(variableDebtContract.connect(users[0].signer).increaseAllowance(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to decreaseAllowance (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(variableDebtContract.connect(users[0].signer).decreaseAllowance(users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('Tries to transferFrom debt tokens (revert expected)', async () => {
        const { users, dai, helpersContract } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, users[0].signer);
        await (0, chai_1.expect)(variableDebtContract
            .connect(users[0].signer)
            .transferFrom(users[0].address, users[1].address, 500)).to.be.revertedWith(types_1.ProtocolErrors.OPERATION_NOT_SUPPORTED);
    });
    it('setIncentivesController() ', async () => {
        const { dai, helpersContract, poolAdmin, aclManager, deployer } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, deployer.signer);
        (0, chai_1.expect)(await aclManager.connect(deployer.signer).addPoolAdmin(poolAdmin.address));
        (0, chai_1.expect)(await variableDebtContract.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        (0, chai_1.expect)(await variableDebtContract.connect(poolAdmin.signer).setIncentivesController(constants_1.ZERO_ADDRESS));
        (0, chai_1.expect)(await variableDebtContract.getIncentivesController()).to.be.eq(constants_1.ZERO_ADDRESS);
    });
    it('setIncentivesController() from not pool admin (revert expected)', async () => {
        const { dai, helpersContract, users: [user], } = testEnv;
        const daiVariableDebtTokenAddress = (await helpersContract.getReserveTokensAddresses(dai.address)).variableDebtTokenAddress;
        const variableDebtContract = types_2.VariableDebtToken__factory.connect(daiVariableDebtTokenAddress, user.signer);
        (0, chai_1.expect)(await variableDebtContract.getIncentivesController()).to.not.be.eq(constants_1.ZERO_ADDRESS);
        await (0, chai_1.expect)(variableDebtContract.connect(user.signer).setIncentivesController(constants_1.ZERO_ADDRESS)).to.be.revertedWith(CALLER_NOT_POOL_ADMIN);
    });
    it('Check Mint and Transfer events when borrowing on behalf', async () => {
        const { pool, weth, dai, users: [user1, user2, user3], faucetMintable } = testEnv;
        // Add liquidity
        await faucetMintable.mint(dai.address, user3.address, ethers_1.utils.parseEther('1000'));
        await dai.connect(user3.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user3.signer)
            .supply(dai.address, ethers_1.utils.parseUnits('1000', 18), user3.address, 0);
        // User1 supplies 10 WETH
        await faucetMintable.mint(weth.address, user1.address, ethers_1.utils.parseEther('10'));
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user1.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('10', 18), user1.address, 0);
        const daiData = await pool.getReserveData(dai.address);
        const variableDebtToken = types_2.VariableDebtToken__factory.connect(daiData.variableDebtTokenAddress, user1.signer);
        const beforeDebtBalanceUser2 = await variableDebtToken.balanceOf(user2.address);
        // User1 borrows 100 DAI
        const borrowAmount = ethers_1.utils.parseUnits('100', 18);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .borrow(dai.address, borrowAmount, types_1.RateMode.Variable, 0, user1.address));
        // User1 approves user2 to borrow 1000 DAI
        (0, chai_1.expect)(await variableDebtToken
            .connect(user1.signer)
            .approveDelegation(user2.address, ethers_1.utils.parseUnits('1000', 18)));
        // Increase time so interests accrue
        await (0, deploy_v3_1.increaseTime)(24 * 3600);
        const previousIndexUser1Before = await variableDebtToken.getPreviousIndex(user1.address);
        const previousIndexUser2Before = await variableDebtToken.getPreviousIndex(user2.address);
        // User2 borrows 100 DAI on behalf of user1
        const borrowOnBehalfAmount = ethers_1.utils.parseUnits('100', 18);
        const tx = await (0, deploy_v3_1.waitForTx)(await pool
            .connect(user2.signer)
            .borrow(dai.address, borrowOnBehalfAmount, types_1.RateMode.Variable, 0, user1.address));
        const previousIndexUser1After = await variableDebtToken.getPreviousIndex(user1.address);
        const previousIndexUser2After = await variableDebtToken.getPreviousIndex(user2.address);
        // User2 index should be the same
        (0, chai_1.expect)(previousIndexUser1Before).to.be.not.eq(previousIndexUser1After);
        (0, chai_1.expect)(previousIndexUser2Before).to.be.eq(previousIndexUser2After);
        const afterDebtBalanceUser1 = await variableDebtToken.balanceOf(user1.address);
        const interest = afterDebtBalanceUser1.sub(borrowAmount).sub(borrowOnBehalfAmount);
        const parsedTransferEvents = (0, tokenization_events_1.getVariableDebtTokenEvent)(variableDebtToken, tx, 'Transfer');
        const transferAmount = parsedTransferEvents[0].value;
        (0, chai_1.expect)(transferAmount).to.be.closeTo(borrowOnBehalfAmount.add(interest), 2);
        const parsedMintEvents = (0, tokenization_events_1.getVariableDebtTokenEvent)(variableDebtToken, tx, 'Mint');
        (0, chai_1.expect)(parsedMintEvents[0].value).to.be.closeTo(borrowOnBehalfAmount.add(interest), 2);
        (0, chai_1.expect)(parsedMintEvents[0].balanceIncrease).to.be.closeTo(interest, 2);
    });
    it('User borrows and repays in same block with zero fees', async () => {
        const { pool, users, dai, aDai, usdc, variableDebtDai, faucetMintable } = testEnv;
        const user = users[0];
        // We need some debt.
        await faucetMintable.mint(usdc.address, user.address, ethers_1.utils.parseEther('2000'));
        await usdc.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user.signer)
            .deposit(usdc.address, ethers_1.utils.parseEther('2000'), user.address, 0);
        await faucetMintable.mint(dai.address, user.address, ethers_1.utils.parseEther('2000'));
        await dai.connect(user.signer).transfer(aDai.address, ethers_1.utils.parseEther('2000'));
        await dai.connect(user.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        const userDataBefore = await pool.getUserAccountData(user.address);
        (0, chai_1.expect)(await variableDebtDai.balanceOf(user.address)).to.be.eq(0);
        // Turn off automining - pretty sure that coverage is getting messed up here.
        await (0, misc_utils_1.setAutomine)(false);
        // Borrow 500 dai
        await pool
            .connect(user.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('500'), types_1.RateMode.Variable, 0, user.address);
        // Turn on automining, but not mine a new block until next tx
        await (0, misc_utils_1.setAutomineEvm)(true);
        (0, chai_1.expect)(await pool
            .connect(user.signer)
            .repay(dai.address, ethers_1.utils.parseEther('500'), types_1.RateMode.Variable, user.address));
        (0, chai_1.expect)(await variableDebtDai.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(user.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(aDai.address)).to.be.eq(ethers_1.utils.parseEther('2000'));
        const userDataAfter = await pool.getUserAccountData(user.address);
        (0, chai_1.expect)(userDataBefore.totalCollateralBase).to.be.lte(userDataAfter.totalCollateralBase);
        (0, chai_1.expect)(userDataBefore.healthFactor).to.be.lte(userDataAfter.healthFactor);
        (0, chai_1.expect)(userDataBefore.totalDebtBase).to.be.eq(userDataAfter.totalDebtBase);
    });
    it('User borrows and repays in same block using credit delegation with zero fees', async () => {
        const { pool, dai, aDai, weth, users: [user1, user2, user3], faucetMintable } = testEnv;
        // Add liquidity
        await faucetMintable.mint(dai.address, user3.address, ethers_1.utils.parseEther('1000'));
        await dai.connect(user3.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user3.signer)
            .supply(dai.address, ethers_1.utils.parseUnits('1000', 18), user3.address, 0);
        // User1 supplies 10 WETH
        await faucetMintable.mint(dai.address, user1.address, ethers_1.utils.parseEther('100'));
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(weth.address, user1.address, ethers_1.utils.parseEther('10'));
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user1.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('10', 18), user1.address, 0);
        const daiData = await pool.getReserveData(dai.address);
        const variableDebtToken = await (0, deploy_v3_1.getVariableDebtToken)(daiData.variableDebtTokenAddress);
        // User1 approves User2 to borrow 1000 DAI
        (0, chai_1.expect)(await variableDebtToken
            .connect(user1.signer)
            .approveDelegation(user2.address, ethers_1.utils.parseUnits('1000', 18)));
        const userDataBefore = await pool.getUserAccountData(user1.address);
        // Turn off automining to simulate actions in same block
        await (0, misc_utils_1.setAutomine)(false);
        // User2 borrows 2 DAI on behalf of User1
        await pool
            .connect(user2.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Variable, 0, user1.address);
        // Turn on automining, but not mine a new block until next tx
        await (0, misc_utils_1.setAutomineEvm)(true);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .repay(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Variable, user1.address));
        (0, chai_1.expect)(await variableDebtToken.balanceOf(user1.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(user2.address)).to.be.eq(ethers_1.utils.parseEther('2'));
        (0, chai_1.expect)(await dai.balanceOf(aDai.address)).to.be.eq(ethers_1.utils.parseEther('1000'));
        const userDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userDataBefore.totalCollateralBase).to.be.lte(userDataAfter.totalCollateralBase);
        (0, chai_1.expect)(userDataBefore.healthFactor).to.be.lte(userDataAfter.healthFactor);
        (0, chai_1.expect)(userDataBefore.totalDebtBase).to.be.eq(userDataAfter.totalDebtBase);
    });
    it('User borrows and repays in same block using credit delegation with zero fees', async () => {
        const { pool, dai, aDai, weth, users: [user1, user2, user3], faucetMintable } = testEnv;
        // Add liquidity
        await faucetMintable.mint(dai.address, user3.address, ethers_1.utils.parseEther('1000'));
        await dai.connect(user3.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user3.signer)
            .supply(dai.address, ethers_1.utils.parseUnits('1000', 18), user3.address, 0);
        // User1 supplies 10 WETH
        await faucetMintable.mint(dai.address, user1.address, ethers_1.utils.parseEther('100'));
        await dai.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await faucetMintable.mint(weth.address, user1.address, ethers_1.utils.parseEther('10'));
        await weth.connect(user1.signer).approve(pool.address, constants_1.MAX_UINT_AMOUNT);
        await pool
            .connect(user1.signer)
            .supply(weth.address, ethers_1.utils.parseUnits('10', 18), user1.address, 0);
        const daiData = await pool.getReserveData(dai.address);
        const variableDebtToken = await (0, deploy_v3_1.getVariableDebtToken)(daiData.variableDebtTokenAddress);
        // User1 approves User2 to borrow 1000 DAI
        (0, chai_1.expect)(await variableDebtToken
            .connect(user1.signer)
            .approveDelegation(user2.address, ethers_1.utils.parseUnits('1000', 18)));
        const userDataBefore = await pool.getUserAccountData(user1.address);
        // Turn off automining to simulate actions in same block
        await (0, misc_utils_1.setAutomine)(false);
        // User2 borrows 2 DAI on behalf of User1
        await pool
            .connect(user2.signer)
            .borrow(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Variable, 0, user1.address);
        // Turn on automining, but not mine a new block until next tx
        await (0, misc_utils_1.setAutomineEvm)(true);
        (0, chai_1.expect)(await pool
            .connect(user1.signer)
            .repay(dai.address, ethers_1.utils.parseEther('2'), types_1.RateMode.Variable, user1.address));
        (0, chai_1.expect)(await variableDebtToken.balanceOf(user1.address)).to.be.eq(0);
        (0, chai_1.expect)(await dai.balanceOf(user2.address)).to.be.eq(ethers_1.utils.parseEther('2'));
        (0, chai_1.expect)(await dai.balanceOf(aDai.address)).to.be.eq(ethers_1.utils.parseEther('1000'));
        const userDataAfter = await pool.getUserAccountData(user1.address);
        (0, chai_1.expect)(userDataBefore.totalCollateralBase).to.be.lte(userDataAfter.totalCollateralBase);
        (0, chai_1.expect)(userDataBefore.healthFactor).to.be.lte(userDataAfter.healthFactor);
        (0, chai_1.expect)(userDataBefore.totalDebtBase).to.be.eq(userDataAfter.totalDebtBase);
    });
});
